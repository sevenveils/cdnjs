{"version":3,"sources":["webpack://parser/webpack/bootstrap","webpack://parser/./src/util.js","webpack://parser/./src/xmlstr2xmlnode.js","webpack://parser/./src/parser.js","webpack://parser/./src/node2json.js","webpack://parser/./src/xmlNode.js","webpack://parser/./src/nimndata.js","webpack://parser/./src/node2json_str.js","webpack://parser/./src/validator.js","webpack://parser/./src/json2xml.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","doesMatch","string","regex","match","exec","isExist","v","isEmptyObject","obj","keys","length","merge","target","a","len","getValue","buildOptions","options","defaultOptions","props","newOptions","undefined","doesNotMatch","getAllMatches","matches","allmatches","index","push","util","require","xmlNode","TagType","OPENING","CLOSING","SELF","CDATA","regx","Number","parseInt","window","parseFloat","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","localeRange","tagValueProcessor","attrValueProcessor","stopNodes","processTagValue","val","trim","parseValue","parseTrueNumberOnly","resolveNameSpace","tagname","tags","split","prefix","charAt","shouldParse","parsed","isNaN","indexOf","String","attrsRegx","RegExp","buildAttributesMap","attrStr","replace","attrs","attrName","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","tagsRegx","tag","nextTag","tagType","substr","parent","includes","child","attrsMap","startIndex","childNode","addChild","nodeToJson","xmlToNodeobj","x2xmlnode","parse","convertToJson","convertTonimn","convert2nimn","convertToJsonString","validate","j2xParser","parseToNimn","schema","node","jObj","this","Array","isArray","char","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","hasValidData","str","itemSchema","arr_len","arr_i","processValue","isAppChar","ch","x2j","_cToJsonStr","level","indentBy","readPI","start","err","code","msg","readCommentAndCDATA","angleBracketsCount","tagFound","regxAttrName","regxTagName","closingTag","tagName","substring","validateTagName","result","readAttributeStr","isValid","validateAttributeString","otg","pop","JSON","stringify","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","validateAttrName","format","supressEmptyNode","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","cdata","join","repeat","startsWith","j2x","attr","arrLen","j","item","Ks","L"],"mappings":"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","file":"./lib/parser.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","'use strict';\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst doesMatch = function(string, regex) {\n  const match = regex.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nconst doesNotMatch = function(string, regex) {\n  return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      target[keys[i]] = a[keys[i]];\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  var newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst TagType = {OPENING: 1, CLOSING: 2, SELF: 3, CDATA: 4};\nlet regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))([^>]*)>|((\\\\/)(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))\\\\s*>))([^<]*)';\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  localeRange: '',\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'localeRange',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'stopNodes'\n];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n  options = buildOptions(options, defaultOptions, props);\n  //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n  xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, ''); //Remove  comments\n\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n\n  regx = regx.replace(/\\[\\\\w/g, '[' + options.localeRange + '\\\\w');\n  const tagsRegx = new RegExp(regx, 'g');\n  let tag = tagsRegx.exec(xmlData);\n  let nextTag = tagsRegx.exec(xmlData);\n  while (tag) {\n    const tagType = checkForTagType(tag);\n\n    if (tagType === TagType.CLOSING) {\n      //add parsed data to parent node\n      if (currentNode.parent && tag[14]) {\n        currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue(tag[14], options);\n      }\n      if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n        currentNode.child = []\n        if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n        currentNode.val = xmlData.substr(currentNode.startIndex + 1, tag.index - currentNode.startIndex - 1)\n      }\n      currentNode = currentNode.parent;\n    } else if (tagType === TagType.CDATA) {\n      if (options.cdataTagName) {\n        //add cdata node\n        const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n        childNode.attrsMap = buildAttributesMap(tag[8], options);\n        currentNode.addChild(childNode);\n        //for backtracking\n        currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n        //add rest value to parent node\n        if (tag[14]) {\n          currentNode.val += processTagValue(tag[14], options);\n        }\n      } else {\n        currentNode.val = (currentNode.val || '') + (tag[3] || '') + processTagValue(tag[14], options);\n      }\n    } else if (tagType === TagType.SELF) {\n      if (currentNode && tag[14]) {\n        currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tag[14], options);\n      }\n\n      const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, '');\n      if (tag[8] && tag[8].length > 0) {\n        tag[8] = tag[8].substr(0, tag[8].length - 1);\n      }\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n    } else {\n      //TagType.OPENING\n      const childNode = new xmlNode(\n        options.ignoreNameSpace ? tag[7] : tag[5],\n        currentNode,\n        processTagValue(tag[14], options)\n      );\n      if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n        childNode.startIndex=tag.index + tag[1].length\n      }\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n      currentNode = childNode;\n    }\n\n    tag = nextTag;\n    nextTag = tagsRegx.exec(xmlData);\n  }\n\n  return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction checkForTagType(match) {\n  if (match[4] === ']]>') {\n    return TagType.CDATA;\n  } else if (match[10] === '/') {\n    return TagType.CLOSING;\n  } else if (typeof match[8] !== 'undefined' && match[8].substr(match[8].length - 1) === '/') {\n    return TagType.SELF;\n  } else {\n    return TagType.OPENING;\n  }\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4]);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.parseTrueNumberOnly\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","'use strict';\n\nconst nodeToJson = require('./node2json');\nconst xmlToNodeobj = require('./xmlstr2xmlnode');\nconst x2xmlnode = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\n\nexports.parse = function(xmlData, options) {\n  options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);\n  return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = require('../src/nimndata').convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require('./node2json_str').convertToJsonString;\nexports.validate = require('./validator').validate;\nexports.j2xParser = require('./json2xml');\nexports.parseToNimn = function(xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\n","'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options) {\n  const jObj = {};\n\n  //when no child node or attr is present\n  if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    //otherwise create a textnode if node has some text\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj[options.textNodeName] = node.val;\n      }\n    }\n  }\n\n  util.merge(jObj, node.attrsMap);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    var tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj[tagname] = [];\n      for (var tag in node.child[tagname]) {\n        jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n      }\n    } else {\n      jObj[tagname] = convertToJson(node.child[tagname][0], options);\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n","'use strict';\n\nmodule.exports = function(tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function(child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};\n","'use strict';\nconst char = function(a) {\n  return String.fromCharCode(a);\n};\n\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n\n  emptyChar: char(178),\n  emptyValue: char(177), //empty Premitive\n\n  boundryChar: char(179),\n\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185),\n};\n\nconst charsArr = [\n  chars.nilChar,\n  chars.nilPremitive,\n  chars.missingChar,\n  chars.missingPremitive,\n  chars.boundryChar,\n  chars.emptyChar,\n  chars.emptyValue,\n  chars.arrayEnd,\n  chars.objStart,\n  chars.arrStart,\n];\n\nconst _e = function(node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val, e_schema);\n    } else {\n      return getValue(node, e_schema);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //var itemSchemaType = itemSchema;\n        const arr_len = node.length;\n\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val, itemSchema);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\n\nconst getValue = function(a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\n\nconst processValue = function(str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\n\nconst isAppChar = function(ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (\n    jObj.child &&\n    Object.keys(jObj.child).length === 0 &&\n    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)\n  ) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\n\nconst x2j = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst x2j = require('./xmlstr2xmlnode');\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    var tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (var tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\n\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\n\nfunction indentate(options, level) {\n  return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  localeRange: 'a-zA-Z',\n};\n\nconst props = ['allowBooleanAttributes', 'localeRange'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n  options = util.buildOptions(options, defaultOptions, props);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n  const tags = [];\n  let tagFound = false;\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  const regxAttrName = new RegExp('^[_w][\\\\w\\\\-.:]*$'.replace('_w', '_' + options.localeRange));\n  const regxTagName = new RegExp('^([w]|_)[\\\\w.\\\\-_:]*'.replace('([w', '([' + options.localeRange));\n  for (let i = 0; i < xmlData.length; i++) {\n    if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n\n      i++;\n      if (xmlData[i] === '?') {\n        i = readPI(xmlData, ++i);\n        if (i.err) {\n          return i;\n        }\n      } else if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length && xmlData[i] !== '>' && xmlData[i] !== ' ' && xmlData[i] !== '\\t'; i++) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          continue;\n        }\n        if (!validateTagName(tagName, regxTagName)) {\n          return {err: {code: 'InvalidTag', msg: 'Tag ' + tagName + ' is an invalid name.'}};\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return {err: {code: 'InvalidAttr', msg: 'Attributes for ' + tagName + ' have open quote'}};\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options, regxAttrName);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            return isValid;\n          }\n        } else if (closingTag) {\n          if (attrStr.trim().length > 0) {\n            return {\n              err: {code: 'InvalidTag', msg: 'closing tag ' + tagName + \" can't have attributes or invalid starting.\"},\n            };\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg) {\n              return {\n                err: {code: 'InvalidTag', msg: 'closing tag ' + otg + ' is expected inplace of ' + tagName + '.'},\n              };\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options, regxAttrName);\n          if (isValid !== true) {\n            return isValid;\n          }\n          tags.push(tagName);\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else {\n              break;\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return {err: {code: 'InvalidChar', msg: 'char ' + xmlData[i] + ' is not expected .'}};\n    }\n  }\n\n  if (!tagFound) {\n    return {err: {code: 'InvalidXml', msg: 'Start tag expected.'}};\n  } else if (tags.length > 0) {\n    return {\n      err: {code: 'InvalidXml', msg: 'Invalid ' + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, '') + ' found.'},\n    };\n  }\n\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  var start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      var tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return {err: {code: 'InvalidXml', msg: 'XML declaration allowed only at the start of the document.'}};\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nvar doubleQuote = '\"';\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n        continue;\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options, regxAttrName) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    //console.log(matches[i]);\n\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return {err: {code: 'InvalidAttr', msg: 'attribute ' + matches[i][2] + ' has no space in starting.'}};\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return {err: {code: 'InvalidAttr', msg: 'boolean attribute ' + matches[i][2] + ' is not allowed.'}};\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName, regxAttrName)) {\n      return {err: {code: 'InvalidAttr', msg: 'attribute ' + attrName + ' is an invalid name.'}};\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return {err: {code: 'InvalidAttr', msg: 'attribute ' + attrName + ' is repeated.'}};\n    }\n  }\n\n  return true;\n}\n\n// const validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName, regxAttrName) {\n  // const validAttrRegxp = new RegExp(regxAttrName);\n  return util.doesMatch(attrName, regxAttrName);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\n//  startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname, regxTagName) {\n  /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n  return !util.doesNotMatch(tagname, regxTagName);\n}\n","'use strict';\n//parse Empty Node as self closing node\nconst buildOptions = require('./util').buildOptions;\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n};\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'cdataTagName',\n  'cdataPositionChar',\n  'format',\n  'indentBy',\n  'supressEmptyNode',\n  'tagValueProcessor',\n  'attrValueProcessor',\n];\n\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function(/*a*/) {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\n\nParser.prototype.parse = function(jObj) {\n  return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  const keys = Object.keys(jObj);\n  const len = keys.length;\n  for (let i = 0; i < len; i++) {\n    const key = keys[i];\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) {\n            //value will added while processing cdata\n          } else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') {\n            // supress undefined node\n          } else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            const result = this.j2x(item, level + 1);\n            val += this.buildObjNode(result.val, key, result.attrStr, level);\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        const result = this.j2x(jObj[key], level + 1);\n        val += this.buildObjNode(result.val, key, result.attrStr, level);\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && !val.includes('<')) {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      '>' +\n      val +\n      //+ this.newLine\n      // + this.indentate(level)\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  } else {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      this.tagEndChar +\n      val +\n      //+ this.newLine\n      this.indentate(level) +\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n  return (\n    this.indentate(level) +\n    '<' +\n    key +\n    attrStr +\n    '>' +\n    this.options.tagValueProcessor('' + val) +\n    '</' +\n    key +\n    this.tagEndChar\n  );\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n"],"sourceRoot":""}