/*!
 * videojs-record
 * @version 3.4.0
 * @see https://github.com/collab-project/videojs-record
 * @copyright 2014-2019 Collab
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("videojs"));
	else if(typeof define === 'function' && define.amd)
		define("VideojsRecord", ["videojs"], factory);
	else if(typeof exports === 'object')
		exports["VideojsRecord"] = factory(require("videojs"));
	else
		root["VideojsRecord"] = factory(root["videojs"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_video_js__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://VideojsRecord/./node_modules/global/window.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://VideojsRecord/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/css/videojs.record.scss":
/*!*************************************!*\
  !*** ./src/css/videojs.record.scss ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack://VideojsRecord/./src/css/videojs.record.scss?");

/***/ }),

/***/ "./src/js/controls/animation-display.js":
/*!**********************************************!*\
  !*** ./src/js/controls/animation-display.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @file animation-display.js\n * @since 2.0.0\n */\nvar Component = videojs.getComponent('Component');\n/**\n * Image for displaying animated GIF image.\n *\n * @class\n * @augments videojs.Component\n*/\n\nvar AnimationDisplay =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(AnimationDisplay, _Component);\n\n  function AnimationDisplay() {\n    _classCallCheck(this, AnimationDisplay);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AnimationDisplay).apply(this, arguments));\n  }\n\n  _createClass(AnimationDisplay, [{\n    key: \"createEl\",\n\n    /**\n     * Create the `AnimationDisplay`s DOM element.\n     *\n     * @return {Element}\n     *         The dom element that gets created.\n     */\n    value: function createEl() {\n      return _get(_getPrototypeOf(AnimationDisplay.prototype), \"createEl\", this).call(this, 'div', {\n        className: 'vjs-animation-display',\n        innerHTML: '<img />'\n      });\n    }\n  }]);\n\n  return AnimationDisplay;\n}(Component);\n\nComponent.registerComponent('AnimationDisplay', AnimationDisplay);\nvar _default = AnimationDisplay;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/controls/animation-display.js?");

/***/ }),

/***/ "./src/js/controls/camera-button.js":
/*!******************************************!*\
  !*** ./src/js/controls/camera-button.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @file camera-button.js\n * @since 2.0.0\n */\nvar Button = videojs.getComponent('Button');\nvar Component = videojs.getComponent('Component');\n/**\n * Button to toggle between create and retry snapshot image.\n *\n * @class\n * @augments videojs.Button\n*/\n\nvar CameraButton =\n/*#__PURE__*/\nfunction (_Button) {\n  _inherits(CameraButton, _Button);\n\n  function CameraButton() {\n    _classCallCheck(this, CameraButton);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CameraButton).apply(this, arguments));\n  }\n\n  _createClass(CameraButton, [{\n    key: \"buildCSSClass\",\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    value: function buildCSSClass() {\n      return 'vjs-camera-button vjs-control vjs-button vjs-icon-photo-camera';\n    }\n    /**\n     * Enable the `CameraButton` element so that it can be activated or clicked.\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      _get(_getPrototypeOf(CameraButton.prototype), \"enable\", this).call(this);\n\n      this.on(this.player_, 'startRecord', this.onStart);\n      this.on(this.player_, 'stopRecord', this.onStop);\n    }\n    /**\n     * Disable the `CameraButton` element so that it cannot be activated or clicked.\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      _get(_getPrototypeOf(CameraButton.prototype), \"disable\", this).call(this);\n\n      this.off(this.player_, 'startRecord', this.onStart);\n      this.off(this.player_, 'stopRecord', this.onStop);\n    }\n    /**\n     * Show the `CameraButton` element if it is hidden by removing the\n     * 'vjs-hidden' class name from it.\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.layoutExclude && this.layoutExclude === true) {\n        // ignore\n        return;\n      }\n\n      _get(_getPrototypeOf(CameraButton.prototype), \"show\", this).call(this);\n    }\n    /**\n     * This gets called when the button is clicked.\n     *\n     * @param {EventTarget~Event} event\n     *        The `tap` or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event) {\n      var recorder = this.player_.record();\n\n      if (!recorder.isProcessing()) {\n        // create snapshot\n        recorder.start();\n      } else {\n        // retry\n        recorder.retrySnapshot(); // reset camera button\n\n        this.onStop();\n      }\n    }\n    /**\n     * Add the vjs-icon-replay class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#startRecord\n     */\n\n  }, {\n    key: \"onStart\",\n    value: function onStart(event) {\n      // replace element class so it can change appearance\n      this.removeClass('vjs-icon-photo-camera');\n      this.addClass('vjs-icon-replay'); // change the button text\n\n      this.controlText('Retry');\n    }\n    /**\n     * Add the vjs-icon-photo-camera class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#stopRecord\n     */\n\n  }, {\n    key: \"onStop\",\n    value: function onStop(event) {\n      // replace element class so it can change appearance\n      this.removeClass('vjs-icon-replay');\n      this.addClass('vjs-icon-photo-camera'); // change the button text\n\n      this.controlText('Image');\n    }\n  }]);\n\n  return CameraButton;\n}(Button);\n/**\n * The text that should display over the `CameraButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nCameraButton.prototype.controlText_ = 'Image';\nComponent.registerComponent('CameraButton', CameraButton);\nvar _default = CameraButton;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/controls/camera-button.js?");

/***/ }),

/***/ "./src/js/controls/device-button.js":
/*!******************************************!*\
  !*** ./src/js/controls/device-button.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @file device-button.js\n * @since 2.0.0\n */\nvar Button = videojs.getComponent('Button');\nvar Component = videojs.getComponent('Component');\n/**\n * Button to select recording device.\n *\n * @class\n * @augments videojs.Button\n*/\n\nvar DeviceButton =\n/*#__PURE__*/\nfunction (_Button) {\n  _inherits(DeviceButton, _Button);\n\n  function DeviceButton() {\n    _classCallCheck(this, DeviceButton);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeviceButton).apply(this, arguments));\n  }\n\n  _createClass(DeviceButton, [{\n    key: \"handleClick\",\n\n    /**\n     * This gets called when this button gets:\n     *\n     * - Clicked (via the `click` event, listening starts in the constructor)\n     * - Tapped (via the `tap` event, listening starts in the constructor)\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    value: function handleClick(event) {\n      // open device dialog\n      this.player_.record().getDevice();\n    }\n    /**\n     * Show the `DeviceButton` element if it is hidden by removing the\n     * 'vjs-hidden' class name from it.\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.layoutExclude && this.layoutExclude === true) {\n        // ignore\n        return;\n      }\n\n      _get(_getPrototypeOf(DeviceButton.prototype), \"show\", this).call(this);\n    }\n  }]);\n\n  return DeviceButton;\n}(Button);\n/**\n * The text that should display over the `DeviceButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nDeviceButton.prototype.controlText_ = 'Device';\nComponent.registerComponent('DeviceButton', DeviceButton);\nvar _default = DeviceButton;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/controls/device-button.js?");

/***/ }),

/***/ "./src/js/controls/record-canvas.js":
/*!******************************************!*\
  !*** ./src/js/controls/record-canvas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @file record-canvas\n * @since 2.0.0\n */\nvar Component = videojs.getComponent('Component');\n/**\n * Canvas for displaying snapshot image.\n *\n * @class\n * @augments videojs.Component\n*/\n\nvar RecordCanvas =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(RecordCanvas, _Component);\n\n  function RecordCanvas() {\n    _classCallCheck(this, RecordCanvas);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RecordCanvas).apply(this, arguments));\n  }\n\n  _createClass(RecordCanvas, [{\n    key: \"createEl\",\n\n    /**\n     * Create the `RecordCanvas`s DOM element.\n     *\n     * @return {Element}\n     *         The dom element that gets created.\n     */\n    value: function createEl() {\n      return _get(_getPrototypeOf(RecordCanvas.prototype), \"createEl\", this).call(this, 'div', {\n        className: 'vjs-record-canvas',\n        innerHTML: '<canvas></canvas>'\n      });\n    }\n  }]);\n\n  return RecordCanvas;\n}(Component);\n\nComponent.registerComponent('RecordCanvas', RecordCanvas);\nvar _default = RecordCanvas;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/controls/record-canvas.js?");

/***/ }),

/***/ "./src/js/controls/record-indicator.js":
/*!*********************************************!*\
  !*** ./src/js/controls/record-indicator.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @file record-indicator.js\n * @since 2.0.0\n */\nvar Component = videojs.getComponent('Component');\n/**\n * Icon indicating recording is active.\n *\n * @class\n * @augments videojs.Component\n*/\n\nvar RecordIndicator =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(RecordIndicator, _Component);\n\n  /**\n   * The constructor function for the class.\n   *\n   * @private\n   * @param {(videojs.Player|Object)} player - Video.js player instance.\n   * @param {Object} options - Player options.\n   */\n  function RecordIndicator(player, options) {\n    var _this;\n\n    _classCallCheck(this, RecordIndicator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RecordIndicator).call(this, player, options));\n\n    _this.enable();\n\n    return _this;\n  }\n  /**\n   * Create the `RecordIndicator`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */\n\n\n  _createClass(RecordIndicator, [{\n    key: \"createEl\",\n    value: function createEl() {\n      return _get(_getPrototypeOf(RecordIndicator.prototype), \"createEl\", this).call(this, 'div', {\n        className: 'vjs-record-indicator vjs-control',\n        dir: 'ltr'\n      });\n    }\n    /**\n     * Enable event handlers.\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.on(this.player_, 'startRecord', this.show);\n      this.on(this.player_, 'stopRecord', this.hide);\n    }\n    /**\n     * Disable event handlers.\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.off(this.player_, 'startRecord', this.show);\n      this.off(this.player_, 'stopRecord', this.hide);\n    }\n    /**\n     * Show the `RecordIndicator` element if it is hidden by removing the\n     * 'vjs-hidden' class name from it.\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.layoutExclude && this.layoutExclude === true) {\n        // ignore\n        return;\n      }\n\n      _get(_getPrototypeOf(RecordIndicator.prototype), \"show\", this).call(this);\n    }\n  }]);\n\n  return RecordIndicator;\n}(Component);\n\nComponent.registerComponent('RecordIndicator', RecordIndicator);\nvar _default = RecordIndicator;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/controls/record-indicator.js?");

/***/ }),

/***/ "./src/js/controls/record-toggle.js":
/*!******************************************!*\
  !*** ./src/js/controls/record-toggle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @file record-toggle.js\n * @since 2.0.0\n */\nvar Button = videojs.getComponent('Button');\nvar Component = videojs.getComponent('Component');\n/**\n * Button to toggle between start and stop recording.\n *\n * @class\n * @augments videojs.Button\n*/\n\nvar RecordToggle =\n/*#__PURE__*/\nfunction (_Button) {\n  _inherits(RecordToggle, _Button);\n\n  function RecordToggle() {\n    _classCallCheck(this, RecordToggle);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RecordToggle).apply(this, arguments));\n  }\n\n  _createClass(RecordToggle, [{\n    key: \"buildCSSClass\",\n\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    value: function buildCSSClass() {\n      return 'vjs-record-button vjs-control vjs-button vjs-icon-record-start';\n    }\n    /**\n     * Enable the `RecordToggle` element so that it can be activated or clicked.\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      _get(_getPrototypeOf(RecordToggle.prototype), \"enable\", this).call(this);\n\n      this.on(this.player_, 'startRecord', this.onStart);\n      this.on(this.player_, 'stopRecord', this.onStop);\n    }\n    /**\n     * Disable the `RecordToggle` element so that it cannot be activated or clicked.\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      _get(_getPrototypeOf(RecordToggle.prototype), \"disable\", this).call(this);\n\n      this.off(this.player_, 'startRecord', this.onStart);\n      this.off(this.player_, 'stopRecord', this.onStop);\n    }\n    /**\n     * Show the `RecordToggle` element if it is hidden by removing the\n     * 'vjs-hidden' class name from it.\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.layoutExclude && this.layoutExclude === true) {\n        // ignore\n        return;\n      }\n\n      _get(_getPrototypeOf(RecordToggle.prototype), \"show\", this).call(this);\n    }\n    /**\n     * This gets called when the button is clicked.\n     *\n     * @param {EventTarget~Event} event\n     *        The `tap` or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event) {\n      var recorder = this.player_.record();\n\n      if (!recorder.isRecording()) {\n        recorder.start();\n      } else {\n        recorder.stop();\n      }\n    }\n    /**\n     * Add the vjs-icon-record-stop class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#startRecord\n     */\n\n  }, {\n    key: \"onStart\",\n    value: function onStart(event) {\n      // replace element class so it can change appearance\n      this.removeClass('vjs-icon-record-start');\n      this.addClass('vjs-icon-record-stop'); // change the button text\n\n      this.controlText('Stop');\n    }\n    /**\n     * Add the vjs-icon-record-start class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#stopRecord\n     */\n\n  }, {\n    key: \"onStop\",\n    value: function onStop(event) {\n      // replace element class so it can change appearance\n      this.removeClass('vjs-icon-record-stop');\n      this.addClass('vjs-icon-record-start'); // change the button text\n\n      this.controlText('Record');\n    }\n  }]);\n\n  return RecordToggle;\n}(Button);\n/**\n * The text that should display over the `RecordToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nRecordToggle.prototype.controlText_ = 'Record';\nComponent.registerComponent('RecordToggle', RecordToggle);\nvar _default = RecordToggle;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/controls/record-toggle.js?");

/***/ }),

/***/ "./src/js/defaults.js":
/*!****************************!*\
  !*** ./src/js/defaults.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * @file defaults.js\n * @since 2.0.0\n */\n// plugin defaults\nvar pluginDefaultOptions = {\n  // Single snapshot image.\n  image: false,\n  // Include audio in the recorded clip.\n  audio: false,\n  // Include video in the recorded clip.\n  video: false,\n  // Animated GIF.\n  animation: false,\n  // Screen capture.\n  screen: false,\n  // Maximum length of the recorded clip.\n  maxLength: 10,\n  // Maximum file size of the recorded clip. Works only when the timeSlice\n  // option is also enabled.\n  maxFileSize: 0,\n  // msDisplayMax indicates the number of seconds that is\n  // considered the boundary value for displaying milliseconds\n  // in the time controls. An audio clip with a total length of\n  // 2 seconds and a msDisplayMax of 3 will use the format\n  // M:SS:MMM. Clips longer than msDisplayMax will be displayed\n  // as M:SS or HH:MM:SS.\n  msDisplayMax: 3,\n  // Width of the recorded video frames.\n  frameWidth: 320,\n  // Height of the recorded video frames.\n  frameHeight: 240,\n  // Enables console logging for debugging purposes.\n  debug: false,\n  // Turn off the camera/mic (and light) when audio and/or video recording\n  // stops, and turns them on again when you resume recording.\n  autoMuteDevice: false,\n  // The mime type for the video recorder. Default to 'video/webm'.\n  // Use 'video/mp4' (Firefox) or 'video/webm;codecs=H264' (Chrome 52 and\n  // newer) for MP4.\n  videoMimeType: 'video/webm',\n  // Video recorder type to use. This allows you to specify an alternative\n  // recorder class, e.g. WhammyRecorder. Defaults to 'auto' which let's\n  // recordrtc specify the best available recorder type.\n  videoRecorderType: 'auto',\n  // Audio recording library to use. Legal values are 'recordrtc',\n  // 'libvorbis.js', 'opus-recorder', 'lamejs', 'vmsg' and 'recorder.js'.\n  audioEngine: 'recordrtc',\n  // Audio recorder type to use. This allows you to specify an alternative\n  // recorder class, e.g. StereoAudioRecorder. Defaults to 'auto' which let's\n  // recordrtc specify the best available recorder type. Currently this\n  // setting is only used with the 'recordrtc' audioEngine.\n  audioRecorderType: 'auto',\n  // The mime type for the audio recorder. Defaults to 'auto' which will pick\n  // the best option available in the browser (e.g. either 'audio/wav',\n  // 'audio/ogg' or 'audio/webm').\n  audioMimeType: 'auto',\n  // The size of the audio buffer (in sample-frames) which needs to\n  // be processed each time onprocessaudio is called.\n  // From the spec: This value controls how frequently the audioprocess event is\n  // dispatched and how many sample-frames need to be processed each call.\n  // Lower values for buffer size will result in a lower (better) latency.\n  // Higher values will be necessary to avoid audio breakup and glitches.\n  // Legal values are 256, 512, 1024, 2048, 4096, 8192 or 16384.\n  audioBufferSize: 4096,\n  // The audio sample rate (in sample-frames per second) at which the\n  // AudioContext handles audio. It is assumed that all AudioNodes\n  // in the context run at this rate. In making this assumption,\n  // sample-rate converters or \"varispeed\" processors are not supported\n  // in real-time processing.\n  // The sampleRate parameter describes the sample-rate of the\n  // linear PCM audio data in the buffer in sample-frames per second.\n  // An implementation must support sample-rates in at least\n  // the range 22050 to 96000.\n  audioSampleRate: 44100,\n  // The audio bitrate in kbps (only used in lamejs plugin).\n  audioBitRate: 128,\n  // Allows you to record single-channel audio, which can reduce the\n  // file size.\n  audioChannels: 2,\n  // URL for the audio worker.\n  audioWorkerURL: '',\n  // Enables the audioBufferUpdate event that provides realtime AudioBuffer\n  // instances from the input audio device.\n  audioBufferUpdate: false,\n  // Frame rate in frames per second.\n  animationFrameRate: 200,\n  // Sets quality of color quantization (conversion of images to the\n  // maximum 256 colors allowed by the GIF specification).\n  // Lower values (minimum = 1) produce better colors,\n  // but slow processing significantly. 10 is the default,\n  // and produces good color mapping at reasonable speeds.\n  // Values greater than 20 do not yield significant improvements\n  // in speed.\n  animationQuality: 10,\n  // Accepts numbers in milliseconds; use this to force intervals-based blobs.\n  timeSlice: 0,\n  // Media converter library to use. Legal values are 'ts-ebml' or an empty\n  // string '' to disable (default).\n  convertEngine: ''\n};\nvar _default = pluginDefaultOptions;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/defaults.js?");

/***/ }),

/***/ "./src/js/engine/convert-engine.js":
/*!*****************************************!*\
  !*** ./src/js/engine/convert-engine.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSEBML = exports.CONVERT_PLUGINS = exports.ConvertEngine = void 0;\n\nvar _fileUtil = __webpack_require__(/*! ../utils/file-util */ \"./src/js/utils/file-util.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Component = videojs.getComponent('Component'); // supported convert plugin engines\n\nvar TSEBML = 'ts-ebml'; // all convert plugins\n\nexports.TSEBML = TSEBML;\nvar CONVERT_PLUGINS = [TSEBML];\n/**\n * Base class for converter backends.\n * @class\n * @augments videojs.Component\n */\n\nexports.CONVERT_PLUGINS = CONVERT_PLUGINS;\n\nvar ConvertEngine =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ConvertEngine, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player - The `Player` that this class should be\n   *     attached to.\n   * @param  {Object} [options] - The key/value store of player options.\n   */\n  function ConvertEngine(player, options) {\n    _classCallCheck(this, ConvertEngine);\n\n    // auto mixin the evented mixin (required since video.js v6.6.0)\n    options.evented = true;\n    return _possibleConstructorReturn(this, _getPrototypeOf(ConvertEngine).call(this, player, options));\n  }\n  /**\n   * Setup recording engine.\n   *\n   * @param {Object} mediaType - Object describing the media type of this\n   *     engine.\n   * @param {Boolean} debug - Indicating whether or not debug messages should\n   *     be printed in the console.\n   */\n\n\n  _createClass(ConvertEngine, [{\n    key: \"setup\",\n    value: function setup(mediaType, debug) {\n      this.mediaType = mediaType;\n      this.debug = debug;\n    }\n    /**\n     * Load `Blob` and return `Promise`.\n     *\n     * @param {Blob} data - `Blob` to load.\n     * @returns {Promise} - Promise with `ArrayBuffer` data.\n     */\n\n  }, {\n    key: \"loadBlob\",\n    value: function loadBlob(data) {\n      return (0, _fileUtil.blobToArrayBuffer)(data);\n    }\n    /**\n     * Add filename and timestamp to converted file object.\n     *\n     * @param {(Blob|File)} fileObj - `Blob` or `File` object to modify.\n     * @param {date} [now] - Optional date information, default is\n     *    current timestamp.\n     */\n\n  }, {\n    key: \"addFileInfo\",\n    value: function addFileInfo(fileObj, now) {\n      (0, _fileUtil.addFileInfo)(fileObj, now);\n    }\n  }]);\n\n  return ConvertEngine;\n}(Component); // expose component for external plugins\n\n\nexports.ConvertEngine = ConvertEngine;\nvideojs.ConvertEngine = ConvertEngine;\nComponent.registerComponent('ConvertEngine', ConvertEngine);\n\n//# sourceURL=webpack://VideojsRecord/./src/js/engine/convert-engine.js?");

/***/ }),

/***/ "./src/js/engine/engine-loader.js":
/*!****************************************!*\
  !*** ./src/js/engine/engine-loader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getConvertEngine = exports.isAudioPluginActive = exports.getAudioEngine = void 0;\n\nvar _recordRtc = _interopRequireDefault(__webpack_require__(/*! ./record-rtc */ \"./src/js/engine/record-rtc.js\"));\n\nvar _convertEngine = __webpack_require__(/*! ./convert-engine */ \"./src/js/engine/convert-engine.js\");\n\nvar _recordEngine = __webpack_require__(/*! ./record-engine */ \"./src/js/engine/record-engine.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @file engine-loader.js\n * @since 3.3.0\n */\n\n/**\n * Get audio plugin engine class.\n *\n * @private\n * @param {String} audioEngine - Name of the audio engine.\n * @returns {Object} Audio engine class.\n */\nvar getAudioEngine = function getAudioEngine(audioEngine) {\n  var AudioEngineClass;\n\n  switch (audioEngine) {\n    case _recordEngine.RECORDRTC:\n      // RecordRTC.js (default)\n      AudioEngineClass = _recordRtc.default;\n      break;\n\n    case _recordEngine.LIBVORBISJS:\n      // libvorbis.js\n      AudioEngineClass = videojs.LibVorbisEngine;\n      break;\n\n    case _recordEngine.RECORDERJS:\n      // recorder.js\n      AudioEngineClass = videojs.RecorderjsEngine;\n      break;\n\n    case _recordEngine.LAMEJS:\n      // lamejs\n      AudioEngineClass = videojs.LamejsEngine;\n      break;\n\n    case _recordEngine.OPUSRECORDER:\n      // opus-recorder\n      AudioEngineClass = videojs.OpusRecorderEngine;\n      break;\n\n    case _recordEngine.VMSG:\n      // vmsg\n      AudioEngineClass = videojs.VmsgEngine;\n      break;\n\n    default:\n      // unknown engine\n      throw new Error('Unknown audioEngine: ' + audioEngine);\n  }\n\n  return AudioEngineClass;\n};\n/**\n * Check whether any audio record plugins are enabled.\n *\n * @private\n * @param {String} audioEngine - Name of the audio engine.\n * @returns {Boolean} Whether any audio plugins are enabled or not.\n */\n\n\nexports.getAudioEngine = getAudioEngine;\n\nvar isAudioPluginActive = function isAudioPluginActive(audioEngine) {\n  return _recordEngine.AUDIO_PLUGINS.indexOf(audioEngine) > -1;\n};\n/**\n * Get converter plugin engine class.\n *\n * @private\n * @param {String} convertEngine - Name of the convert engine.\n * @returns {Object} Convert engine class.\n */\n\n\nexports.isAudioPluginActive = isAudioPluginActive;\n\nvar getConvertEngine = function getConvertEngine(convertEngine) {\n  var ConvertEngineClass;\n\n  switch (convertEngine) {\n    case '':\n      // disabled (default)\n      break;\n\n    case _convertEngine.TSEBML:\n      // ts-ebml\n      ConvertEngineClass = videojs.TsEBMLEngine;\n      break;\n\n    default:\n      // unknown engine\n      throw new Error('Unknown convertEngine: ' + convertEngine);\n  }\n\n  return ConvertEngineClass;\n};\n\nexports.getConvertEngine = getConvertEngine;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/engine/engine-loader.js?");

/***/ }),

/***/ "./src/js/engine/record-engine.js":
/*!****************************************!*\
  !*** ./src/js/engine/record-engine.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VMSG = exports.OPUSRECORDER = exports.LAMEJS = exports.RECORDERJS = exports.LIBVORBISJS = exports.RECORDRTC = exports.AUDIO_PLUGINS = exports.RECORD_PLUGINS = exports.RecordEngine = void 0;\n\nvar _fileUtil = __webpack_require__(/*! ../utils/file-util */ \"./src/js/utils/file-util.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Component = videojs.getComponent('Component'); // supported recorder plugin engines\n// builtin\n\nvar RECORDRTC = 'recordrtc'; // audio\n\nexports.RECORDRTC = RECORDRTC;\nvar LIBVORBISJS = 'libvorbis.js';\nexports.LIBVORBISJS = LIBVORBISJS;\nvar RECORDERJS = 'recorder.js';\nexports.RECORDERJS = RECORDERJS;\nvar LAMEJS = 'lamejs';\nexports.LAMEJS = LAMEJS;\nvar OPUSRECORDER = 'opus-recorder';\nexports.OPUSRECORDER = OPUSRECORDER;\nvar VMSG = 'vmsg'; // all audio plugins\n\nexports.VMSG = VMSG;\nvar AUDIO_PLUGINS = [LIBVORBISJS, RECORDERJS, LAMEJS, OPUSRECORDER, VMSG]; // all record plugins\n\nexports.AUDIO_PLUGINS = AUDIO_PLUGINS;\nvar RECORD_PLUGINS = AUDIO_PLUGINS;\n/**\n * Base class for recorder backends.\n * @class\n * @augments videojs.Component\n */\n\nexports.RECORD_PLUGINS = RECORD_PLUGINS;\n\nvar RecordEngine =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(RecordEngine, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function RecordEngine(player, options) {\n    _classCallCheck(this, RecordEngine);\n\n    // auto mixin the evented mixin (required since video.js v6.6.0)\n    options.evented = true;\n    return _possibleConstructorReturn(this, _getPrototypeOf(RecordEngine).call(this, player, options));\n  }\n  /**\n   * Remove any temporary data and references to streams.\n   * @private\n   */\n\n\n  _createClass(RecordEngine, [{\n    key: \"dispose\",\n    value: function dispose() {\n      // dispose previous recording\n      if (this.recordedData !== undefined) {\n        URL.revokeObjectURL(this.recordedData);\n      }\n    }\n    /**\n     * Add filename and timestamp to recorded file object.\n     *\n     * @param {(Blob|File)} fileObj - Blob or File object to modify.\n     */\n\n  }, {\n    key: \"addFileInfo\",\n    value: function addFileInfo(fileObj) {\n      (0, _fileUtil.addFileInfo)(fileObj);\n    }\n    /**\n     * Invoked when recording is stopped and resulting stream is available.\n     *\n     * @param {blob} data - Reference to the recorded `Blob`.\n     * @private\n     */\n\n  }, {\n    key: \"onStopRecording\",\n    value: function onStopRecording(data) {\n      this.recordedData = data; // add filename and timestamp to recorded file object\n\n      this.addFileInfo(this.recordedData); // remove reference to recorded stream\n\n      this.dispose(); // notify listeners\n\n      this.trigger('recordComplete');\n    }\n    /**\n     * Show save as dialog in browser so the user can store the recorded media\n     * locally.\n     *\n     * @param {Object} name - Object with names for the particular blob(s)\n     *     you want to save. File extensions are added automatically. For\n     *     example: {'video': 'name-of-video-file'}. Supported keys are\n     *     'audio', 'video' and 'gif'.\n     * @example\n     * // save video file as 'foo.webm'\n     * player.record().saveAs({'video': 'foo'});\n     * @returns {void}\n     */\n\n  }, {\n    key: \"saveAs\",\n    value: function saveAs(name) {\n      var fileName = name[Object.keys(name)[0]]; // download recorded file\n\n      (0, _fileUtil.downloadBlob)(fileName, this.recordedData);\n    }\n  }]);\n\n  return RecordEngine;\n}(Component); // expose component for external plugins\n\n\nexports.RecordEngine = RecordEngine;\nvideojs.RecordEngine = RecordEngine;\nComponent.registerComponent('RecordEngine', RecordEngine);\n\n//# sourceURL=webpack://VideojsRecord/./src/js/engine/record-engine.js?");

/***/ }),

/***/ "./src/js/engine/record-mode.js":
/*!**************************************!*\
  !*** ./src/js/engine/record-mode.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SCREEN_ONLY = exports.ANIMATION = exports.AUDIO_VIDEO = exports.VIDEO_ONLY = exports.AUDIO_ONLY = exports.IMAGE_ONLY = exports.getRecorderMode = void 0;\n\n/**\n * @file record-mode.js\n * @since 2.0.0\n */\n// recorder modes\nvar IMAGE_ONLY = 'image_only';\nexports.IMAGE_ONLY = IMAGE_ONLY;\nvar AUDIO_ONLY = 'audio_only';\nexports.AUDIO_ONLY = AUDIO_ONLY;\nvar VIDEO_ONLY = 'video_only';\nexports.VIDEO_ONLY = VIDEO_ONLY;\nvar AUDIO_VIDEO = 'audio_video';\nexports.AUDIO_VIDEO = AUDIO_VIDEO;\nvar ANIMATION = 'animation';\nexports.ANIMATION = ANIMATION;\nvar SCREEN_ONLY = 'screen_only';\nexports.SCREEN_ONLY = SCREEN_ONLY;\n\nvar getRecorderMode = function getRecorderMode(image, audio, video, animation, screen) {\n  if (isModeEnabled(image)) {\n    return IMAGE_ONLY;\n  } else if (isModeEnabled(animation)) {\n    return ANIMATION;\n  } else if (isModeEnabled(screen)) {\n    return SCREEN_ONLY;\n  } else if (isModeEnabled(audio) && !isModeEnabled(video)) {\n    return AUDIO_ONLY;\n  } else if (isModeEnabled(audio) && isModeEnabled(video)) {\n    return AUDIO_VIDEO;\n  } else if (!isModeEnabled(audio) && isModeEnabled(video)) {\n    return VIDEO_ONLY;\n  }\n};\n/**\n * Check whether mode is enabled or not.\n *\n * @param {(Object|Boolean)} mode - Mode.\n * @returns {Boolean} Return boolean indicating whether mode is enabled or not.\n * @private\n */\n\n\nexports.getRecorderMode = getRecorderMode;\n\nvar isModeEnabled = function isModeEnabled(mode) {\n  return mode === Object(mode) || mode === true;\n};\n\n//# sourceURL=webpack://VideojsRecord/./src/js/engine/record-mode.js?");

/***/ }),

/***/ "./src/js/engine/record-rtc.js":
/*!*************************************!*\
  !*** ./src/js/engine/record-rtc.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _recordEngine = __webpack_require__(/*! ./record-engine */ \"./src/js/engine/record-engine.js\");\n\nvar _detectBrowser = __webpack_require__(/*! ../utils/detect-browser */ \"./src/js/utils/detect-browser.js\");\n\nvar _recordMode = __webpack_require__(/*! ./record-mode */ \"./src/js/engine/record-mode.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Component = videojs.getComponent('Component');\n/**\n * Engine used with the MRecordRTC class in the RecordRTC library.\n *\n * @class\n * @augments videojs.RecordEngine\n */\n\nvar RecordRTCEngine =\n/*#__PURE__*/\nfunction (_RecordEngine) {\n  _inherits(RecordRTCEngine, _RecordEngine);\n\n  function RecordRTCEngine() {\n    _classCallCheck(this, RecordRTCEngine);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RecordRTCEngine).apply(this, arguments));\n  }\n\n  _createClass(RecordRTCEngine, [{\n    key: \"setup\",\n\n    /**\n     * Setup recording engine.\n     *\n     * @param {LocalMediaStream} stream - Media stream to record.\n     * @param {Object} mediaType - Object describing the media type of this\n     *     engine.\n     * @param {Boolean} debug - Indicating whether or not debug messages should\n     *     be printed in the console.\n     */\n    value: function setup(stream, mediaType, debug) {\n      this.inputStream = stream;\n      this.mediaType = mediaType;\n      this.debug = debug;\n\n      if ('screen' in this.mediaType) {\n        this.mediaType.video = true;\n      } // setup RecordRTC\n\n\n      this.engine = new RecordRTC.MRecordRTC();\n      this.engine.mediaType = this.mediaType;\n      this.engine.disableLogs = !this.debug;\n      this.engine.mimeType = this.mimeType; // audio settings\n\n      this.engine.bufferSize = this.bufferSize;\n      this.engine.sampleRate = this.sampleRate;\n      this.engine.numberOfAudioChannels = this.audioChannels; // video/canvas settings\n\n      this.engine.video = this.video;\n      this.engine.canvas = this.canvas; // animated gif settings\n\n      this.engine.quality = this.quality;\n      this.engine.frameRate = this.frameRate;\n\n      if (this.onTimeStamp !== undefined) {\n        this.engine.timeSlice = this.timeSlice;\n        this.engine.onTimeStamp = this.onTimeStamp;\n      } // connect stream to recording engine\n\n\n      this.engine.addStream(this.inputStream);\n    }\n    /**\n     * Remove any temporary data and references to streams.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(RecordRTCEngine.prototype), \"dispose\", this).call(this);\n\n      if (typeof this.engine.destroy === 'function') {\n        this.engine.destroy();\n      }\n    }\n    /**\n     * Start recording.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.engine.startRecording();\n    }\n    /**\n     * Stop recording. Result will be available async when onStopRecording\n     * is called.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.engine.stopRecording(this.onStopRecording.bind(this));\n    }\n    /**\n     * Pause recording.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.engine.pauseRecording();\n    }\n    /**\n     * Resume recording.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.engine.resumeRecording();\n    }\n    /**\n     * Show save as dialog in browser so the user can store the recorded media\n     * locally.\n     *\n     * @param {object} name - Object with names for the particular blob(s)\n     *     you want to save. File extensions are added automatically. For\n     *     example: {'video': 'name-of-video-file'}. Supported keys are\n     *     'audio', 'video' and 'gif'.\n     * @example\n     * // save video file as 'foo.webm'\n     * player.record().saveAs({'video': 'foo'});\n     */\n\n  }, {\n    key: \"saveAs\",\n    value: function saveAs(name) {\n      if (this.engine && name !== undefined) {\n        this.engine.save(name);\n      }\n    }\n    /**\n     * Invoked when recording is stopped and resulting stream is available.\n     *\n     * @private\n     * @param {string} audioVideoURL - Reference to the recorded Blob\n     *     object, e.g. 'blob:http://localhost:8080/10100016-4248-9949-b0d6-0bb40db56eba'\n     * @param {string} type - Media type, eg. 'video' or 'audio'.\n     */\n\n  }, {\n    key: \"onStopRecording\",\n    value: function onStopRecording(audioVideoURL, type) {\n      var _this = this;\n\n      // store reference to recorded stream URL\n      this.mediaURL = audioVideoURL; // store reference to recorded stream data\n\n      var recordType = this.player().record().getRecordType();\n      this.engine.getBlob(function (recording) {\n        switch (recordType) {\n          case _recordMode.AUDIO_ONLY:\n            if (recording.audio !== undefined) {\n              _this.recordedData = recording.audio;\n            }\n\n            break;\n\n          case _recordMode.VIDEO_ONLY:\n          case _recordMode.AUDIO_VIDEO:\n          case _recordMode.SCREEN_ONLY:\n            // recordrtc returns a single blob that includes both audio\n            // and video data\n            if (recording.video !== undefined) {\n              _this.recordedData = recording.video;\n            }\n\n            break;\n\n          case _recordMode.ANIMATION:\n            if (recording.gif !== undefined) {\n              _this.recordedData = recording.gif;\n            }\n\n            break;\n        } // inject file info\n\n\n        _this.addFileInfo(_this.recordedData); // notify listeners\n\n\n        _this.trigger('recordComplete');\n      });\n    }\n  }]);\n\n  return RecordRTCEngine;\n}(_recordEngine.RecordEngine); // expose plugin\n\n\nvideojs.RecordRTCEngine = RecordRTCEngine;\nComponent.registerComponent('RecordRTCEngine', RecordRTCEngine);\nvar _default = RecordRTCEngine;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/engine/record-rtc.js?");

/***/ }),

/***/ "./src/js/utils/browser-shim.js":
/*!**************************************!*\
  !*** ./src/js/utils/browser-shim.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * @file browser-shim.js\n * @since 2.0.0\n */\nvar setSrcObject = function setSrcObject(stream, element) {\n  if ('srcObject' in element) {\n    element.srcObject = stream;\n  } else if ('mozSrcObject' in element) {\n    element.mozSrcObject = stream;\n  } else {\n    element.srcObject = stream;\n  }\n};\n\nvar _default = setSrcObject;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/utils/browser-shim.js?");

/***/ }),

/***/ "./src/js/utils/detect-browser.js":
/*!****************************************!*\
  !*** ./src/js/utils/detect-browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFirefox = exports.isSafari = exports.isChrome = exports.isOpera = exports.isEdge = exports.detectBrowser = void 0;\n\nvar _window = _interopRequireDefault(__webpack_require__(/*! global/window */ \"./node_modules/global/window.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @file detect-browser.js\n * @since 2.0.0\n */\n\n/**\n * Browser detector.\n *\n * @private\n * @return {object} result containing browser, version and minVersion\n *     properties.\n */\nvar detectBrowser = function detectBrowser() {\n  // returned result object\n  var result = {};\n  result.browser = null;\n  result.version = null;\n  result.minVersion = null; // fail early if it's not a browser\n\n  if (typeof _window.default === 'undefined' || !_window.default.navigator) {\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    result.minVersion = 31;\n  } else if (navigator.webkitGetUserMedia) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    result.minVersion = 38;\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n    // Edge.\n    result.browser = 'edge';\n    result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\n    result.minVersion = 10547;\n  } else if (_window.default.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n};\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @private\n * @param {!string} uastring - userAgent string.\n * @param {!string} expr - Regular expression used as match criteria.\n * @param {!number} pos - position in the version string to be\n *     returned.\n * @return {!number} browser version.\n */\n\n\nexports.detectBrowser = detectBrowser;\n\nvar extractVersion = function extractVersion(uastring, expr, pos) {\n  var match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n};\n\nvar isEdge = function isEdge() {\n  return detectBrowser().browser === 'edge';\n};\n\nexports.isEdge = isEdge;\n\nvar isSafari = function isSafari() {\n  return detectBrowser().browser === 'safari';\n};\n\nexports.isSafari = isSafari;\n\nvar isOpera = function isOpera() {\n  return !!_window.default.opera || navigator.userAgent.indexOf('OPR/') !== -1;\n};\n\nexports.isOpera = isOpera;\n\nvar isChrome = function isChrome() {\n  return detectBrowser().browser === 'chrome';\n};\n\nexports.isChrome = isChrome;\n\nvar isFirefox = function isFirefox() {\n  return detectBrowser().browser === 'firefox';\n};\n\nexports.isFirefox = isFirefox;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/utils/detect-browser.js?");

/***/ }),

/***/ "./src/js/utils/file-util.js":
/*!***********************************!*\
  !*** ./src/js/utils/file-util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addFileInfo = exports.blobToArrayBuffer = exports.downloadBlob = void 0;\n\n/**\n * @file file-util.js\n * @since 3.3.0\n */\n\n/**\n * Download `Blob` object in browser.\n *\n * @param {string} fileName - Name for the file to download.\n * @param {blob} data - File data.\n * @returns {void}\n */\nvar downloadBlob = function downloadBlob(fileName, data) {\n  if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {\n    return navigator.msSaveOrOpenBlob(data, fileName);\n  } else if (typeof navigator.msSaveBlob !== 'undefined') {\n    return navigator.msSaveBlob(data, fileName);\n  }\n\n  var hyperlink = document.createElement('a');\n  hyperlink.href = URL.createObjectURL(data);\n  hyperlink.download = fileName;\n  hyperlink.style = 'display:none;opacity:0;color:transparent;';\n  (document.body || document.documentElement).appendChild(hyperlink);\n\n  if (typeof hyperlink.click === 'function') {\n    hyperlink.click();\n  } else {\n    hyperlink.target = '_blank';\n    hyperlink.dispatchEvent(new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: true\n    }));\n  }\n\n  URL.revokeObjectURL(hyperlink.href);\n};\n/**\n * Read `Blob` as `ArrayBuffer`.\n *\n * @param {(Blob|File)} fileObj - Blob or File object to read.\n * @returns {void}\n */\n\n\nexports.downloadBlob = downloadBlob;\n\nvar blobToArrayBuffer = function blobToArrayBuffer(fileObj) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onloadend = function () {\n      resolve(reader.result);\n    };\n\n    reader.onerror = function (ev) {\n      reject(ev.error);\n    };\n\n    reader.readAsArrayBuffer(fileObj);\n  });\n};\n/**\n * Add filename and timestamp to recorded file object.\n *\n * @param {(Blob|File)} fileObj - Blob or File object to modify.\n * @param {date} [now] - Optional date information, default is\n *    current timestamp.\n */\n\n\nexports.blobToArrayBuffer = blobToArrayBuffer;\n\nvar addFileInfo = function addFileInfo(fileObj, now) {\n  if (fileObj instanceof Blob || fileObj instanceof File) {\n    // set modification date\n    if (now === undefined) {\n      now = new Date();\n    }\n\n    try {\n      fileObj.lastModified = now.getTime();\n      fileObj.lastModifiedDate = now;\n    } catch (e) {\n      if (e instanceof TypeError) {// ignore: setting getter-only property \"lastModifiedDate\"\n      } else {\n        // re-raise error\n        throw e;\n      }\n    } // guess extension name from mime type, e.g. audio/ogg, but\n    // any extension is valid here. Chrome also accepts extended\n    // mime types like video/webm;codecs=h264,vp9,opus\n\n\n    var fileExtension = '.' + fileObj.type.split('/')[1];\n\n    if (fileExtension.indexOf(';') > -1) {\n      fileExtension = fileExtension.split(';')[0];\n    } // use timestamp in filename, e.g. 1451180941326.ogg\n\n\n    try {\n      fileObj.name = now.getTime() + fileExtension;\n    } catch (e) {\n      if (e instanceof TypeError) {// ignore: setting getter-only property \"name\"\n      } else {\n        // re-raise error\n        throw e;\n      }\n    }\n  }\n};\n\nexports.addFileInfo = addFileInfo;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/utils/file-util.js?");

/***/ }),

/***/ "./src/js/utils/format-time.js":
/*!*************************************!*\
  !*** ./src/js/utils/format-time.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * @file format-time.js\n * @since 2.0.0\n */\n\n/**\n * Format seconds as a time string, H:MM:SS, M:SS or M:SS:MMM.\n *\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide.\n *\n * @param {number} seconds - Number of seconds to be turned into a\n *     string.\n * @param {number} guide - Number (in seconds) to model the string\n *     after.\n * @param {number} msDisplayMax - Number (in milliseconds) to model the string\n *     after.\n * @return {string} Time formatted as H:MM:SS, M:SS or M:SS:MMM, e.g.\n *     0:00:12.\n * @private\n */\nvar formatTime = function formatTime(seconds, guide, msDisplayMax) {\n  // Default to using seconds as guide\n  seconds = seconds < 0 ? 0 : seconds;\n  guide = guide || seconds;\n  var s = Math.floor(seconds % 60),\n      m = Math.floor(seconds / 60 % 60),\n      h = Math.floor(seconds / 3600),\n      gm = Math.floor(guide / 60 % 60),\n      gh = Math.floor(guide / 3600),\n      ms = Math.floor((seconds - s) * 1000); // handle invalid times\n\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this\n    // setting will add the minimum number of fields specified by the\n    // guide\n    h = m = s = ms = '-';\n  } // Check if we need to show milliseconds\n\n\n  if (guide > 0 && guide < msDisplayMax) {\n    if (ms < 100) {\n      if (ms < 10) {\n        ms = '00' + ms;\n      } else {\n        ms = '0' + ms;\n      }\n    }\n\n    ms = ':' + ms;\n  } else {\n    ms = '';\n  } // Check if we need to show hours\n\n\n  h = h > 0 || gh > 0 ? h + ':' : ''; // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n\n  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':'; // Check if leading zero is need for seconds\n\n  s = s < 10 ? '0' + s : s;\n  return h + m + s + ms;\n};\n\nvar _default = formatTime;\nexports.default = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://VideojsRecord/./src/js/utils/format-time.js?");

/***/ }),

/***/ "./src/js/videojs.record.js":
/*!**********************************!*\
  !*** ./src/js/videojs.record.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _animationDisplay = _interopRequireDefault(__webpack_require__(/*! ./controls/animation-display */ \"./src/js/controls/animation-display.js\"));\n\nvar _recordCanvas = _interopRequireDefault(__webpack_require__(/*! ./controls/record-canvas */ \"./src/js/controls/record-canvas.js\"));\n\nvar _deviceButton = _interopRequireDefault(__webpack_require__(/*! ./controls/device-button */ \"./src/js/controls/device-button.js\"));\n\nvar _cameraButton = _interopRequireDefault(__webpack_require__(/*! ./controls/camera-button */ \"./src/js/controls/camera-button.js\"));\n\nvar _recordToggle = _interopRequireDefault(__webpack_require__(/*! ./controls/record-toggle */ \"./src/js/controls/record-toggle.js\"));\n\nvar _recordIndicator = _interopRequireDefault(__webpack_require__(/*! ./controls/record-indicator */ \"./src/js/controls/record-indicator.js\"));\n\nvar _defaults = _interopRequireDefault(__webpack_require__(/*! ./defaults */ \"./src/js/defaults.js\"));\n\nvar _formatTime = _interopRequireDefault(__webpack_require__(/*! ./utils/format-time */ \"./src/js/utils/format-time.js\"));\n\nvar _browserShim = _interopRequireDefault(__webpack_require__(/*! ./utils/browser-shim */ \"./src/js/utils/browser-shim.js\"));\n\nvar _detectBrowser = __webpack_require__(/*! ./utils/detect-browser */ \"./src/js/utils/detect-browser.js\");\n\nvar _engineLoader = __webpack_require__(/*! ./engine/engine-loader */ \"./src/js/engine/engine-loader.js\");\n\nvar _recordMode = __webpack_require__(/*! ./engine/record-mode */ \"./src/js/engine/record-mode.js\");\n\nvar _video = _interopRequireDefault(__webpack_require__(/*! video.js */ \"video.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Plugin = _video.default.getPlugin('plugin');\n\nvar Player = _video.default.getComponent('Player');\n\nvar AUTO = 'auto'; // monkey-patch play (#152)\n\nPlayer.prototype.play = function play() {\n  var retval = this.techGet_('play'); // silence errors (unhandled promise from play)\n\n  if (retval !== undefined && typeof retval.then === 'function') {\n    retval.then(null, function (e) {});\n  }\n\n  return retval;\n};\n/**\n * Record audio/video/images using the Video.js player.\n *\n * @class\n * @augments videojs.Plugin\n */\n\n\nvar Record =\n/*#__PURE__*/\nfunction (_Plugin) {\n  _inherits(Record, _Plugin);\n\n  /**\n   * The constructor function for the class.\n   *\n   * @param {(videojs.Player|Object)} player - video.js Player object.\n   * @param {Object} options - Player options.\n   */\n  function Record(player, options) {\n    var _this;\n\n    _classCallCheck(this, Record);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Record).call(this, player, options)); // add plugin style\n\n    player.addClass('vjs-record'); // setup plugin options\n\n    _this.loadOptions(); // (re)set recorder state\n\n\n    _this.resetState(); // add device button with icon based on type\n\n\n    var deviceIcon = 'av-perm';\n\n    switch (_this.getRecordType()) {\n      case _recordMode.IMAGE_ONLY:\n      case _recordMode.VIDEO_ONLY:\n      case _recordMode.ANIMATION:\n        deviceIcon = 'video-perm';\n        break;\n\n      case _recordMode.AUDIO_ONLY:\n        deviceIcon = 'audio-perm';\n        break;\n\n      case _recordMode.SCREEN_ONLY:\n        deviceIcon = 'screen-perm';\n        break;\n    } // add custom interface elements\n\n\n    _deviceButton.default.prototype.buildCSSClass = function () {\n      // use dynamic icon class\n      return 'vjs-record vjs-device-button vjs-control vjs-icon-' + deviceIcon;\n    };\n\n    player.deviceButton = new _deviceButton.default(player, options);\n    player.addChild(player.deviceButton); // add blinking record indicator\n\n    player.recordIndicator = new _recordIndicator.default(player, options);\n    player.recordIndicator.hide();\n    player.addChild(player.recordIndicator); // add canvas for recording and displaying image\n\n    player.recordCanvas = new _recordCanvas.default(player, options);\n    player.recordCanvas.hide();\n    player.addChild(player.recordCanvas); // add image for animation display\n\n    player.animationDisplay = new _animationDisplay.default(player, options);\n    player.animationDisplay.hide();\n    player.addChild(player.animationDisplay); // add camera button\n\n    player.cameraButton = new _cameraButton.default(player, options);\n    player.cameraButton.hide(); // add record toggle button\n\n    player.recordToggle = new _recordToggle.default(player, options);\n    player.recordToggle.hide(); // exclude custom UI elements\n\n    if (_this.player.options_.controlBar) {\n      var customUIElements = ['deviceButton', 'recordIndicator', 'cameraButton', 'recordToggle'];\n      customUIElements.forEach(function (element) {\n        if (_this.player.options_.controlBar[element] !== undefined) {\n          _this.player[element].layoutExclude = true;\n\n          _this.player[element].hide();\n        }\n      });\n    } // wait until player ui is ready\n\n\n    _this.player.one('ready', _this.setupUI.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    return _this;\n  }\n  /**\n   * Setup plugin options.\n   *\n   * @param {Object} newOptions - Optional new player options.\n   */\n\n\n  _createClass(Record, [{\n    key: \"loadOptions\",\n    value: function loadOptions() {\n      var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var recordOptions = _video.default.mergeOptions(_defaults.default, this.player.options_.plugins.record, newOptions); // record settings\n\n\n      this.recordImage = recordOptions.image;\n      this.recordAudio = recordOptions.audio;\n      this.recordVideo = recordOptions.video;\n      this.recordAnimation = recordOptions.animation;\n      this.recordScreen = recordOptions.screen;\n      this.maxLength = recordOptions.maxLength;\n      this.maxFileSize = recordOptions.maxFileSize;\n      this.msDisplayMax = parseFloat(recordOptions.msDisplayMax);\n      this.debug = recordOptions.debug;\n      this.recordTimeSlice = recordOptions.timeSlice;\n      this.autoMuteDevice = recordOptions.autoMuteDevice; // video/canvas settings\n\n      this.videoFrameWidth = recordOptions.frameWidth;\n      this.videoFrameHeight = recordOptions.frameHeight;\n      this.videoRecorderType = recordOptions.videoRecorderType;\n      this.videoMimeType = recordOptions.videoMimeType; // convert settings\n\n      this.convertEngine = recordOptions.convertEngine; // audio settings\n\n      this.audioEngine = recordOptions.audioEngine;\n      this.audioRecorderType = recordOptions.audioRecorderType;\n      this.audioWorkerURL = recordOptions.audioWorkerURL;\n      this.audioBufferSize = recordOptions.audioBufferSize;\n      this.audioSampleRate = recordOptions.audioSampleRate;\n      this.audioBitRate = recordOptions.audioBitRate;\n      this.audioChannels = recordOptions.audioChannels;\n      this.audioMimeType = recordOptions.audioMimeType;\n      this.audioBufferUpdate = recordOptions.audioBufferUpdate; // animation settings\n\n      this.animationFrameRate = recordOptions.animationFrameRate;\n      this.animationQuality = recordOptions.animationQuality;\n    }\n    /**\n     * Player UI is ready.\n     * @private\n     */\n\n  }, {\n    key: \"setupUI\",\n    value: function setupUI() {\n      var _this2 = this;\n\n      // insert custom controls on left-side of controlbar\n      this.player.controlBar.addChild(this.player.cameraButton);\n      this.player.controlBar.el().insertBefore(this.player.cameraButton.el(), this.player.controlBar.el().firstChild);\n      this.player.controlBar.el().insertBefore(this.player.recordToggle.el(), this.player.controlBar.el().firstChild); // get rid of unused controls\n\n      if (this.player.controlBar.remainingTimeDisplay !== undefined) {\n        this.player.controlBar.remainingTimeDisplay.el().style.display = 'none';\n      }\n\n      if (this.player.controlBar.liveDisplay !== undefined) {\n        this.player.controlBar.liveDisplay.el().style.display = 'none';\n      } // loop feature is never used in this plugin\n\n\n      this.player.loop(false); // tweak player UI based on type\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          // reference to videojs-wavesurfer plugin\n          this.surfer = this.player.wavesurfer();\n          break;\n\n        case _recordMode.IMAGE_ONLY:\n        case _recordMode.VIDEO_ONLY:\n        case _recordMode.AUDIO_VIDEO:\n        case _recordMode.ANIMATION:\n        case _recordMode.SCREEN_ONLY:\n          // customize controls\n          this.player.bigPlayButton.hide(); // 'loadedmetadata' and 'loadstart' events reset the\n          // durationDisplay for the first time: prevent this\n\n          this.player.one('loadedmetadata', function () {\n            // display max record time\n            _this2.setDuration(_this2.maxLength);\n          });\n          this.player.one('loadstart', function () {\n            // display max record time\n            _this2.setDuration(_this2.maxLength);\n          }); // the native controls don't work for this UI so disable\n          // them no matter what\n\n          if (this.player.usingNativeControls_ === true) {\n            if (this.player.tech_.el_ !== undefined) {\n              this.player.tech_.el_.controls = false;\n            }\n          } // clicking or tapping the player video element should not try\n          // to start playback\n\n\n          this.player.removeTechControlsListeners_();\n\n          if (this.player.options_.controls) {\n            // progress control isn't used by this plugin\n            this.player.controlBar.progressControl.hide(); // prevent controlbar fadeout\n\n            this.player.on('userinactive', function (event) {\n              _this2.player.userActive(true);\n            }); // videojs automatically hides the controls when no valid 'source'\n            // element is included in the video or audio tag. Don't. Ever again.\n\n            this.player.controlBar.show();\n            this.player.controlBar.el().style.display = 'flex';\n          }\n\n          break;\n      } // disable time display events that constantly try to reset the current time\n      // and duration values\n\n\n      this.player.off('timeupdate');\n      this.player.off('durationchange');\n      this.player.off('loadedmetadata');\n      this.player.off('loadstart'); // display max record time\n\n      this.setDuration(this.maxLength); // hide play control\n\n      this.player.controlBar.playToggle.hide();\n    }\n    /**\n     * Indicates whether the plugin is currently recording or not.\n     *\n     * @return {boolean} Plugin currently recording or not.\n     */\n\n  }, {\n    key: \"isRecording\",\n    value: function isRecording() {\n      return this._recording;\n    }\n    /**\n     * Indicates whether the plugin is currently processing recorded data\n     * or not.\n     *\n     * @return {boolean} Plugin processing or not.\n     */\n\n  }, {\n    key: \"isProcessing\",\n    value: function isProcessing() {\n      return this._processing;\n    }\n    /**\n     * Indicates whether the plugin is destroyed or not.\n     *\n     * @return {boolean} Plugin destroyed or not.\n     */\n\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      var destroyed = this.player === null;\n\n      if (destroyed === false) {\n        destroyed = this.player.children() === null;\n      }\n\n      return destroyed;\n    }\n    /**\n     * Open the browser's recording device selection dialog.\n     */\n\n  }, {\n    key: \"getDevice\",\n    value: function getDevice() {\n      var _this3 = this;\n\n      // define device callbacks once\n      if (this.deviceReadyCallback === undefined) {\n        this.deviceReadyCallback = this.onDeviceReady.bind(this);\n      }\n\n      if (this.deviceErrorCallback === undefined) {\n        this.deviceErrorCallback = this.onDeviceError.bind(this);\n      }\n\n      if (this.engineStopCallback === undefined) {\n        this.engineStopCallback = this.onRecordComplete.bind(this);\n      } // ask the browser to give the user access to the media device\n      // and get a stream reference in the callback function\n\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          // setup microphone\n          this.mediaType = {\n            audio: this.audioRecorderType === AUTO ? true : this.audioRecorderType,\n            video: false\n          }; // remove existing microphone listeners\n\n          this.surfer.surfer.microphone.un('deviceReady', this.deviceReadyCallback);\n          this.surfer.surfer.microphone.un('deviceError', this.deviceErrorCallback); // setup new microphone listeners\n\n          this.surfer.surfer.microphone.on('deviceReady', this.deviceReadyCallback);\n          this.surfer.surfer.microphone.on('deviceError', this.deviceErrorCallback); // disable existing playback events\n\n          this.surfer.setupPlaybackEvents(false); // (re)set surfer liveMode\n\n          this.surfer.liveMode = true;\n          this.surfer.surfer.microphone.paused = false; // assign custom reloadBufferFunction for microphone plugin to\n          // obtain AudioBuffer chunks\n\n          if (this.audioBufferUpdate === true) {\n            this.surfer.surfer.microphone.reloadBufferFunction = function (event) {\n              if (!_this3.surfer.surfer.microphone.paused) {\n                // redraw\n                _this3.surfer.surfer.empty();\n\n                _this3.surfer.surfer.loadDecodedBuffer(event.inputBuffer); // store data and notify others\n\n\n                _this3.player.recordedData = event.inputBuffer;\n\n                _this3.player.trigger('audioBufferUpdate');\n              }\n            };\n          } // open browser device selection dialog\n\n\n          this.surfer.surfer.microphone.start();\n          break;\n\n        case _recordMode.IMAGE_ONLY:\n        case _recordMode.VIDEO_ONLY:\n          // setup camera\n          this.mediaType = {\n            audio: false,\n            video: this.videoRecorderType === AUTO ? true : this.videoRecorderType\n          };\n          navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: this.getRecordType() === _recordMode.IMAGE_ONLY ? this.recordImage : this.recordVideo\n          }).then(this.onDeviceReady.bind(this)).catch(this.onDeviceError.bind(this));\n          break;\n\n        case _recordMode.AUDIO_VIDEO:\n          // setup camera and microphone\n          this.mediaType = {\n            audio: this.audioRecorderType === AUTO ? true : this.audioRecorderType,\n            video: this.videoRecorderType === AUTO ? true : this.videoRecorderType\n          };\n          navigator.mediaDevices.getUserMedia({\n            audio: this.recordAudio,\n            video: this.recordVideo\n          }).then(this.onDeviceReady.bind(this)).catch(this.onDeviceError.bind(this));\n          break;\n\n        case _recordMode.ANIMATION:\n          // setup camera\n          this.mediaType = {\n            // animated GIF\n            audio: false,\n            video: false,\n            gif: true\n          };\n          navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: this.recordAnimation\n          }).then(this.onDeviceReady.bind(this)).catch(this.onDeviceError.bind(this));\n          break;\n\n        case _recordMode.SCREEN_ONLY:\n          // setup screen\n          this.mediaType = {\n            // screen capture\n            audio: false,\n            video: false,\n            screen: true,\n            gif: false\n          };\n          navigator.mediaDevices.getDisplayMedia({\n            video: true\n          }).then(this.onDeviceReady.bind(this)).catch(this.onDeviceError.bind(this));\n          break;\n      }\n    }\n    /**\n     * Invoked when the device is ready.\n     *\n     * @private\n     * @param {LocalMediaStream} stream - Local media stream from device.\n     */\n\n  }, {\n    key: \"onDeviceReady\",\n    value: function onDeviceReady(stream) {\n      var _this4 = this;\n\n      this._deviceActive = true; // store reference to stream for stopping etc.\n\n      this.stream = stream; // hide device selection button\n\n      this.player.deviceButton.hide(); // reset time (e.g. when stopDevice was used)\n\n      this.setDuration(this.maxLength);\n      this.setCurrentTime(0); // hide play/pause control (e.g. when stopDevice was used)\n\n      this.player.controlBar.playToggle.hide(); // reset playback listeners\n\n      this.off(this.player, 'timeupdate', this.playbackTimeUpdate);\n      this.off(this.player, 'ended', this.playbackTimeUpdate); // setup recording engine\n\n      if (this.getRecordType() !== _recordMode.IMAGE_ONLY) {\n        // currently record plugins are only supported in audio-only mode\n        if (this.getRecordType() !== _recordMode.AUDIO_ONLY && (0, _engineLoader.isAudioPluginActive)(this.audioEngine)) {\n          throw new Error('Currently ' + this.audioEngine + ' is only supported in audio-only mode.');\n        } // get audio plugin engine class\n\n\n        var AudioEngineClass = (0, _engineLoader.getAudioEngine)(this.audioEngine); // create recording engine\n\n        try {\n          // connect stream to recording engine\n          this.engine = new AudioEngineClass(this.player, this.player.options_);\n        } catch (err) {\n          throw new Error('Could not load ' + this.audioEngine + ' plugin');\n        } // listen for events\n\n\n        this.engine.on('recordComplete', this.engineStopCallback); // audio settings\n\n        this.engine.bufferSize = this.audioBufferSize;\n        this.engine.sampleRate = this.audioSampleRate;\n        this.engine.bitRate = this.audioBitRate;\n        this.engine.audioChannels = this.audioChannels;\n        this.engine.audioWorkerURL = this.audioWorkerURL; // mime type\n\n        this.engine.mimeType = {\n          video: this.videoMimeType,\n          gif: 'image/gif'\n        };\n\n        if (this.audioMimeType !== null && this.audioMimeType !== AUTO) {\n          this.engine.mimeType.audio = this.audioMimeType;\n        } // video/canvas settings\n\n\n        this.engine.video = {\n          width: this.videoFrameWidth,\n          height: this.videoFrameHeight\n        };\n        this.engine.canvas = {\n          width: this.videoFrameWidth,\n          height: this.videoFrameHeight\n        }; // animated GIF settings\n\n        this.engine.quality = this.animationQuality;\n        this.engine.frameRate = this.animationFrameRate; // timeSlice\n\n        if (this.recordTimeSlice && this.recordTimeSlice > 0) {\n          this.engine.timeSlice = this.recordTimeSlice;\n          this.engine.onTimeStamp = this.onTimeStamp.bind(this);\n        } // initialize recorder\n\n\n        this.engine.setup(this.stream, this.mediaType, this.debug); // create converter engine\n\n        if (this.convertEngine !== '') {\n          var ConvertEngineClass = (0, _engineLoader.getConvertEngine)(this.convertEngine);\n\n          try {\n            this.converter = new ConvertEngineClass(this.player, this.player.options_);\n          } catch (err) {\n            throw new Error('Could not load ' + this.convertEngine + ' plugin');\n          } // initialize converter\n\n\n          this.converter.setup(this.mediaType, this.debug);\n        } // show elements that should never be hidden in animation,\n        // audio and/or video modus\n\n\n        var uiElements = [this.player.controlBar.currentTimeDisplay, this.player.controlBar.timeDivider, this.player.controlBar.durationDisplay];\n        uiElements.forEach(function (element) {\n          if (element !== undefined) {\n            element.el().style.display = 'block';\n            element.show();\n          }\n        }); // show record button\n\n        this.player.recordToggle.show();\n      } else {\n        // disable record indicator\n        this.player.recordIndicator.disable(); // setup UI for retrying snapshot (e.g. when stopDevice was\n        // used)\n\n        this.retrySnapshot(); // reset and show camera button\n\n        this.player.cameraButton.onStop();\n        this.player.cameraButton.show();\n      } // setup preview\n\n\n      if (this.getRecordType() !== _recordMode.AUDIO_ONLY) {\n        // show live preview\n        this.mediaElement = this.player.el().firstChild;\n        this.mediaElement.controls = false; // mute incoming audio for feedback loops\n\n        this.mediaElement.muted = true; // hide the volume bar while it's muted\n\n        this.displayVolumeControl(false); // load stream\n\n        this.load(this.stream); // stream loading is async, so we wait until it's ready to play\n        // the stream\n\n        this.player.one('loadedmetadata', function () {\n          // start stream\n          _this4.mediaElement.play(); // forward to listeners\n\n\n          _this4.player.trigger('deviceReady');\n        });\n      } else {\n        // forward to listeners\n        this.player.trigger('deviceReady');\n      }\n    }\n    /**\n     * Invoked when an device error occurred.\n     *\n     * @private\n     * @param {(string|number)} code - Error code/description.\n     */\n\n  }, {\n    key: \"onDeviceError\",\n    value: function onDeviceError(code) {\n      this._deviceActive = false;\n\n      if (!this.isDestroyed()) {\n        // store code\n        this.player.deviceErrorCode = code; // forward error to player\n\n        this.player.trigger('deviceError');\n      }\n    }\n    /**\n     * Start recording.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this5 = this;\n\n      if (!this.isProcessing()) {\n        this._recording = true; // hide play/pause control\n\n        this.player.controlBar.playToggle.hide(); // reset playback listeners\n\n        this.off(this.player, 'timeupdate', this.playbackTimeUpdate);\n        this.off(this.player, 'ended', this.playbackTimeUpdate); // start preview\n\n        switch (this.getRecordType()) {\n          case _recordMode.AUDIO_ONLY:\n            // disable playback events\n            this.surfer.setupPlaybackEvents(false); // start/resume live audio visualization\n\n            this.surfer.surfer.microphone.paused = false;\n            this.surfer.liveMode = true;\n            this.surfer.surfer.microphone.play();\n            break;\n\n          case _recordMode.VIDEO_ONLY:\n          case _recordMode.AUDIO_VIDEO:\n          case _recordMode.SCREEN_ONLY:\n            // preview video stream in video element\n            this.startVideoPreview();\n            break;\n\n          case _recordMode.ANIMATION:\n            // hide the first frame\n            this.player.recordCanvas.hide(); // hide the animation\n\n            this.player.animationDisplay.hide(); // show preview video\n\n            this.mediaElement.style.display = 'block'; // for animations, capture the first frame\n            // that can be displayed as soon as recording\n            // is complete\n\n            this.captureFrame().then(function (result) {\n              // start video preview **after** capturing first frame\n              _this5.startVideoPreview();\n            });\n            break;\n        }\n\n        if (this.autoMuteDevice) {\n          // unmute device\n          this.muteTracks(false);\n        } // start recording\n\n\n        switch (this.getRecordType()) {\n          case _recordMode.IMAGE_ONLY:\n            // create snapshot\n            this.createSnapshot(); // notify UI\n\n            this.player.trigger('startRecord');\n            break;\n\n          case _recordMode.VIDEO_ONLY:\n          case _recordMode.AUDIO_VIDEO:\n          case _recordMode.ANIMATION:\n          case _recordMode.SCREEN_ONLY:\n            // wait for media stream on video element to actually load\n            this.player.one('loadedmetadata', function () {\n              // start actually recording process\n              _this5.startRecording();\n            });\n            break;\n\n          default:\n            // all resources have already loaded, so we can start\n            // recording right away\n            this.startRecording();\n        }\n      }\n    }\n    /**\n     * Start recording.\n     * @private\n     */\n\n  }, {\n    key: \"startRecording\",\n    value: function startRecording() {\n      // register starting point\n      this.paused = false;\n      this.pauseTime = this.pausedTime = 0;\n      this.startTime = new Date().getTime(); // start countdown\n\n      this.countDown = this.player.setInterval(this.onCountDown.bind(this), 100); // cleanup previous recording\n\n      if (this.engine !== undefined) {\n        this.engine.dispose();\n      } // start recording stream\n\n\n      this.engine.start(); // notify UI\n\n      this.player.trigger('startRecord');\n    }\n    /**\n     * Stop recording.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.isProcessing()) {\n        this._recording = false;\n        this._processing = true;\n\n        if (this.getRecordType() !== _recordMode.IMAGE_ONLY) {\n          // notify UI\n          this.player.trigger('stopRecord'); // stop countdown\n\n          this.player.clearInterval(this.countDown); // stop recording stream (result will be available async)\n\n          if (this.engine) {\n            this.engine.stop();\n          }\n\n          if (this.autoMuteDevice) {\n            // mute device\n            this.muteTracks(true);\n          }\n        } else {\n          if (this.player.recordedData) {\n            // notify listeners that image data is (already) available\n            this.player.trigger('finishRecord');\n          }\n        }\n      }\n    }\n    /**\n     * Stop device(s) and recording if active.\n     */\n\n  }, {\n    key: \"stopDevice\",\n    value: function stopDevice() {\n      if (this.isRecording()) {\n        // stop stream once recorded data is available,\n        // otherwise it'll break recording\n        this.player.one('finishRecord', this.stopStream.bind(this)); // stop recording\n\n        this.stop();\n      } else {\n        // stop stream now, since there's no recorded data available\n        this.stopStream();\n      }\n    }\n    /**\n     * Stop stream and device.\n     */\n\n  }, {\n    key: \"stopStream\",\n    value: function stopStream() {\n      // stop stream and device\n      if (this.stream) {\n        this._deviceActive = false;\n\n        if (this.getRecordType() === _recordMode.AUDIO_ONLY) {\n          // make the microphone plugin stop it's device\n          this.surfer.surfer.microphone.stopDevice();\n          return;\n        }\n\n        this.stream.getTracks().forEach(function (stream) {\n          stream.stop();\n        });\n      }\n    }\n    /**\n     * Pause recording.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (!this.paused) {\n        this.pauseTime = new Date().getTime();\n        this.paused = true;\n        this.engine.pause();\n      }\n    }\n    /**\n     * Resume recording.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.paused) {\n        this.pausedTime += new Date().getTime() - this.pauseTime;\n        this.engine.resume();\n        this.paused = false;\n      }\n    }\n    /**\n     * Invoked when recording completed and the resulting stream is\n     * available.\n     * @private\n     */\n\n  }, {\n    key: \"onRecordComplete\",\n    value: function onRecordComplete() {\n      var _this6 = this;\n\n      // store reference to recorded stream data\n      this.player.recordedData = this.engine.recordedData; // change the replay button back to a play button\n\n      this.player.controlBar.playToggle.removeClass('vjs-ended');\n      this.player.controlBar.playToggle.show(); // notify converter\n\n      if (this.converter !== undefined) {\n        this.converter.convert(this.player.recordedData);\n      } // notify listeners that data is available\n\n\n      this.player.trigger('finishRecord'); // skip loading when player is destroyed after finishRecord event\n\n      if (this.isDestroyed()) {\n        return;\n      } // load and display recorded data\n\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          // pause player so user can start playback\n          this.surfer.pause(); // setup events for playback\n\n          this.surfer.setupPlaybackEvents(true); // display loader\n\n          this.player.loadingSpinner.show(); // restore interaction with controls after waveform\n          // rendering is complete\n\n          this.surfer.surfer.once('ready', function () {\n            _this6._processing = false;\n          }); // visualize recorded stream\n\n          this.load(this.player.recordedData);\n          break;\n\n        case _recordMode.VIDEO_ONLY:\n        case _recordMode.AUDIO_VIDEO:\n        case _recordMode.SCREEN_ONLY:\n          // pausing the player so we can visualize the recorded data\n          // will trigger an async video.js 'pause' event that we\n          // have to wait for.\n          this.player.one('pause', function () {\n            // video data is ready\n            _this6._processing = false; // hide loader\n\n            _this6.player.loadingSpinner.hide(); // show stream total duration\n\n\n            _this6.setDuration(_this6.streamDuration); // update time during playback and at end\n\n\n            _this6.on(_this6.player, 'timeupdate', _this6.playbackTimeUpdate);\n\n            _this6.on(_this6.player, 'ended', _this6.playbackTimeUpdate); // unmute local audio during playback\n\n\n            if (_this6.getRecordType() === _recordMode.AUDIO_VIDEO) {\n              _this6.mediaElement.muted = false; // show the volume bar when it's unmuted\n\n              _this6.displayVolumeControl(true);\n            } // load recorded media\n\n\n            _this6.load(_this6.player.recordedData);\n          }); // pause player so user can start playback\n\n          this.player.pause();\n          break;\n\n        case _recordMode.ANIMATION:\n          // animation data is ready\n          this._processing = false; // hide loader\n\n          this.player.loadingSpinner.hide(); // show animation total duration\n\n          this.setDuration(this.streamDuration); // hide preview video\n\n          this.mediaElement.style.display = 'none'; // show the first frame\n\n          this.player.recordCanvas.show(); // pause player so user can start playback\n\n          this.player.pause(); // show animation on play\n\n          this.on(this.player, 'play', this.showAnimation); // hide animation on pause\n\n          this.on(this.player, 'pause', this.hideAnimation);\n          break;\n      }\n    }\n    /**\n     * Invoked during recording and displays the remaining time.\n     * @private\n     */\n\n  }, {\n    key: \"onCountDown\",\n    value: function onCountDown() {\n      if (!this.paused) {\n        var now = new Date().getTime();\n        var duration = this.maxLength;\n        var currentTime = (now - (this.startTime + this.pausedTime)) / 1000;\n        this.streamDuration = currentTime;\n\n        if (currentTime >= duration) {\n          // at the end\n          currentTime = duration; // stop recording\n\n          this.stop();\n        } // update duration\n\n\n        this.setDuration(duration); // update current time\n\n        this.setCurrentTime(currentTime, duration); // notify listeners\n\n        this.player.trigger('progressRecord');\n      }\n    }\n    /**\n     * Get the current time of the recorded stream during playback.\n     *\n     * Returns 0 if no recording is available (yet).\n     *\n     * @returns {float} Current time of the recorded stream.\n     */\n\n  }, {\n    key: \"getCurrentTime\",\n    value: function getCurrentTime() {\n      var currentTime = isNaN(this.streamCurrentTime) ? 0 : this.streamCurrentTime;\n\n      if (this.getRecordType() === _recordMode.AUDIO_ONLY) {\n        currentTime = this.surfer.getCurrentTime();\n      }\n\n      return currentTime;\n    }\n    /**\n     * Updates the player's element displaying the current time.\n     *\n     * @private\n     * @param {number} [currentTime=0] - Current position of the\n     *    playhead (in seconds).\n     * @param {number} [duration=0] - Duration in seconds.\n     */\n\n  }, {\n    key: \"setCurrentTime\",\n    value: function setCurrentTime(currentTime, duration) {\n      currentTime = isNaN(currentTime) ? 0 : currentTime;\n      duration = isNaN(duration) ? 0 : duration;\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          this.surfer.setCurrentTime(currentTime, duration);\n          break;\n\n        case _recordMode.VIDEO_ONLY:\n        case _recordMode.AUDIO_VIDEO:\n        case _recordMode.ANIMATION:\n        case _recordMode.SCREEN_ONLY:\n          if (this.player.controlBar.currentTimeDisplay && this.player.controlBar.currentTimeDisplay.contentEl()) {\n            this.streamCurrentTime = Math.min(currentTime, duration); // update current time display component\n\n            this.player.controlBar.currentTimeDisplay.formattedTime_ = this.player.controlBar.currentTimeDisplay.contentEl().lastChild.textContent = (0, _formatTime.default)(this.streamCurrentTime, duration, this.msDisplayMax);\n          }\n\n          break;\n      }\n    }\n    /**\n     * Get the length of the recorded stream in seconds.\n     *\n     * Returns 0 if no recording is available (yet).\n     *\n     * @returns {float} Duration of the recorded stream.\n     */\n\n  }, {\n    key: \"getDuration\",\n    value: function getDuration() {\n      var duration = isNaN(this.streamDuration) ? 0 : this.streamDuration;\n      return duration;\n    }\n    /**\n     * Updates the player's element displaying the duration time.\n     *\n     * @param {number} [duration=0] - Duration in seconds.\n     * @private\n     */\n\n  }, {\n    key: \"setDuration\",\n    value: function setDuration(duration) {\n      duration = isNaN(duration) ? 0 : duration;\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          this.surfer.setDuration(duration);\n          break;\n\n        case _recordMode.VIDEO_ONLY:\n        case _recordMode.AUDIO_VIDEO:\n        case _recordMode.ANIMATION:\n        case _recordMode.SCREEN_ONLY:\n          // update duration display component\n          if (this.player.controlBar.durationDisplay && this.player.controlBar.durationDisplay.contentEl()) {\n            this.player.controlBar.durationDisplay.formattedTime_ = this.player.controlBar.durationDisplay.contentEl().lastChild.textContent = (0, _formatTime.default)(duration, duration, this.msDisplayMax);\n          }\n\n          break;\n      }\n    }\n    /**\n     * Start loading data.\n     *\n     * @param {(string|blob|file)} url - Either the URL of the media file,\n     *     a Blob, a File object or MediaStream.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          // visualize recorded Blob stream\n          this.surfer.load(url);\n          break;\n\n        case _recordMode.IMAGE_ONLY:\n        case _recordMode.VIDEO_ONLY:\n        case _recordMode.AUDIO_VIDEO:\n        case _recordMode.ANIMATION:\n        case _recordMode.SCREEN_ONLY:\n          if (url instanceof Blob || url instanceof File) {\n            // make sure to reset it (#312)\n            this.mediaElement.srcObject = null; // assign blob using createObjectURL\n\n            this.mediaElement.src = URL.createObjectURL(url);\n          } else {\n            // assign stream with srcObject\n            (0, _browserShim.default)(url, this.mediaElement);\n          }\n\n          break;\n      }\n    }\n    /**\n     * Show save as dialog in browser so the user can store the recorded media\n     * locally.\n     *\n     * @param {object} name - Object with one or more names for the particular\n     *     blob(s) you want to save. File extensions are added automatically.\n     *     For example: {'video': 'name-of-video-file'}. Supported keys are\n     *     'audio', 'video' and 'gif'.\n     * @example\n     * // save video file as 'foo.webm'\n     * player.record().saveAs({'video': 'foo'});\n     */\n\n  }, {\n    key: \"saveAs\",\n    value: function saveAs(name) {\n      if (this.engine && name !== undefined) {\n        this.engine.saveAs(name);\n      }\n    }\n    /**\n     * Destroy plugin only.\n     *\n     * Use [destroy]{@link Record#destroy} to remove the plugin and the player\n     * as well.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      // disable common event listeners\n      this.player.off('ready');\n      this.player.off('userinactive');\n      this.player.off('loadedmetadata'); // prevent callbacks if recording is in progress\n\n      if (this.engine) {\n        this.engine.dispose();\n        this.engine.off('recordComplete', this.engineStopCallback);\n      } // stop recording and device\n\n\n      this.stop();\n      this.stopDevice(); // stop countdown\n\n      this.player.clearInterval(this.countDown); // dispose wavesurfer.js\n\n      if (this.getRecordType() === _recordMode.AUDIO_ONLY) {\n        if (this.surfer) {\n          // also disposes player\n          this.surfer.destroy();\n        }\n      }\n\n      this.resetState();\n\n      _get(_getPrototypeOf(Record.prototype), \"dispose\", this).call(this);\n    }\n    /**\n     * Destroy plugin and players and cleanup resources.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.player.dispose();\n    }\n    /**\n     * Reset the plugin.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _this7 = this;\n\n      // prevent callbacks if recording is in progress\n      if (this.engine) {\n        this.engine.dispose();\n        this.engine.off('recordComplete', this.engineStopCallback);\n      } // stop recording and device\n\n\n      this.stop();\n      this.stopDevice(); // stop countdown\n\n      this.player.clearInterval(this.countDown); // reset options\n\n      this.loadOptions(); // reset recorder state\n\n      this.resetState(); // reset record time\n\n      this.setDuration(this.maxLength);\n      this.setCurrentTime(0); // reset player\n\n      this.player.reset();\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          if (this.surfer && this.surfer.surfer) {\n            // empty last frame\n            this.surfer.surfer.empty();\n          }\n\n          break;\n\n        case _recordMode.IMAGE_ONLY:\n        case _recordMode.ANIMATION:\n          // reset UI\n          this.player.recordCanvas.hide();\n          this.player.cameraButton.hide();\n          break;\n      } // hide play control\n\n\n      this.player.controlBar.playToggle.hide(); // show device selection button\n\n      this.player.deviceButton.show(); // hide record button\n\n      this.player.recordToggle.hide(); // loadedmetadata resets the durationDisplay for the\n      // first time\n\n      this.player.one('loadedmetadata', function () {\n        // display max record time\n        _this7.setDuration(_this7.maxLength);\n      });\n    }\n    /**\n     * Reset the plugin recorder state.\n     * @private\n     */\n\n  }, {\n    key: \"resetState\",\n    value: function resetState() {\n      this._recording = false;\n      this._processing = false;\n      this._deviceActive = false;\n      this.devices = [];\n    }\n    /**\n     * Mute LocalMediaStream audio and video tracks.\n     *\n     * @param {boolean} mute - Whether or not the mute the track(s).\n     */\n\n  }, {\n    key: \"muteTracks\",\n    value: function muteTracks(mute) {\n      if ((this.getRecordType() === _recordMode.AUDIO_ONLY || this.getRecordType() === _recordMode.AUDIO_VIDEO) && this.stream.getAudioTracks().length > 0) {\n        this.stream.getAudioTracks()[0].enabled = !mute;\n      }\n\n      if (this.getRecordType() !== _recordMode.AUDIO_ONLY && this.stream.getVideoTracks().length > 0) {\n        this.stream.getVideoTracks()[0].enabled = !mute;\n      }\n    }\n    /**\n     * Get recorder type.\n     *\n     * @returns {string} Recorder type constant.\n     * @example\n     * console.log(player.record().getRecordType()); // 'audio_video'\n     */\n\n  }, {\n    key: \"getRecordType\",\n    value: function getRecordType() {\n      return (0, _recordMode.getRecorderMode)(this.recordImage, this.recordAudio, this.recordVideo, this.recordAnimation, this.recordScreen);\n    }\n    /**\n     * Create and display snapshot image.\n     * @private\n     */\n\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot() {\n      var _this8 = this;\n\n      this.captureFrame().then(function (result) {\n        // turn the canvas data into base64 data with a PNG header\n        _this8.player.recordedData = result.toDataURL('image/png'); // hide preview video\n\n        _this8.mediaElement.style.display = 'none'; // show the snapshot\n\n        _this8.player.recordCanvas.show(); // stop recording\n\n\n        _this8.stop();\n      });\n    }\n    /**\n     * Reset UI for retrying a snapshot image.\n     * @private\n     */\n\n  }, {\n    key: \"retrySnapshot\",\n    value: function retrySnapshot() {\n      this._processing = false; // retry: hide the snapshot\n\n      this.player.recordCanvas.hide(); // show preview video\n\n      this.player.el().firstChild.style.display = 'block';\n    }\n    /**\n     * Capture frame from camera and copy data to canvas.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"captureFrame\",\n    value: function captureFrame() {\n      var _this9 = this;\n\n      var detected = (0, _detectBrowser.detectBrowser)();\n      var recordCanvas = this.player.recordCanvas.el().firstChild; // set the canvas size to the dimensions of the camera,\n      // which also wipes the content of the canvas\n\n      recordCanvas.width = this.player.width();\n      recordCanvas.height = this.player.height();\n      return new Promise(function (resolve, reject) {\n        // MediaCapture is only supported on:\n        // - Chrome 60 and newer (see\n        // https://github.com/w3c/mediacapture-image/blob/gh-pages/implementation-status.md)\n        // - Firefox behind flag (https://bugzilla.mozilla.org/show_bug.cgi?id=888177)\n        //\n        // importing ImageCapture can fail when enabling chrome flag is still required.\n        // if so; ignore and continue\n        if (detected.browser === 'chrome' && detected.version >= 60 && (typeof ImageCapture === \"undefined\" ? \"undefined\" : _typeof(ImageCapture)) === (typeof Function === \"undefined\" ? \"undefined\" : _typeof(Function))) {\n          try {\n            var track = _this9.stream.getVideoTracks()[0];\n\n            var imageCapture = new ImageCapture(track); // take picture\n\n            imageCapture.grabFrame().then(function (imageBitmap) {\n              // get a frame and copy it onto the canvas\n              _this9.drawCanvas(recordCanvas, imageBitmap); // notify others\n\n\n              resolve(recordCanvas);\n            }).catch(function (error) {// ignore, try oldskool\n            });\n          } catch (err) {}\n        } // no ImageCapture available: do it the oldskool way\n        // get a frame and copy it onto the canvas\n\n\n        _this9.drawCanvas(recordCanvas, _this9.mediaElement); // notify others\n\n\n        resolve(recordCanvas);\n      });\n    }\n    /**\n     * Draw image frame on canvas element.\n     * @private\n     * @param {HTMLCanvasElement} canvas - Canvas to draw on.\n     * @param {HTMLElement} element - Element to draw onto the canvas.\n     */\n\n  }, {\n    key: \"drawCanvas\",\n    value: function drawCanvas(canvas, element) {\n      canvas.getContext('2d').drawImage(element, 0, 0, canvas.width, canvas.height);\n    }\n    /**\n     * Start preview of video stream.\n     * @private\n     */\n\n  }, {\n    key: \"startVideoPreview\",\n    value: function startVideoPreview() {\n      // disable playback events\n      this.off('timeupdate');\n      this.off('durationchange');\n      this.off('loadedmetadata');\n      this.off('play'); // mute local audio\n\n      this.mediaElement.muted = true; // hide volume control to prevent feedback\n\n      this.displayVolumeControl(false); // start or resume live preview\n\n      this.load(this.stream);\n      this.mediaElement.play();\n    }\n    /**\n     * Show animated GIF.\n     * @private\n     */\n\n  }, {\n    key: \"showAnimation\",\n    value: function showAnimation() {\n      var animationDisplay = this.player.animationDisplay.el().firstChild; // set the image size to the dimensions of the recorded animation\n\n      animationDisplay.width = this.player.width();\n      animationDisplay.height = this.player.height(); // hide the first frame\n\n      this.player.recordCanvas.hide(); // show the animation\n\n      (0, _browserShim.default)(this.player.recordedData, animationDisplay);\n      this.player.animationDisplay.show();\n    }\n    /**\n     * Hide animated GIF.\n     * @private\n     */\n\n  }, {\n    key: \"hideAnimation\",\n    value: function hideAnimation() {\n      // show the first frame\n      this.player.recordCanvas.show(); // hide the animation\n\n      this.player.animationDisplay.hide();\n    }\n    /**\n     * Update time during playback.\n     * @private\n     */\n\n  }, {\n    key: \"playbackTimeUpdate\",\n    value: function playbackTimeUpdate() {\n      this.setCurrentTime(this.player.currentTime(), this.streamDuration);\n    }\n    /**\n     * Received new timestamp (when timeSlice option is enabled).\n     * @private\n     * @param {float} current - Current timestamp.\n     * @param {array} all - List of timestamps so far.\n     */\n\n  }, {\n    key: \"onTimeStamp\",\n    value: function onTimeStamp(current, all) {\n      this.player.currentTimestamp = current;\n      this.player.allTimestamps = all; // get blob (only for MediaStreamRecorder)\n\n      var internal;\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          internal = this.engine.engine.audioRecorder;\n          break;\n\n        case _recordMode.ANIMATION:\n          internal = this.engine.engine.gifRecorder;\n          break;\n\n        default:\n          internal = this.engine.engine.videoRecorder;\n      }\n\n      var maxFileSizeReached = false;\n\n      if (internal) {\n        internal = internal.getInternalRecorder();\n      }\n\n      if (internal instanceof MediaStreamRecorder === true) {\n        this.player.recordedData = internal.getArrayOfBlobs(); // inject file info for newest blob\n\n        this.engine.addFileInfo(this.player.recordedData[this.player.recordedData.length - 1]); // check max file size\n\n        if (this.maxFileSize > 0) {\n          var currentSize = new Blob(this.player.recordedData).size;\n\n          if (currentSize >= this.maxFileSize) {\n            maxFileSizeReached = true;\n          }\n        }\n      } // notify others\n\n\n      this.player.trigger('timestamp'); // automatically stop when max file size was reached\n\n      if (maxFileSizeReached) {\n        this.stop();\n      }\n    }\n    /**\n     * Collects information about the media input and output devices\n     * available on the system.\n     */\n\n  }, {\n    key: \"enumerateDevices\",\n    value: function enumerateDevices() {\n      var _this10 = this;\n\n      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        this.player.enumerateErrorCode = 'enumerateDevices() not supported.';\n        this.player.trigger('enumerateError');\n        return;\n      } // list video and audio devices\n\n\n      navigator.mediaDevices.enumerateDevices(this).then(function (devices) {\n        _this10.devices = [];\n        devices.forEach(function (device) {\n          _this10.devices.push(device);\n        }); // notify listeners\n\n        _this10.player.trigger('enumerateReady');\n      }).catch(function (err) {\n        _this10.player.enumerateErrorCode = err;\n\n        _this10.player.trigger('enumerateError');\n      });\n    }\n    /**\n     * Change the audio output device.\n     *\n     * @param {string} deviceId - Id of audio output device.\n     */\n\n  }, {\n    key: \"setAudioOutput\",\n    value: function setAudioOutput(deviceId) {\n      var _this11 = this;\n\n      var errorMessage;\n\n      switch (this.getRecordType()) {\n        case _recordMode.AUDIO_ONLY:\n          // use wavesurfer\n          this.surfer.surfer.setSinkId(deviceId).then(function (result) {\n            // notify listeners\n            _this11.player.trigger('audioOutputReady');\n\n            return;\n          }).catch(function (err) {\n            errorMessage = err;\n          });\n          break;\n\n        default:\n          var element = player.tech_.el_;\n\n          if (deviceId) {\n            if (typeof element.sinkId !== 'undefined') {\n              element.setSinkId(deviceId).then(function (result) {\n                // notify listeners\n                _this11.player.trigger('audioOutputReady');\n\n                return;\n              }).catch(function (err) {\n                errorMessage = err;\n              });\n            } else {\n              errorMessage = 'Browser does not support audio output device selection.';\n            }\n          } else {\n            errorMessage = 'Invalid deviceId: ' + deviceId;\n          }\n\n          break;\n      } // error if we get here: notify listeners\n\n\n      this.player.trigger('error', errorMessage);\n    }\n    /**\n     * Show or hide the volume menu.\n     *\n     * @private\n     * @param {boolean} display - Hide/show volume control.\n     */\n\n  }, {\n    key: \"displayVolumeControl\",\n    value: function displayVolumeControl(display) {\n      if (this.player.controlBar.volumePanel !== undefined) {\n        if (display === true) {\n          display = 'flex';\n        } else {\n          display = 'none';\n        }\n\n        this.player.controlBar.volumePanel.el().style.display = display;\n      }\n    }\n  }]);\n\n  return Record;\n}(Plugin); // version nr is injected during build\n\n\nRecord.VERSION = \"3.4.0\"; // register plugin\n\n_video.default.Record = Record;\n\nif (_video.default.getPlugin('record') === undefined) {\n  _video.default.registerPlugin('record', Record);\n} // export plugin\n\n\nmodule.exports = {\n  Record: Record\n};\n\n//# sourceURL=webpack://VideojsRecord/./src/js/videojs.record.js?");

/***/ }),

/***/ 0:
/*!**********************************************************************!*\
  !*** multi ./src/js/videojs.record.js ./src/css/videojs.record.scss ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! /home/thijs/projects/videojs-record/src/js/videojs.record.js */\"./src/js/videojs.record.js\");\nmodule.exports = __webpack_require__(/*! /home/thijs/projects/videojs-record/src/css/videojs.record.scss */\"./src/css/videojs.record.scss\");\n\n\n//# sourceURL=webpack://VideojsRecord/multi_./src/js/videojs.record.js_./src/css/videojs.record.scss?");

/***/ }),

/***/ "video.js":
/*!**************************!*\
  !*** external "videojs" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_video_js__;\n\n//# sourceURL=webpack://VideojsRecord/external_%22videojs%22?");

/***/ })

/******/ });
});