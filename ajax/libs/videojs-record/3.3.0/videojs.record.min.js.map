{"version":3,"sources":["webpack://VideojsRecord/webpack/universalModuleDefinition","webpack://VideojsRecord/webpack/bootstrap","webpack://VideojsRecord/./src/js/utils/detect-browser.js","webpack://VideojsRecord/./src/js/engine/record-engine.js","webpack://VideojsRecord/./src/js/utils/file-util.js","webpack://VideojsRecord/./src/js/engine/record-mode.js","webpack://VideojsRecord/./src/js/videojs.record.js","webpack://VideojsRecord/./src/js/controls/animation-display.js","webpack://VideojsRecord/./src/js/controls/record-canvas.js","webpack://VideojsRecord/./src/js/controls/device-button.js","webpack://VideojsRecord/./src/js/controls/camera-button.js","webpack://VideojsRecord/./src/js/controls/record-toggle.js","webpack://VideojsRecord/./src/js/controls/record-indicator.js","webpack://VideojsRecord/./src/js/defaults.js","webpack://VideojsRecord/./src/js/utils/format-time.js","webpack://VideojsRecord/./src/js/utils/browser-shim.js","webpack://VideojsRecord/./node_modules/global/window.js","webpack://VideojsRecord/(webpack)/buildin/global.js","webpack://VideojsRecord/./src/js/engine/engine-loader.js","webpack://VideojsRecord/./src/js/engine/record-rtc.js","webpack://VideojsRecord/./src/js/engine/convert-engine.js","webpack://VideojsRecord/external \"videojs\""],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__20__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_window","detectBrowser","result","navigator","browser","mozGetUserMedia","version","extractVersion","userAgent","minVersion","webkitGetUserMedia","mediaDevices","match","RTCPeerConnection","uastring","expr","pos","length","parseInt","opera","indexOf","_fileUtil","Component","videojs","getComponent","AUDIO_PLUGINS","RECORD_PLUGINS","RecordEngine","player","options","_classCallCheck","this","evented","_possibleConstructorReturn","_getPrototypeOf","undefined","recordedData","URL","revokeObjectURL","fileObj","addFileInfo","data","dispose","trigger","fileName","keys","downloadBlob","registerComponent","msSaveOrOpenBlob","msSaveBlob","hyperlink","document","createElement","href","createObjectURL","download","style","body","documentElement","appendChild","click","target","dispatchEvent","MouseEvent","view","bubbles","cancelable","Promise","resolve","reject","reader","FileReader","onloadend","onerror","ev","error","readAsArrayBuffer","now","Blob","File","Date","lastModified","getTime","lastModifiedDate","e","TypeError","fileExtension","type","split","image","audio","video","animation","screen","isModeEnabled","_animationDisplay","_interopRequireDefault","_recordCanvas","_deviceButton","_cameraButton","_recordToggle","_recordIndicator","_defaults","_formatTime","_browserShim","_detectBrowser","_engineLoader","_recordMode","_video","Plugin","getPlugin","Player","play","retval","techGet_","then","Record","_this","addClass","loadOptions","resetState","deviceIcon","getRecordType","IMAGE_ONLY","VIDEO_ONLY","ANIMATION","AUDIO_ONLY","SCREEN_ONLY","DeviceButton","buildCSSClass","deviceButton","addChild","recordIndicator","RecordIndicator","hide","recordCanvas","RecordCanvas","animationDisplay","AnimationDisplay","cameraButton","CameraButton","recordToggle","RecordToggle","one","setupUI","_assertThisInitialized","newOptions","arguments","recordOptions","mergeOptions","pluginDefaultOptions","options_","plugins","record","recordImage","recordAudio","recordVideo","recordAnimation","recordScreen","maxLength","maxFileSize","msDisplayMax","parseFloat","debug","recordTimeSlice","timeSlice","autoMuteDevice","videoFrameWidth","frameWidth","videoFrameHeight","frameHeight","videoRecorderType","videoMimeType","convertEngine","audioEngine","audioRecorderType","audioWorkerURL","audioBufferSize","audioSampleRate","audioBitRate","audioChannels","audioMimeType","audioBufferUpdate","animationFrameRate","animationQuality","_this2","controlBar","el","insertBefore","firstChild","remainingTimeDisplay","display","liveDisplay","loop","surfer","wavesurfer","AUDIO_VIDEO","bigPlayButton","setDuration","usingNativeControls_","tech_","el_","controls","removeTechControlsListeners_","progressControl","on","event","userActive","show","off","playToggle","_recording","_processing","destroyed","children","_this3","deviceReadyCallback","onDeviceReady","deviceErrorCallback","onDeviceError","engineStopCallback","onRecordComplete","mediaType","microphone","un","setupPlaybackEvents","liveMode","paused","reloadBufferFunction","empty","loadDecodedBuffer","inputBuffer","start","getUserMedia","catch","gif","getDisplayMedia","stream","_this4","_deviceActive","setCurrentTime","playbackTimeUpdate","isAudioPluginActive","Error","AudioEngineClass","getAudioEngine","engine","err","bufferSize","sampleRate","bitRate","mimeType","width","height","canvas","quality","frameRate","onTimeStamp","setup","ConvertEngineClass","getConvertEngine","converter","currentTimeDisplay","timeDivider","durationDisplay","forEach","element","disable","retrySnapshot","onStop","mediaElement","muted","displayVolumeControl","load","code","isDestroyed","deviceErrorCode","_this5","isProcessing","startVideoPreview","captureFrame","muteTracks","createSnapshot","startRecording","pauseTime","pausedTime","startTime","countDown","setInterval","onCountDown","clearInterval","stop","isRecording","stopStream","stopDevice","getTracks","pause","resume","_this6","removeClass","convert","loadingSpinner","once","streamDuration","showAnimation","hideAnimation","duration","currentTime","isNaN","streamCurrentTime","getCurrentTime","contentEl","Math","min","formattedTime_","lastChild","textContent","default","url","srcObject","src","saveAs","destroy","_get","_this7","reset","devices","mute","getAudioTracks","enabled","getVideoTracks","getRecorderMode","_this8","toDataURL","_this9","detected","ImageCapture","_typeof","Function","track","grabFrame","imageBitmap","drawCanvas","getContext","drawImage","current","all","internal","currentTimestamp","allTimestamps","audioRecorder","gifRecorder","videoRecorder","maxFileSizeReached","getInternalRecorder","MediaStreamRecorder","getArrayOfBlobs","size","_this10","enumerateDevices","enumerateErrorCode","device","push","deviceId","errorMessage","_this11","setSinkId","sinkId","volumePanel","VERSION","__VERSION__","registerPlugin","className","innerHTML","Button","player_","getDevice","controlText_","onStart","recorder","controlText","enable","dir","seconds","guide","floor","h","gm","gh","ms","Infinity","mozSrcObject","global","win","self","g","_recordRtc","_convertEngine","_recordEngine","RECORDRTC","RecordRTCEngine","LIBVORBISJS","LibVorbisEngine","RECORDERJS","RecorderjsEngine","LAMEJS","LamejsEngine","OPUSRECORDER","OpusRecorderEngine","VMSG","VmsgEngine","TSEBML","TsEBMLEngine","inputStream","RecordRTC","MRecordRTC","disableLogs","numberOfAudioChannels","addStream","stopRecording","onStopRecording","pauseRecording","resumeRecording","save","audioVideoURL","mediaURL","recordType","getBlob","recording","CONVERT_PLUGINS","ConvertEngine","blobToArrayBuffer"],"mappings":"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","file":"videojs.record.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"videojs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"VideojsRecord\", [\"videojs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VideojsRecord\"] = factory(require(\"videojs\"));\n\telse\n\t\troot[\"VideojsRecord\"] = factory(root[\"videojs\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__20__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * @file detect-browser.js\n * @since 2.0.0\n */\n\nimport window from 'global/window';\n\n/**\n * Browser detector.\n *\n * @private\n * @return {object} result containing browser, version and minVersion\n *     properties.\n */\nconst detectBrowser = function() {\n    // returned result object\n    let result = {};\n    result.browser = null;\n    result.version = null;\n    result.minVersion = null;\n\n    // fail early if it's not a browser\n    if (typeof window === 'undefined' || !window.navigator) {\n        result.browser = 'Not a supported browser.';\n        return result;\n    }\n\n    if (navigator.mozGetUserMedia) { // Firefox.\n        result.browser = 'firefox';\n        result.version = extractVersion(navigator.userAgent,\n            /Firefox\\/(\\d+)\\./, 1);\n        result.minVersion = 31;\n    } else if (navigator.webkitGetUserMedia) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        result.browser = 'chrome';\n        result.version = extractVersion(navigator.userAgent,\n            /Chrom(e|ium)\\/(\\d+)\\./, 2);\n        result.minVersion = 38;\n    } else if (navigator.mediaDevices &&\n               navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n        result.browser = 'edge';\n        result.version = extractVersion(navigator.userAgent,\n            /Edge\\/(\\d+).(\\d+)$/, 2);\n        result.minVersion = 10547;\n    } else if (window.RTCPeerConnection &&\n        navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n        result.browser = 'safari';\n        result.version = extractVersion(navigator.userAgent,\n            /AppleWebKit\\/(\\d+)\\./, 1);\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = 'Not a supported browser.';\n        return result;\n    }\n\n    return result;\n};\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @private\n * @param {!string} uastring - userAgent string.\n * @param {!string} expr - Regular expression used as match criteria.\n * @param {!number} pos - position in the version string to be\n *     returned.\n * @return {!number} browser version.\n */\nconst extractVersion = function(uastring, expr, pos) {\n    let match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n};\n\nconst isEdge = function() {\n    return detectBrowser().browser === 'edge';\n};\n\nconst isSafari = function() {\n    return detectBrowser().browser === 'safari';\n};\n\nconst isOpera = function() {\n    return !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;\n};\n\nconst isChrome = function() {\n    return detectBrowser().browser === 'chrome';\n};\n\nconst isFirefox = function() {\n    return detectBrowser().browser === 'firefox';\n};\n\nexport {\n    detectBrowser, isEdge, isOpera, isChrome, isSafari, isFirefox\n};\n","/**\n * @file record-engine.js\n * @since 2.0.0\n */\n\nimport {downloadBlob, addFileInfo} from '../utils/file-util';\n\nconst Component = videojs.getComponent('Component');\n\n// supported recorder plugin engines\n// builtin\nconst RECORDRTC = 'recordrtc';\n// audio\nconst LIBVORBISJS = 'libvorbis.js';\nconst RECORDERJS = 'recorder.js';\nconst LAMEJS = 'lamejs';\nconst OPUSRECORDER = 'opus-recorder';\nconst VMSG = 'vmsg';\n\n// all audio plugins\nconst AUDIO_PLUGINS = [LIBVORBISJS, RECORDERJS, LAMEJS, OPUSRECORDER, VMSG];\n\n// all record plugins\nconst RECORD_PLUGINS = AUDIO_PLUGINS;\n\n\n/**\n * Base class for recorder backends.\n * @class\n * @augments videojs.Component\n */\nclass RecordEngine extends Component {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param  {Player} player\n     *         The `Player` that this class should be attached to.\n     *\n     * @param  {Object} [options]\n     *         The key/value store of player options.\n     */\n    constructor(player, options) {\n        // auto mixin the evented mixin (required since video.js v6.6.0)\n        options.evented = true;\n\n        super(player, options);\n    }\n\n    /**\n     * Remove any temporary data and references to streams.\n     * @private\n     */\n    dispose() {\n        // dispose previous recording\n        if (this.recordedData !== undefined) {\n            URL.revokeObjectURL(this.recordedData);\n        }\n    }\n\n    /**\n     * Add filename and timestamp to recorded file object.\n     *\n     * @param {(Blob|File)} fileObj - Blob or File object to modify.\n     */\n    addFileInfo(fileObj) {\n        addFileInfo(fileObj);\n    }\n\n    /**\n     * Invoked when recording is stopped and resulting stream is available.\n     *\n     * @param {blob} data - Reference to the recorded `Blob`.\n     * @private\n     */\n    onStopRecording(data) {\n        this.recordedData = data;\n\n        // add filename and timestamp to recorded file object\n        this.addFileInfo(this.recordedData);\n\n        // remove reference to recorded stream\n        this.dispose();\n\n        // notify listeners\n        this.trigger('recordComplete');\n    }\n\n    /**\n     * Show save as dialog in browser so the user can store the recorded media\n     * locally.\n     *\n     * @param {Object} name - Object with names for the particular blob(s)\n     *     you want to save. File extensions are added automatically. For\n     *     example: {'video': 'name-of-video-file'}. Supported keys are\n     *     'audio', 'video' and 'gif'.\n     * @example\n     * // save video file as 'foo.webm'\n     * player.record().saveAs({'video': 'foo'});\n     * @returns {void}\n     */\n    saveAs(name) {\n        let fileName = name[Object.keys(name)[0]];\n\n        // download recorded file\n        downloadBlob(fileName, this.recordedData);\n    }\n}\n\n// expose component for external plugins\nvideojs.RecordEngine = RecordEngine;\nComponent.registerComponent('RecordEngine', RecordEngine);\n\nexport {\n    RecordEngine, RECORD_PLUGINS, AUDIO_PLUGINS,\n    RECORDRTC, LIBVORBISJS, RECORDERJS, LAMEJS, OPUSRECORDER, VMSG\n};\n","/**\n * @file file-util.js\n * @since 3.3.0\n */\n\n/**\n * Download `Blob` object in browser.\n *\n * @param {string} fileName - Name for the file to download.\n * @param {blob} data - File data.\n * @returns {void}\n */\nconst downloadBlob = function(fileName, data) {\n    if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {\n        return navigator.msSaveOrOpenBlob(data, fileName);\n    } else if (typeof navigator.msSaveBlob !== 'undefined') {\n        return navigator.msSaveBlob(data, fileName);\n    }\n\n    let hyperlink = document.createElement('a');\n    hyperlink.href = URL.createObjectURL(data);\n    hyperlink.download = fileName;\n\n    hyperlink.style = 'display:none;opacity:0;color:transparent;';\n    (document.body || document.documentElement).appendChild(hyperlink);\n\n    if (typeof hyperlink.click === 'function') {\n        hyperlink.click();\n    } else {\n        hyperlink.target = '_blank';\n        hyperlink.dispatchEvent(new MouseEvent('click', {\n            view: window,\n            bubbles: true,\n            cancelable: true\n        }));\n    }\n\n    URL.revokeObjectURL(hyperlink.href);\n};\n\n/**\n * Read `Blob` as `ArrayBuffer`.\n *\n * @param {(Blob|File)} fileObj - Blob or File object to read.\n * @returns {void}\n */\nconst blobToArrayBuffer = function(fileObj) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n            resolve(reader.result);\n        };\n        reader.onerror = (ev) => {\n            reject(ev.error);\n        };\n        reader.readAsArrayBuffer(fileObj);\n    });\n};\n\n/**\n * Add filename and timestamp to recorded file object.\n *\n * @param {(Blob|File)} fileObj - Blob or File object to modify.\n * @param {date} [now] - Optional date information, default is\n *    current timestamp.\n */\nconst addFileInfo = function(fileObj, now) {\n    if (fileObj instanceof Blob || fileObj instanceof File) {\n        // set modification date\n        if (now === undefined) {\n            now = new Date();\n        }\n        try {\n            fileObj.lastModified = now.getTime();\n            fileObj.lastModifiedDate = now;\n        } catch (e) {\n            if (e instanceof TypeError) {\n                // ignore: setting getter-only property \"lastModifiedDate\"\n            } else {\n                // re-raise error\n                throw e;\n            }\n        }\n        // guess extension name from mime type, e.g. audio/ogg, but\n        // any extension is valid here. Chrome also accepts extended\n        // mime types like video/webm;codecs=h264,vp9,opus\n        let fileExtension = '.' + fileObj.type.split('/')[1];\n        if (fileExtension.indexOf(';') > -1) {\n            fileExtension = fileExtension.split(';')[0];\n        }\n\n        // use timestamp in filename, e.g. 1451180941326.ogg\n        try {\n            fileObj.name = now.getTime() + fileExtension;\n        } catch (e) {\n            if (e instanceof TypeError) {\n                // ignore: setting getter-only property \"name\"\n            } else {\n                // re-raise error\n                throw e;\n            }\n        }\n    }\n};\n\nexport {\n    downloadBlob, blobToArrayBuffer, addFileInfo\n};","/**\n * @file record-mode.js\n * @since 2.0.0\n */\n\n// recorder modes\nconst IMAGE_ONLY = 'image_only';\nconst AUDIO_ONLY = 'audio_only';\nconst VIDEO_ONLY = 'video_only';\nconst AUDIO_VIDEO = 'audio_video';\nconst ANIMATION = 'animation';\nconst SCREEN_ONLY = 'screen_only';\n\n\nconst getRecorderMode = function(image, audio, video, animation, screen) {\n    if (isModeEnabled(image)) {\n        return IMAGE_ONLY;\n\n    } else if (isModeEnabled(animation)) {\n        return ANIMATION;\n\n    } else if (isModeEnabled(screen)) {\n        return SCREEN_ONLY;\n\n    } else if (isModeEnabled(audio) && !isModeEnabled(video)) {\n        return AUDIO_ONLY;\n\n    } else if (isModeEnabled(audio) && isModeEnabled(video)) {\n        return AUDIO_VIDEO;\n\n    } else if (!isModeEnabled(audio) && isModeEnabled(video)) {\n        return VIDEO_ONLY;\n    }\n};\n\n/**\n * Check whether mode is enabled or not.\n *\n * @param {(Object|Boolean)} mode - Mode.\n * @returns {Boolean} Return boolean indicating whether mode is enabled or not.\n * @private\n */\nconst isModeEnabled = function(mode) {\n    return mode === Object(mode) || mode === true;\n};\n\nexport {\n    getRecorderMode,\n    IMAGE_ONLY, AUDIO_ONLY, VIDEO_ONLY, AUDIO_VIDEO, ANIMATION, SCREEN_ONLY\n};\n","/**\n * @file videojs.record.js\n *\n * The main file for the videojs-record project.\n * MIT license: https://github.com/collab-project/videojs-record/blob/master/LICENSE\n */\n\nimport AnimationDisplay from './controls/animation-display';\nimport RecordCanvas from './controls/record-canvas';\nimport DeviceButton from './controls/device-button';\nimport CameraButton from './controls/camera-button';\nimport RecordToggle from './controls/record-toggle';\nimport RecordIndicator from './controls/record-indicator';\n\nimport pluginDefaultOptions from './defaults';\nimport formatTime from './utils/format-time';\nimport setSrcObject from './utils/browser-shim';\nimport {detectBrowser} from './utils/detect-browser';\n\nimport {getAudioEngine, isAudioPluginActive, getConvertEngine} from './engine/engine-loader';\nimport {IMAGE_ONLY, AUDIO_ONLY, VIDEO_ONLY, AUDIO_VIDEO, ANIMATION, SCREEN_ONLY, getRecorderMode} from './engine/record-mode';\n\nimport videojs from 'video.js';\n\nconst Plugin = videojs.getPlugin('plugin');\nconst Player = videojs.getComponent('Player');\n\nconst AUTO = 'auto';\n\n\n// monkey-patch play (#152)\nPlayer.prototype.play = function play() {\n    let retval = this.techGet_('play');\n    // silence errors (unhandled promise from play)\n    if (retval !== undefined && typeof retval.then === 'function') {\n        retval.then(null, (e) => {});\n    }\n    return retval;\n};\n\n/**\n * Record audio/video/images using the Video.js player.\n *\n * @class\n * @augments videojs.Plugin\n */\nclass Record extends Plugin {\n    /**\n     * The constructor function for the class.\n     *\n     * @param {(videojs.Player|Object)} player - video.js Player object.\n     * @param {Object} options - Player options.\n     */\n    constructor(player, options) {\n        super(player, options);\n\n        // add plugin style\n        player.addClass('vjs-record');\n\n        // setup plugin options\n        this.loadOptions();\n\n        // (re)set recorder state\n        this.resetState();\n\n        // add device button with icon based on type\n        let deviceIcon = 'av-perm';\n        switch (this.getRecordType()) {\n            case IMAGE_ONLY:\n            case VIDEO_ONLY:\n            case ANIMATION:\n                deviceIcon = 'video-perm';\n                break;\n            case AUDIO_ONLY:\n                deviceIcon = 'audio-perm';\n                break;\n            case SCREEN_ONLY:\n                deviceIcon = 'screen-perm';\n                break;\n        }\n        DeviceButton.prototype.buildCSSClass = () => {\n            // use dynamic icon class\n            return 'vjs-record vjs-device-button vjs-control vjs-icon-' + deviceIcon;\n        };\n        player.deviceButton = new DeviceButton(player, options);\n        player.addChild(player.deviceButton);\n\n        // add blinking record indicator\n        player.recordIndicator = new RecordIndicator(player, options);\n        player.recordIndicator.hide();\n        player.addChild(player.recordIndicator);\n\n        // add canvas for recording and displaying image\n        player.recordCanvas = new RecordCanvas(player, options);\n        player.recordCanvas.hide();\n        player.addChild(player.recordCanvas);\n\n        // add image for animation display\n        player.animationDisplay = new AnimationDisplay(player, options);\n        player.animationDisplay.hide();\n        player.addChild(player.animationDisplay);\n\n        // add camera button\n        player.cameraButton = new CameraButton(player, options);\n        player.cameraButton.hide();\n\n        // add record toggle\n        player.recordToggle = new RecordToggle(player, options);\n        player.recordToggle.hide();\n\n        // wait until player ui is ready\n        this.player.one('ready', this.setupUI.bind(this));\n    }\n\n    /**\n     * Setup plugin options.\n     *\n     * @param {Object} newOptions - Optional new player options.\n     */\n    loadOptions(newOptions = {}) {\n        let recordOptions = videojs.mergeOptions(pluginDefaultOptions,\n            this.player.options_.plugins.record, newOptions);\n\n        // record settings\n        this.recordImage = recordOptions.image;\n        this.recordAudio = recordOptions.audio;\n        this.recordVideo = recordOptions.video;\n        this.recordAnimation = recordOptions.animation;\n        this.recordScreen = recordOptions.screen;\n        this.maxLength = recordOptions.maxLength;\n        this.maxFileSize = recordOptions.maxFileSize;\n        this.msDisplayMax = parseFloat(recordOptions.msDisplayMax);\n        this.debug = recordOptions.debug;\n        this.recordTimeSlice = recordOptions.timeSlice;\n        this.autoMuteDevice = recordOptions.autoMuteDevice;\n\n        // video/canvas settings\n        this.videoFrameWidth = recordOptions.frameWidth;\n        this.videoFrameHeight = recordOptions.frameHeight;\n        this.videoRecorderType = recordOptions.videoRecorderType;\n        this.videoMimeType = recordOptions.videoMimeType;\n\n        // convert settings\n        this.convertEngine = recordOptions.convertEngine;\n\n        // audio settings\n        this.audioEngine = recordOptions.audioEngine;\n        this.audioRecorderType = recordOptions.audioRecorderType;\n        this.audioWorkerURL = recordOptions.audioWorkerURL;\n        this.audioBufferSize = recordOptions.audioBufferSize;\n        this.audioSampleRate = recordOptions.audioSampleRate;\n        this.audioBitRate = recordOptions.audioBitRate;\n        this.audioChannels = recordOptions.audioChannels;\n        this.audioMimeType = recordOptions.audioMimeType;\n        this.audioBufferUpdate = recordOptions.audioBufferUpdate;\n\n        // animation settings\n        this.animationFrameRate = recordOptions.animationFrameRate;\n        this.animationQuality = recordOptions.animationQuality;\n    }\n\n    /**\n     * Player UI is ready.\n     * @private\n     */\n    setupUI() {\n        // insert custom controls on left-side of controlbar\n        this.player.controlBar.addChild(this.player.cameraButton);\n        this.player.controlBar.el().insertBefore(\n            this.player.cameraButton.el(),\n            this.player.controlBar.el().firstChild);\n        this.player.controlBar.el().insertBefore(\n            this.player.recordToggle.el(),\n            this.player.controlBar.el().firstChild);\n\n        // get rid of unused controls\n        if (this.player.controlBar.remainingTimeDisplay !== undefined) {\n            this.player.controlBar.remainingTimeDisplay.el().style.display = 'none';\n        }\n        if (this.player.controlBar.liveDisplay !== undefined) {\n            this.player.controlBar.liveDisplay.el().style.display = 'none';\n        }\n\n        // loop feature is never used in this plugin\n        this.player.loop(false);\n\n        // tweak player UI based on type\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                // reference to videojs-wavesurfer plugin\n                this.surfer = this.player.wavesurfer();\n                break;\n\n            case IMAGE_ONLY:\n            case VIDEO_ONLY:\n            case AUDIO_VIDEO:\n            case ANIMATION:\n            case SCREEN_ONLY:\n                // customize controls\n                this.player.bigPlayButton.hide();\n\n                // 'loadedmetadata' and 'loadstart' events reset the\n                // durationDisplay for the first time: prevent this\n                this.player.one('loadedmetadata', () => {\n                    // display max record time\n                    this.setDuration(this.maxLength);\n                });\n                this.player.one('loadstart', () => {\n                    // display max record time\n                    this.setDuration(this.maxLength);\n                });\n\n                // the native controls don't work for this UI so disable\n                // them no matter what\n                if (this.player.usingNativeControls_ === true) {\n                    if (this.player.tech_.el_ !== undefined) {\n                        this.player.tech_.el_.controls = false;\n                    }\n                }\n\n                // clicking or tapping the player video element should not try\n                // to start playback\n                this.player.removeTechControlsListeners_();\n\n                if (this.player.options_.controls) {\n                    // progress control isn't used by this plugin\n                    this.player.controlBar.progressControl.hide();\n\n                    // prevent controlbar fadeout\n                    this.player.on('userinactive', (event) => {\n                        this.player.userActive(true);\n                    });\n\n                    // videojs automatically hides the controls when no valid 'source'\n                    // element is included in the video or audio tag. Don't. Ever again.\n                    this.player.controlBar.show();\n                    this.player.controlBar.el().style.display = 'flex';\n                }\n                break;\n        }\n\n        // disable time display events that constantly try to reset the current time\n        // and duration values\n        this.player.off('timeupdate');\n        this.player.off('durationchange');\n        this.player.off('loadedmetadata');\n        this.player.off('loadstart');\n\n        // display max record time\n        this.setDuration(this.maxLength);\n\n        // hide play control\n        this.player.controlBar.playToggle.hide();\n    }\n\n    /**\n     * Indicates whether the plugin is currently recording or not.\n     *\n     * @return {boolean} Plugin currently recording or not.\n     */\n    isRecording() {\n        return this._recording;\n    }\n\n    /**\n     * Indicates whether the plugin is currently processing recorded data\n     * or not.\n     *\n     * @return {boolean} Plugin processing or not.\n     */\n    isProcessing() {\n        return this._processing;\n    }\n\n    /**\n     * Indicates whether the plugin is destroyed or not.\n     *\n     * @return {boolean} Plugin destroyed or not.\n     */\n    isDestroyed() {\n        let destroyed = (this.player === null);\n        if (destroyed === false) {\n            destroyed = (this.player.children() === null);\n        }\n        return destroyed;\n    }\n\n    /**\n     * Open the browser's recording device selection dialog.\n     */\n    getDevice() {\n        // define device callbacks once\n        if (this.deviceReadyCallback === undefined) {\n            this.deviceReadyCallback = this.onDeviceReady.bind(this);\n        }\n        if (this.deviceErrorCallback === undefined) {\n            this.deviceErrorCallback = this.onDeviceError.bind(this);\n        }\n        if (this.engineStopCallback === undefined) {\n            this.engineStopCallback = this.onRecordComplete.bind(this);\n        }\n        // ask the browser to give the user access to the media device\n        // and get a stream reference in the callback function\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                // setup microphone\n                this.mediaType = {\n                    audio: (this.audioRecorderType === AUTO) ? true : this.audioRecorderType,\n                    video: false\n                };\n                // remove existing microphone listeners\n                this.surfer.surfer.microphone.un('deviceReady',\n                    this.deviceReadyCallback);\n                this.surfer.surfer.microphone.un('deviceError',\n                    this.deviceErrorCallback);\n\n                // setup new microphone listeners\n                this.surfer.surfer.microphone.on('deviceReady',\n                    this.deviceReadyCallback);\n                this.surfer.surfer.microphone.on('deviceError',\n                    this.deviceErrorCallback);\n\n                // disable existing playback events\n                this.surfer.setupPlaybackEvents(false);\n\n                // (re)set surfer liveMode\n                this.surfer.liveMode = true;\n                this.surfer.surfer.microphone.paused = false;\n\n                // assign custom reloadBufferFunction for microphone plugin to\n                // obtain AudioBuffer chunks\n                if (this.audioBufferUpdate === true) {\n                    this.surfer.surfer.microphone.reloadBufferFunction = (event) => {\n                        if (!this.surfer.surfer.microphone.paused) {\n                            // redraw\n                            this.surfer.surfer.empty();\n                            this.surfer.surfer.loadDecodedBuffer(event.inputBuffer);\n\n                            // store data and notify others\n                            this.player.recordedData = event.inputBuffer;\n                            this.player.trigger('audioBufferUpdate');\n                        }\n                    };\n                }\n                // open browser device selection dialog\n                this.surfer.surfer.microphone.start();\n                break;\n\n            case IMAGE_ONLY:\n            case VIDEO_ONLY:\n                // setup camera\n                this.mediaType = {\n                    audio: false,\n                    video: (this.videoRecorderType === AUTO) ? true : this.videoRecorderType\n                };\n                navigator.mediaDevices.getUserMedia({\n                    audio: false,\n                    video: (this.getRecordType() === IMAGE_ONLY) ? this.recordImage : this.recordVideo\n                }).then(\n                    this.onDeviceReady.bind(this)\n                ).catch(\n                    this.onDeviceError.bind(this)\n                );\n                break;\n\n            case AUDIO_VIDEO:\n                // setup camera and microphone\n                this.mediaType = {\n                    audio: (this.audioRecorderType === AUTO) ? true : this.audioRecorderType,\n                    video: (this.videoRecorderType === AUTO) ? true : this.videoRecorderType\n                };\n                navigator.mediaDevices.getUserMedia({\n                    audio: this.recordAudio,\n                    video: this.recordVideo\n                }).then(\n                    this.onDeviceReady.bind(this)\n                ).catch(\n                    this.onDeviceError.bind(this)\n                );\n                break;\n\n            case ANIMATION:\n                // setup camera\n                this.mediaType = {\n                    // animated GIF\n                    audio: false,\n                    video: false,\n                    gif: true\n                };\n                navigator.mediaDevices.getUserMedia({\n                    audio: false,\n                    video: this.recordAnimation\n                }).then(\n                    this.onDeviceReady.bind(this)\n                ).catch(\n                    this.onDeviceError.bind(this)\n                );\n                break;\n\n            case SCREEN_ONLY:\n                // setup screen\n                this.mediaType = {\n                    // screen capture\n                    audio: false,\n                    video: false,\n                    screen: true,\n                    gif: false\n                };\n                navigator.mediaDevices.getDisplayMedia({\n                    video: true\n                }).then(\n                    this.onDeviceReady.bind(this)\n                ).catch(\n                    this.onDeviceError.bind(this)\n                );\n                break;\n        }\n    }\n\n    /**\n     * Invoked when the device is ready.\n     *\n     * @private\n     * @param {LocalMediaStream} stream - Local media stream from device.\n     */\n    onDeviceReady(stream) {\n        this._deviceActive = true;\n\n        // store reference to stream for stopping etc.\n        this.stream = stream;\n\n        // hide device selection button\n        this.player.deviceButton.hide();\n\n        // reset time (e.g. when stopDevice was used)\n        this.setDuration(this.maxLength);\n        this.setCurrentTime(0);\n\n        // hide play/pause control (e.g. when stopDevice was used)\n        this.player.controlBar.playToggle.hide();\n\n        // reset playback listeners\n        this.off(this.player, 'timeupdate', this.playbackTimeUpdate);\n        this.off(this.player, 'ended', this.playbackTimeUpdate);\n\n        // setup recording engine\n        if (this.getRecordType() !== IMAGE_ONLY) {\n            // currently record plugins are only supported in audio-only mode\n            if (this.getRecordType() !== AUDIO_ONLY && isAudioPluginActive(this.audioEngine)) {\n                throw new Error('Currently ' + this.audioEngine +\n                    ' is only supported in audio-only mode.');\n            }\n            // get audio plugin engine class\n            let AudioEngineClass = getAudioEngine(this.audioEngine);\n\n            // create recording engine\n            try {\n                // connect stream to recording engine\n                this.engine = new AudioEngineClass(this.player, this.player.options_);\n            } catch (err) {\n                throw new Error('Could not load ' + this.audioEngine +\n                    ' plugin');\n            }\n\n            // listen for events\n            this.engine.on('recordComplete', this.engineStopCallback);\n\n            // audio settings\n            this.engine.bufferSize = this.audioBufferSize;\n            this.engine.sampleRate = this.audioSampleRate;\n            this.engine.bitRate = this.audioBitRate;\n            this.engine.audioChannels = this.audioChannels;\n            this.engine.audioWorkerURL = this.audioWorkerURL;\n\n            // mime type\n            this.engine.mimeType = {\n                video: this.videoMimeType,\n                gif: 'image/gif'\n            };\n            if (this.audioMimeType !== null &&\n                this.audioMimeType !== AUTO) {\n                this.engine.mimeType.audio = this.audioMimeType;\n            }\n\n            // video/canvas settings\n            this.engine.video = {\n                width: this.videoFrameWidth,\n                height: this.videoFrameHeight\n            };\n            this.engine.canvas = {\n                width: this.videoFrameWidth,\n                height: this.videoFrameHeight\n            };\n\n            // animated GIF settings\n            this.engine.quality = this.animationQuality;\n            this.engine.frameRate = this.animationFrameRate;\n\n            // timeSlice\n            if (this.recordTimeSlice && this.recordTimeSlice > 0) {\n                this.engine.timeSlice = this.recordTimeSlice;\n                this.engine.onTimeStamp = this.onTimeStamp.bind(this);\n            }\n\n            // initialize recorder\n            this.engine.setup(this.stream, this.mediaType, this.debug);\n\n            // create converter engine\n            if (this.convertEngine !== '') {\n                let ConvertEngineClass = getConvertEngine(this.convertEngine);\n                try {\n                    this.converter = new ConvertEngineClass(this.player,\n                        this.player.options_);\n                }\n                catch (err) {\n                    throw new Error('Could not load ' + this.convertEngine +\n                        ' plugin');\n                }\n\n                // initialize converter\n                this.converter.setup(this.mediaType, this.debug);\n            }\n\n            // show elements that should never be hidden in animation,\n            // audio and/or video modus\n            let uiElements = [\n                this.player.controlBar.currentTimeDisplay,\n                this.player.controlBar.timeDivider,\n                this.player.controlBar.durationDisplay\n            ];\n            uiElements.forEach((element) => {\n                if (element !== undefined) {\n                    element.el().style.display = 'block';\n                    element.show();\n                }\n            });\n\n            // show record button\n            this.player.recordToggle.show();\n        } else {\n            // disable record indicator\n            this.player.recordIndicator.disable();\n\n            // setup UI for retrying snapshot (e.g. when stopDevice was\n            // used)\n            this.retrySnapshot();\n\n            // reset and show camera button\n            this.player.cameraButton.onStop();\n            this.player.cameraButton.show();\n        }\n\n        // setup preview\n        if (this.getRecordType() !== AUDIO_ONLY) {\n            // show live preview\n            this.mediaElement = this.player.el().firstChild;\n            this.mediaElement.controls = false;\n\n            // mute incoming audio for feedback loops\n            this.mediaElement.muted = true;\n\n            // hide the volume bar while it's muted\n            this.displayVolumeControl(false);\n\n            // load stream\n            this.load(this.stream);\n\n            // stream loading is async, so we wait until it's ready to play\n            // the stream\n            this.player.one('loadedmetadata', () => {\n                // start stream\n                this.mediaElement.play();\n\n                // forward to listeners\n                this.player.trigger('deviceReady');\n            });\n        } else {\n            // forward to listeners\n            this.player.trigger('deviceReady');\n        }\n    }\n\n    /**\n     * Invoked when an device error occurred.\n     *\n     * @private\n     * @param {(string|number)} code - Error code/description.\n     */\n    onDeviceError(code) {\n        this._deviceActive = false;\n\n        if (!this.isDestroyed()) {\n            // store code\n            this.player.deviceErrorCode = code;\n\n            // forward error to player\n            this.player.trigger('deviceError');\n        }\n    }\n\n    /**\n     * Start recording.\n     */\n    start() {\n        if (!this.isProcessing()) {\n            this._recording = true;\n\n            // hide play/pause control\n            this.player.controlBar.playToggle.hide();\n\n            // reset playback listeners\n            this.off(this.player, 'timeupdate', this.playbackTimeUpdate);\n            this.off(this.player, 'ended', this.playbackTimeUpdate);\n\n            // start preview\n            switch (this.getRecordType()) {\n                case AUDIO_ONLY:\n                    // disable playback events\n                    this.surfer.setupPlaybackEvents(false);\n\n                    // start/resume live audio visualization\n                    this.surfer.surfer.microphone.paused = false;\n                    this.surfer.liveMode = true;\n                    this.surfer.surfer.microphone.play();\n                    break;\n\n                case VIDEO_ONLY:\n                case AUDIO_VIDEO:\n                case SCREEN_ONLY:\n                    // preview video stream in video element\n                    this.startVideoPreview();\n                    break;\n\n                case ANIMATION:\n                    // hide the first frame\n                    this.player.recordCanvas.hide();\n\n                    // hide the animation\n                    this.player.animationDisplay.hide();\n\n                    // show preview video\n                    this.mediaElement.style.display = 'block';\n\n                    // for animations, capture the first frame\n                    // that can be displayed as soon as recording\n                    // is complete\n                    this.captureFrame().then((result) => {\n                        // start video preview **after** capturing first frame\n                        this.startVideoPreview();\n                    });\n                    break;\n            }\n\n            if (this.autoMuteDevice) {\n                // unmute device\n                this.muteTracks(false);\n            }\n\n            // start recording\n            switch (this.getRecordType()) {\n                case IMAGE_ONLY:\n                    // create snapshot\n                    this.createSnapshot();\n\n                    // notify UI\n                    this.player.trigger('startRecord');\n                    break;\n\n                case VIDEO_ONLY:\n                case AUDIO_VIDEO:\n                case ANIMATION:\n                case SCREEN_ONLY:\n                    // wait for media stream on video element to actually load\n                    this.player.one('loadedmetadata', () => {\n                        // start actually recording process\n                        this.startRecording();\n                    });\n                    break;\n\n                default:\n                    // all resources have already loaded, so we can start\n                    // recording right away\n                    this.startRecording();\n            }\n        }\n    }\n\n    /**\n     * Start recording.\n     * @private\n     */\n    startRecording() {\n        // register starting point\n        this.paused = false;\n        this.pauseTime = this.pausedTime = 0;\n        this.startTime = new Date().getTime();\n\n        // start countdown\n        this.countDown = this.player.setInterval(\n            this.onCountDown.bind(this), 100);\n\n        // cleanup previous recording\n        if (this.engine !== undefined) {\n            this.engine.dispose();\n        }\n\n        // start recording stream\n        this.engine.start();\n\n        // notify UI\n        this.player.trigger('startRecord');\n    }\n\n    /**\n     * Stop recording.\n     */\n    stop() {\n        if (!this.isProcessing()) {\n            this._recording = false;\n            this._processing = true;\n\n            if (this.getRecordType() !== IMAGE_ONLY) {\n                // notify UI\n                this.player.trigger('stopRecord');\n\n                // stop countdown\n                this.player.clearInterval(this.countDown);\n\n                // stop recording stream (result will be available async)\n                if (this.engine) {\n                    this.engine.stop();\n                }\n\n                if (this.autoMuteDevice) {\n                    // mute device\n                    this.muteTracks(true);\n                }\n            } else {\n                if (this.player.recordedData) {\n                    // notify listeners that image data is (already) available\n                    this.player.trigger('finishRecord');\n                }\n            }\n        }\n    }\n\n    /**\n     * Stop device(s) and recording if active.\n     */\n    stopDevice() {\n        if (this.isRecording()) {\n            // stop stream once recorded data is available,\n            // otherwise it'll break recording\n            this.player.one('finishRecord', this.stopStream.bind(this));\n\n            // stop recording\n            this.stop();\n        } else {\n            // stop stream now, since there's no recorded data available\n            this.stopStream();\n        }\n    }\n\n    /**\n     * Stop stream and device.\n     */\n    stopStream() {\n        // stop stream and device\n        if (this.stream) {\n            this._deviceActive = false;\n\n            if (this.getRecordType() === AUDIO_ONLY) {\n                // make the microphone plugin stop it's device\n                this.surfer.surfer.microphone.stopDevice();\n                return;\n            }\n            this.stream.getTracks().forEach((stream) => {\n                stream.stop();\n            });\n        }\n    }\n\n    /**\n     * Pause recording.\n     */\n    pause() {\n        if (!this.paused) {\n            this.pauseTime = new Date().getTime();\n            this.paused = true;\n\n            this.engine.pause();\n        }\n    }\n\n    /**\n     * Resume recording.\n     */\n    resume() {\n        if (this.paused) {\n            this.pausedTime += new Date().getTime() - this.pauseTime;\n\n            this.engine.resume();\n            this.paused = false;\n        }\n    }\n\n    /**\n     * Invoked when recording completed and the resulting stream is\n     * available.\n     * @private\n     */\n    onRecordComplete() {\n        // store reference to recorded stream data\n        this.player.recordedData = this.engine.recordedData;\n\n        // change the replay button back to a play button\n        this.player.controlBar.playToggle.removeClass('vjs-ended');\n        this.player.controlBar.playToggle.show();\n\n        // notify converter\n        if (this.converter !== undefined) {\n            this.converter.convert(this.player.recordedData);\n        }\n\n        // notify listeners that data is available\n        this.player.trigger('finishRecord');\n\n        // skip loading when player is destroyed after finishRecord event\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // load and display recorded data\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                // pause player so user can start playback\n                this.surfer.pause();\n\n                // setup events for playback\n                this.surfer.setupPlaybackEvents(true);\n\n                // display loader\n                this.player.loadingSpinner.show();\n\n                // restore interaction with controls after waveform\n                // rendering is complete\n                this.surfer.surfer.once('ready', () => {\n                    this._processing = false;\n                });\n\n                // visualize recorded stream\n                this.load(this.player.recordedData);\n                break;\n\n            case VIDEO_ONLY:\n            case AUDIO_VIDEO:\n            case SCREEN_ONLY:\n                // pausing the player so we can visualize the recorded data\n                // will trigger an async video.js 'pause' event that we\n                // have to wait for.\n                this.player.one('pause', () => {\n                    // video data is ready\n                    this._processing = false;\n\n                    // hide loader\n                    this.player.loadingSpinner.hide();\n\n                    // show stream total duration\n                    this.setDuration(this.streamDuration);\n\n                    // update time during playback and at end\n                    this.on(this.player, 'timeupdate',\n                        this.playbackTimeUpdate);\n                    this.on(this.player, 'ended',\n                        this.playbackTimeUpdate);\n\n                    // unmute local audio during playback\n                    if (this.getRecordType() === AUDIO_VIDEO) {\n                        this.mediaElement.muted = false;\n\n                        // show the volume bar when it's unmuted\n                        this.displayVolumeControl(true);\n                    }\n\n                    // load recorded media\n                    this.load(this.player.recordedData);\n                });\n\n                // pause player so user can start playback\n                this.player.pause();\n                break;\n\n            case ANIMATION:\n                // animation data is ready\n                this._processing = false;\n\n                // hide loader\n                this.player.loadingSpinner.hide();\n\n                // show animation total duration\n                this.setDuration(this.streamDuration);\n\n                // hide preview video\n                this.mediaElement.style.display = 'none';\n\n                // show the first frame\n                this.player.recordCanvas.show();\n\n                // pause player so user can start playback\n                this.player.pause();\n\n                // show animation on play\n                this.on(this.player, 'play', this.showAnimation);\n\n                // hide animation on pause\n                this.on(this.player, 'pause', this.hideAnimation);\n                break;\n        }\n    }\n\n    /**\n     * Invoked during recording and displays the remaining time.\n     * @private\n     */\n    onCountDown() {\n        if (!this.paused) {\n            let now = new Date().getTime();\n            let duration = this.maxLength;\n            let currentTime = (now - (this.startTime + this.pausedTime)) / 1000;\n\n            this.streamDuration = currentTime;\n\n            if (currentTime >= duration) {\n                // at the end\n                currentTime = duration;\n\n                // stop recording\n                this.stop();\n            }\n\n            // update duration\n            this.setDuration(duration);\n\n            // update current time\n            this.setCurrentTime(currentTime, duration);\n\n            // notify listeners\n            this.player.trigger('progressRecord');\n        }\n    }\n\n    /**\n     * Get the current time of the recorded stream during playback.\n     *\n     * Returns 0 if no recording is available (yet).\n     *\n     * @returns {float} Current time of the recorded stream.\n     */\n    getCurrentTime() {\n        let currentTime = isNaN(this.streamCurrentTime) ? 0 : this.streamCurrentTime;\n\n        if (this.getRecordType() === AUDIO_ONLY) {\n            currentTime = this.surfer.getCurrentTime();\n        }\n\n        return currentTime;\n    }\n\n    /**\n     * Updates the player's element displaying the current time.\n     *\n     * @private\n     * @param {number} [currentTime=0] - Current position of the\n     *    playhead (in seconds).\n     * @param {number} [duration=0] - Duration in seconds.\n     */\n    setCurrentTime(currentTime, duration) {\n        currentTime = isNaN(currentTime) ? 0 : currentTime;\n        duration = isNaN(duration) ? 0 : duration;\n\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                this.surfer.setCurrentTime(currentTime, duration);\n                break;\n\n            case VIDEO_ONLY:\n            case AUDIO_VIDEO:\n            case ANIMATION:\n            case SCREEN_ONLY:\n                if (this.player.controlBar.currentTimeDisplay &&\n                    this.player.controlBar.currentTimeDisplay.contentEl()) {\n                    this.streamCurrentTime = Math.min(currentTime, duration);\n\n                    // update current time display component\n                    this.player.controlBar.currentTimeDisplay.formattedTime_ =\n                        this.player.controlBar.currentTimeDisplay.contentEl().lastChild.textContent =\n                            formatTime(this.streamCurrentTime, duration, this.msDisplayMax);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Get the length of the recorded stream in seconds.\n     *\n     * Returns 0 if no recording is available (yet).\n     *\n     * @returns {float} Duration of the recorded stream.\n     */\n    getDuration() {\n        let duration = isNaN(this.streamDuration) ? 0 : this.streamDuration;\n\n        return duration;\n    }\n\n    /**\n     * Updates the player's element displaying the duration time.\n     *\n     * @param {number} [duration=0] - Duration in seconds.\n     * @private\n     */\n    setDuration(duration) {\n        duration = isNaN(duration) ? 0 : duration;\n\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                this.surfer.setDuration(duration);\n                break;\n\n            case VIDEO_ONLY:\n            case AUDIO_VIDEO:\n            case ANIMATION:\n            case SCREEN_ONLY:\n                // update duration display component\n                if (this.player.controlBar.durationDisplay &&\n                    this.player.controlBar.durationDisplay.contentEl()) {\n                    this.player.controlBar.durationDisplay.formattedTime_ =\n                    this.player.controlBar.durationDisplay.contentEl().lastChild.textContent =\n                        formatTime(duration, duration, this.msDisplayMax);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Start loading data.\n     *\n     * @param {(string|blob|file)} url - Either the URL of the media file,\n     *     a Blob, a File object or MediaStream.\n     */\n    load(url) {\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                // visualize recorded Blob stream\n                this.surfer.load(url);\n                break;\n\n            case IMAGE_ONLY:\n            case VIDEO_ONLY:\n            case AUDIO_VIDEO:\n            case ANIMATION:\n            case SCREEN_ONLY:\n                if (url instanceof Blob || url instanceof File) {\n                    // make sure to reset it (#312)\n                    this.mediaElement.srcObject = null;\n                    // assign blob using createObjectURL\n                    this.mediaElement.src = URL.createObjectURL(url);\n                } else {\n                    // assign stream with srcObject\n                    setSrcObject(url, this.mediaElement);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Show save as dialog in browser so the user can store the recorded media\n     * locally.\n     *\n     * @param {object} name - Object with one or more names for the particular\n     *     blob(s) you want to save. File extensions are added automatically.\n     *     For example: {'video': 'name-of-video-file'}. Supported keys are\n     *     'audio', 'video' and 'gif'.\n     * @example\n     * // save video file as 'foo.webm'\n     * player.record().saveAs({'video': 'foo'});\n     */\n    saveAs(name) {\n        if (this.engine && name !== undefined) {\n            this.engine.saveAs(name);\n        }\n    }\n\n    /**\n     * Destroy plugin only.\n     *\n     * Use [destroy]{@link Record#destroy} to remove the plugin and the player\n     * as well.\n     */\n    dispose() {\n        // disable common event listeners\n        this.player.off('ready');\n        this.player.off('userinactive');\n        this.player.off('loadedmetadata');\n\n        // prevent callbacks if recording is in progress\n        if (this.engine) {\n            this.engine.dispose();\n            this.engine.off('recordComplete', this.engineStopCallback);\n        }\n\n        // stop recording and device\n        this.stop();\n        this.stopDevice();\n\n        // stop countdown\n        this.player.clearInterval(this.countDown);\n\n        // dispose wavesurfer.js\n        if (this.getRecordType() === AUDIO_ONLY) {\n            if (this.surfer) {\n                // also disposes player\n                this.surfer.destroy();\n            }\n        }\n\n        this.resetState();\n\n        super.dispose();\n    }\n\n    /**\n     * Destroy plugin and players and cleanup resources.\n     */\n    destroy() {\n        this.player.dispose();\n    }\n\n    /**\n     * Reset the plugin.\n     */\n    reset() {\n        // prevent callbacks if recording is in progress\n        if (this.engine) {\n            this.engine.dispose();\n            this.engine.off('recordComplete', this.engineStopCallback);\n        }\n\n        // stop recording and device\n        this.stop();\n        this.stopDevice();\n\n        // stop countdown\n        this.player.clearInterval(this.countDown);\n\n        // reset options\n        this.loadOptions();\n\n        // reset recorder state\n        this.resetState();\n\n        // reset record time\n        this.setDuration(this.maxLength);\n        this.setCurrentTime(0);\n\n        // reset player\n        this.player.reset();\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                if (this.surfer && this.surfer.surfer) {\n                    // empty last frame\n                    this.surfer.surfer.empty();\n                }\n                break;\n\n            case IMAGE_ONLY:\n            case ANIMATION:\n                // reset UI\n                this.player.recordCanvas.hide();\n                this.player.cameraButton.hide();\n                break;\n        }\n\n        // hide play control\n        this.player.controlBar.playToggle.hide();\n\n        // show device selection button\n        this.player.deviceButton.show();\n\n        // hide record button\n        this.player.recordToggle.hide();\n\n        // loadedmetadata resets the durationDisplay for the\n        // first time\n        this.player.one('loadedmetadata', () => {\n            // display max record time\n            this.setDuration(this.maxLength);\n        });\n    }\n\n    /**\n     * Reset the plugin recorder state.\n     * @private\n     */\n    resetState() {\n        this._recording = false;\n        this._processing = false;\n        this._deviceActive = false;\n        this.devices = [];\n    }\n\n    /**\n     * Mute LocalMediaStream audio and video tracks.\n     *\n     * @param {boolean} mute - Whether or not the mute the track(s).\n     */\n    muteTracks(mute) {\n        if ((this.getRecordType() === AUDIO_ONLY ||\n            this.getRecordType() === AUDIO_VIDEO) &&\n            this.stream.getAudioTracks().length > 0) {\n            this.stream.getAudioTracks()[0].enabled = !mute;\n        }\n\n        if (this.getRecordType() !== AUDIO_ONLY &&\n            this.stream.getVideoTracks().length > 0) {\n            this.stream.getVideoTracks()[0].enabled = !mute;\n        }\n    }\n\n    /**\n     * Get recorder type.\n     *\n     * @returns {string} Recorder type constant.\n     * @example\n     * console.log(player.record().getRecordType()); // 'audio_video'\n     */\n    getRecordType() {\n        return getRecorderMode(this.recordImage, this.recordAudio,\n            this.recordVideo, this.recordAnimation, this.recordScreen);\n    }\n\n    /**\n     * Create and display snapshot image.\n     * @private\n     */\n    createSnapshot() {\n        this.captureFrame().then((result) => {\n            // turn the canvas data into base64 data with a PNG header\n            this.player.recordedData = result.toDataURL('image/png');\n\n            // hide preview video\n            this.mediaElement.style.display = 'none';\n\n            // show the snapshot\n            this.player.recordCanvas.show();\n\n            // stop recording\n            this.stop();\n        });\n    }\n\n    /**\n     * Reset UI for retrying a snapshot image.\n     * @private\n     */\n    retrySnapshot() {\n        this._processing = false;\n\n        // retry: hide the snapshot\n        this.player.recordCanvas.hide();\n\n        // show preview video\n        this.player.el().firstChild.style.display = 'block';\n    }\n\n    /**\n     * Capture frame from camera and copy data to canvas.\n     * @private\n     * @returns {void}\n     */\n    captureFrame() {\n        let detected = detectBrowser();\n        let recordCanvas = this.player.recordCanvas.el().firstChild;\n\n        // set the canvas size to the dimensions of the camera,\n        // which also wipes the content of the canvas\n        recordCanvas.width = this.player.width();\n        recordCanvas.height = this.player.height();\n\n        return new Promise((resolve, reject) => {\n            // MediaCapture is only supported on:\n            // - Chrome 60 and newer (see\n            // https://github.com/w3c/mediacapture-image/blob/gh-pages/implementation-status.md)\n            // - Firefox behind flag (https://bugzilla.mozilla.org/show_bug.cgi?id=888177)\n            //\n            // importing ImageCapture can fail when enabling chrome flag is still required.\n            // if so; ignore and continue\n            if ((detected.browser === 'chrome' && detected.version >= 60) &&\n               (typeof ImageCapture === typeof Function)) {\n                try {\n                    let track = this.stream.getVideoTracks()[0];\n                    let imageCapture = new ImageCapture(track);\n                    // take picture\n                    imageCapture.grabFrame().then((imageBitmap) => {\n                        // get a frame and copy it onto the canvas\n                        this.drawCanvas(recordCanvas, imageBitmap);\n\n                        // notify others\n                        resolve(recordCanvas);\n                    }).catch((error) => {\n                        // ignore, try oldskool\n                    });\n                } catch (err) {}\n            }\n            // no ImageCapture available: do it the oldskool way\n\n            // get a frame and copy it onto the canvas\n            this.drawCanvas(recordCanvas, this.mediaElement);\n\n            // notify others\n            resolve(recordCanvas);\n        });\n    }\n\n    /**\n     * Draw image frame on canvas element.\n     * @private\n     * @param {HTMLCanvasElement} canvas - Canvas to draw on.\n     * @param {HTMLElement} element - Element to draw onto the canvas.\n     */\n    drawCanvas(canvas, element) {\n        canvas.getContext('2d').drawImage(\n            element, 0, 0,\n            canvas.width,\n            canvas.height\n        );\n    }\n\n    /**\n     * Start preview of video stream.\n     * @private\n     */\n    startVideoPreview() {\n        // disable playback events\n        this.off('timeupdate');\n        this.off('durationchange');\n        this.off('loadedmetadata');\n        this.off('play');\n\n        // mute local audio\n        this.mediaElement.muted = true;\n\n        // hide volume control to prevent feedback\n        this.displayVolumeControl(false);\n\n        // start or resume live preview\n        this.load(this.stream);\n        this.mediaElement.play();\n    }\n\n    /**\n     * Show animated GIF.\n     * @private\n     */\n    showAnimation() {\n        let animationDisplay = this.player.animationDisplay.el().firstChild;\n\n        // set the image size to the dimensions of the recorded animation\n        animationDisplay.width = this.player.width();\n        animationDisplay.height = this.player.height();\n\n        // hide the first frame\n        this.player.recordCanvas.hide();\n\n        // show the animation\n        setSrcObject(this.player.recordedData, animationDisplay);\n        this.player.animationDisplay.show();\n    }\n\n    /**\n     * Hide animated GIF.\n     * @private\n     */\n    hideAnimation() {\n        // show the first frame\n        this.player.recordCanvas.show();\n\n        // hide the animation\n        this.player.animationDisplay.hide();\n    }\n\n    /**\n     * Update time during playback.\n     * @private\n     */\n    playbackTimeUpdate() {\n        this.setCurrentTime(this.player.currentTime(),\n            this.streamDuration);\n    }\n\n    /**\n     * Received new timestamp (when timeSlice option is enabled).\n     * @private\n     * @param {float} current - Current timestamp.\n     * @param {array} all - List of timestamps so far.\n     */\n    onTimeStamp(current, all) {\n        this.player.currentTimestamp = current;\n        this.player.allTimestamps = all;\n\n        // get blob (only for MediaStreamRecorder)\n        let internal;\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                internal = this.engine.engine.audioRecorder;\n                break;\n\n            case ANIMATION:\n                internal = this.engine.engine.gifRecorder;\n                break;\n\n            default:\n                internal = this.engine.engine.videoRecorder;\n        }\n\n        let maxFileSizeReached = false;\n        if (internal) {\n            internal = internal.getInternalRecorder();\n        }\n\n        if ((internal instanceof MediaStreamRecorder) === true) {\n            this.player.recordedData = internal.getArrayOfBlobs();\n\n            // inject file info for newest blob\n            this.engine.addFileInfo(\n                this.player.recordedData[this.player.recordedData.length - 1]);\n\n            // check max file size\n            if (this.maxFileSize > 0) {\n                let currentSize = new Blob(this.player.recordedData).size;\n                if (currentSize >= this.maxFileSize) {\n                    maxFileSizeReached = true;\n                }\n            }\n        }\n\n        // notify others\n        this.player.trigger('timestamp');\n\n        // automatically stop when max file size was reached\n        if (maxFileSizeReached) {\n            this.stop();\n        }\n    }\n\n    /**\n     * Collects information about the media input and output devices\n     * available on the system.\n     */\n    enumerateDevices() {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n            this.player.enumerateErrorCode = 'enumerateDevices() not supported.';\n            this.player.trigger('enumerateError');\n            return;\n        }\n\n        // List cameras and microphones.\n        navigator.mediaDevices.enumerateDevices(this).then((devices) => {\n            this.devices = [];\n            devices.forEach((device) => {\n                this.devices.push(device);\n            });\n\n            // notify listeners\n            this.player.trigger('enumerateReady');\n        }).catch((err) => {\n            this.player.enumerateErrorCode = err;\n            this.player.trigger('enumerateError');\n        });\n    }\n\n    /**\n     * Change the audio output device.\n     *\n     * @param {string} deviceId - Id of audio output device.\n     */\n    setAudioOutput(deviceId) {\n        let errorMessage;\n\n        switch (this.getRecordType()) {\n            case AUDIO_ONLY:\n                // use wavesurfer\n                this.surfer.surfer.setSinkId(deviceId).then((result) => {\n                    // notify listeners\n                    this.player.trigger('audioOutputReady');\n                    return;\n                }).catch((err) => {\n                    errorMessage = err;\n                });\n                break;\n\n            default:\n                let element = player.tech_.el_;\n                if (deviceId) {\n                    if (typeof element.sinkId !== 'undefined') {\n                        element.setSinkId(deviceId).then((result) => {\n                            // notify listeners\n                            this.player.trigger('audioOutputReady');\n                            return;\n                        }).catch((err) => {\n                            errorMessage = err;\n                        });\n                    } else {\n                        errorMessage = 'Browser does not support audio output device selection.';\n                    }\n                } else {\n                    errorMessage = 'Invalid deviceId: ' + deviceId;\n                }\n                break;\n        }\n\n        // error if we get here: notify listeners\n        this.player.trigger('error', errorMessage);\n    }\n\n    /**\n     * Show or hide the volume menu.\n     *\n     * @private\n     * @param {boolean} display - Hide/show volume control.\n     */\n    displayVolumeControl(display) {\n        if (this.player.controlBar.volumePanel !== undefined) {\n            if (display === true) {\n                display = 'flex';\n            } else {\n                display = 'none';\n            }\n            this.player.controlBar.volumePanel.el().style.display = display;\n        }\n    }\n}\n\n// version nr is injected during build\nRecord.VERSION = __VERSION__;\n\n// register plugin\nvideojs.Record = Record;\nif (videojs.getPlugin('record') === undefined) {\n    videojs.registerPlugin('record', Record);\n}\n\n// export plugin\nmodule.exports = {\n    Record\n};\n","/**\n * @file animation-display.js\n * @since 2.0.0\n */\n\nconst Component = videojs.getComponent('Component');\n\n/**\n * Image for displaying animated GIF image.\n *\n * @class\n * @augments videojs.Component\n*/\nclass AnimationDisplay extends Component {\n\n    /**\n     * Create the `AnimationDisplay`s DOM element.\n     *\n     * @return {Element}\n     *         The dom element that gets created.\n     */\n    createEl() {\n        return super.createEl('div', {\n            className: 'vjs-animation-display',\n            innerHTML: '<img />'\n        });\n    }\n}\n\nComponent.registerComponent('AnimationDisplay', AnimationDisplay);\n\nexport default AnimationDisplay;\n","/**\n * @file record-canvas\n * @since 2.0.0\n */\n\nconst Component = videojs.getComponent('Component');\n\n/**\n * Canvas for displaying snapshot image.\n *\n * @class\n * @augments videojs.Component\n*/\nclass RecordCanvas extends Component {\n\n    /**\n     * Create the `RecordCanvas`s DOM element.\n     *\n     * @return {Element}\n     *         The dom element that gets created.\n     */\n    createEl() {\n        return super.createEl('div', {\n            className: 'vjs-record-canvas',\n            innerHTML: '<canvas></canvas>'\n        });\n    }\n}\n\nComponent.registerComponent('RecordCanvas', RecordCanvas);\n\nexport default RecordCanvas;\n","/**\n * @file device-button.js\n * @since 2.0.0\n */\n\nconst Button = videojs.getComponent('Button');\nconst Component = videojs.getComponent('Component');\n\n/**\n * Button to select recording device.\n *\n * @class\n * @augments videojs.Button\n*/\nclass DeviceButton extends Button {\n    /**\n     * This gets called when this button gets:\n     *\n     * - Clicked (via the `click` event, listening starts in the constructor)\n     * - Tapped (via the `tap` event, listening starts in the constructor)\n     *\n     * @param {EventTarget~Event} event\n     *        The `keydown`, `tap`, or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n        // open device dialog\n        this.player_.record().getDevice();\n    }\n}\n\n/**\n * The text that should display over the `DeviceButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nDeviceButton.prototype.controlText_ = 'Device';\n\nComponent.registerComponent('DeviceButton', DeviceButton);\n\nexport default DeviceButton;\n","/**\n * @file camera-button.js\n * @since 2.0.0\n */\n\nconst Button = videojs.getComponent('Button');\nconst Component = videojs.getComponent('Component');\n\n/**\n * Button to toggle between create and retry snapshot image.\n *\n * @class\n * @augments videojs.Button\n*/\nclass CameraButton extends Button {\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n        return 'vjs-camera-button vjs-control vjs-button vjs-icon-photo-camera';\n    }\n\n    /**\n     * Enable the `CameraButton` element so that it can be activated or clicked.\n     */\n    enable() {\n        super.enable();\n\n        this.on(this.player_, 'startRecord', this.onStart);\n        this.on(this.player_, 'stopRecord', this.onStop);\n    }\n\n    /**\n     * Disable the `CameraButton` element so that it cannot be activated or clicked.\n     */\n    disable() {\n        super.disable();\n\n        this.off(this.player_, 'startRecord', this.onStart);\n        this.off(this.player_, 'stopRecord', this.onStop);\n    }\n\n    /**\n     * This gets called when the button is clicked.\n     *\n     * @param {EventTarget~Event} event\n     *        The `tap` or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n        let recorder = this.player_.record();\n\n        if (!recorder.isProcessing()) {\n            // create snapshot\n            recorder.start();\n        } else {\n            // retry\n            recorder.retrySnapshot();\n\n            // reset camera button\n            this.onStop();\n        }\n    }\n\n    /**\n     * Add the vjs-icon-replay class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#startRecord\n     */\n    onStart(event) {\n        // replace element class so it can change appearance\n        this.removeClass('vjs-icon-photo-camera');\n        this.addClass('vjs-icon-replay');\n\n        // change the button text\n        this.controlText('Retry');\n    }\n\n    /**\n     * Add the vjs-icon-photo-camera class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#stopRecord\n     */\n    onStop(event) {\n        // replace element class so it can change appearance\n        this.removeClass('vjs-icon-replay');\n        this.addClass('vjs-icon-photo-camera');\n\n        // change the button text\n        this.controlText('Image');\n    }\n}\n\n/**\n * The text that should display over the `CameraButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nCameraButton.prototype.controlText_ = 'Image';\n\nComponent.registerComponent('CameraButton', CameraButton);\n\nexport default CameraButton;\n","/**\n * @file record-toggle.js\n * @since 2.0.0\n */\n\nconst Button = videojs.getComponent('Button');\nconst Component = videojs.getComponent('Component');\n\n/**\n * Button to toggle between start and stop recording.\n *\n * @class\n * @augments videojs.Button\n*/\nclass RecordToggle extends Button {\n    /**\n     * Builds the default DOM `className`.\n     *\n     * @return {string}\n     *         The DOM `className` for this object.\n     */\n    buildCSSClass() {\n        return 'vjs-record-button vjs-control vjs-button vjs-icon-record-start';\n    }\n\n    /**\n     * Enable the `RecordToggle` element so that it can be activated or clicked.\n     */\n    enable() {\n        super.enable();\n\n        this.on(this.player_, 'startRecord', this.onStart);\n        this.on(this.player_, 'stopRecord', this.onStop);\n    }\n\n    /**\n     * Disable the `RecordToggle` element so that it cannot be activated or clicked.\n     */\n    disable() {\n        super.disable();\n\n        this.off(this.player_, 'startRecord', this.onStart);\n        this.off(this.player_, 'stopRecord', this.onStop);\n    }\n\n    /**\n     * This gets called when the button is clicked.\n     *\n     * @param {EventTarget~Event} event\n     *        The `tap` or `click` event that caused this function to be\n     *        called.\n     *\n     * @listens tap\n     * @listens click\n     */\n    handleClick(event) {\n        let recorder = this.player_.record();\n        if (!recorder.isRecording()) {\n            recorder.start();\n        } else {\n            recorder.stop();\n        }\n    }\n\n    /**\n     * Add the vjs-icon-record-stop class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#startRecord\n     */\n    onStart(event) {\n        // replace element class so it can change appearance\n        this.removeClass('vjs-icon-record-start');\n        this.addClass('vjs-icon-record-stop');\n\n        // change the button text\n        this.controlText('Stop');\n    }\n\n    /**\n     * Add the vjs-icon-record-start class to the element so it can change appearance.\n     *\n     * @param {EventTarget~Event} [event]\n     *        The event that caused this function to run.\n     *\n     * @listens Player#stopRecord\n     */\n    onStop(event) {\n        // replace element class so it can change appearance\n        this.removeClass('vjs-icon-record-stop');\n        this.addClass('vjs-icon-record-start');\n\n        // change the button text\n        this.controlText('Record');\n    }\n}\n\n/**\n * The text that should display over the `RecordToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nRecordToggle.prototype.controlText_ = 'Record';\n\nComponent.registerComponent('RecordToggle', RecordToggle);\n\nexport default RecordToggle;\n","/**\n * @file record-indicator.js\n * @since 2.0.0\n */\n\nconst Component = videojs.getComponent('Component');\n\n/**\n * Icon indicating recording is active.\n *\n * @class\n * @augments videojs.Component\n*/\nclass RecordIndicator extends Component {\n    /**\n     * The constructor function for the class.\n     *\n     * @private\n     * @param {(videojs.Player|Object)} player - Video.js player instance.\n     * @param {Object} options - Player options.\n     */\n    constructor(player, options) {\n        super(player, options);\n\n        this.enable();\n    }\n\n    /**\n     * Create the `RecordIndicator`s DOM element.\n     *\n     * @return {Element}\n     *         The dom element that gets created.\n     */\n    createEl() {\n        return super.createEl('div', {\n            className: 'vjs-record-indicator vjs-control',\n            dir: 'ltr'\n        });\n    }\n\n    /**\n     * Enable event handlers.\n     */\n    enable() {\n        this.on(this.player_, 'startRecord', this.show);\n        this.on(this.player_, 'stopRecord', this.hide);\n    }\n\n    /**\n     * Disable event handlers.\n     */\n    disable() {\n        this.off(this.player_, 'startRecord', this.show);\n        this.off(this.player_, 'stopRecord', this.hide);\n    }\n}\n\nComponent.registerComponent('RecordIndicator', RecordIndicator);\n\nexport default RecordIndicator;\n","/**\n * @file defaults.js\n * @since 2.0.0\n */\n\n// plugin defaults\nconst pluginDefaultOptions = {\n    // Single snapshot image.\n    image: false,\n    // Include audio in the recorded clip.\n    audio: false,\n    // Include video in the recorded clip.\n    video: false,\n    // Animated GIF.\n    animation: false,\n    // Screen capture.\n    screen: false,\n    // Maximum length of the recorded clip.\n    maxLength: 10,\n    // Maximum file size of the recorded clip. Works only when the timeSlice\n    // option is also enabled.\n    maxFileSize: 0,\n    // msDisplayMax indicates the number of seconds that is\n    // considered the boundary value for displaying milliseconds\n    // in the time controls. An audio clip with a total length of\n    // 2 seconds and a msDisplayMax of 3 will use the format\n    // M:SS:MMM. Clips longer than msDisplayMax will be displayed\n    // as M:SS or HH:MM:SS.\n    msDisplayMax: 3,\n    // Width of the recorded video frames.\n    frameWidth: 320,\n    // Height of the recorded video frames.\n    frameHeight: 240,\n    // Enables console logging for debugging purposes.\n    debug: false,\n    // Turn off the camera/mic (and light) when audio and/or video recording\n    // stops, and turns them on again when you resume recording.\n    autoMuteDevice: false,\n    // The mime type for the video recorder. Default to 'video/webm'.\n    // Use 'video/mp4' (Firefox) or 'video/webm;codecs=H264' (Chrome 52 and\n    // newer) for MP4.\n    videoMimeType: 'video/webm',\n    // Video recorder type to use. This allows you to specify an alternative\n    // recorder class, e.g. WhammyRecorder. Defaults to 'auto' which let's\n    // recordrtc specify the best available recorder type.\n    videoRecorderType: 'auto',\n    // Audio recording library to use. Legal values are 'recordrtc',\n    // 'libvorbis.js', 'opus-recorder', 'lamejs', 'vmsg' and 'recorder.js'.\n    audioEngine: 'recordrtc',\n    // Audio recorder type to use. This allows you to specify an alternative\n    // recorder class, e.g. StereoAudioRecorder. Defaults to 'auto' which let's\n    // recordrtc specify the best available recorder type. Currently this\n    // setting is only used with the 'recordrtc' audioEngine.\n    audioRecorderType: 'auto',\n    // The mime type for the audio recorder. Defaults to 'auto' which will pick\n    // the best option available in the browser (e.g. either 'audio/wav',\n    // 'audio/ogg' or 'audio/webm').\n    audioMimeType: 'auto',\n    // The size of the audio buffer (in sample-frames) which needs to\n    // be processed each time onprocessaudio is called.\n    // From the spec: This value controls how frequently the audioprocess event is\n    // dispatched and how many sample-frames need to be processed each call.\n    // Lower values for buffer size will result in a lower (better) latency.\n    // Higher values will be necessary to avoid audio breakup and glitches.\n    // Legal values are 256, 512, 1024, 2048, 4096, 8192 or 16384.\n    audioBufferSize: 4096,\n    // The audio sample rate (in sample-frames per second) at which the\n    // AudioContext handles audio. It is assumed that all AudioNodes\n    // in the context run at this rate. In making this assumption,\n    // sample-rate converters or \"varispeed\" processors are not supported\n    // in real-time processing.\n    // The sampleRate parameter describes the sample-rate of the\n    // linear PCM audio data in the buffer in sample-frames per second.\n    // An implementation must support sample-rates in at least\n    // the range 22050 to 96000.\n    audioSampleRate: 44100,\n    // The audio bitrate in kbps (only used in lamejs plugin).\n    audioBitRate: 128,\n    // Allows you to record single-channel audio, which can reduce the\n    // file size.\n    audioChannels: 2,\n    // URL for the audio worker.\n    audioWorkerURL: '',\n    // Enables the audioBufferUpdate event that provides realtime AudioBuffer\n    // instances from the input audio device.\n    audioBufferUpdate: false,\n    // Frame rate in frames per second.\n    animationFrameRate: 200,\n    // Sets quality of color quantization (conversion of images to the\n    // maximum 256 colors allowed by the GIF specification).\n    // Lower values (minimum = 1) produce better colors,\n    // but slow processing significantly. 10 is the default,\n    // and produces good color mapping at reasonable speeds.\n    // Values greater than 20 do not yield significant improvements\n    // in speed.\n    animationQuality: 10,\n    // Accepts numbers in milliseconds; use this to force intervals-based blobs.\n    timeSlice: 0,\n    // Media converter library to use. Legal values are 'ts-ebml' or an empty\n    // string '' to disable (default).\n    convertEngine: ''\n};\n\nexport default pluginDefaultOptions;\n","/**\n * @file format-time.js\n * @since 2.0.0\n */\n\n/**\n * Format seconds as a time string, H:MM:SS, M:SS or M:SS:MMM.\n *\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide.\n *\n * @param {number} seconds - Number of seconds to be turned into a\n *     string.\n * @param {number} guide - Number (in seconds) to model the string\n *     after.\n * @param {number} msDisplayMax - Number (in milliseconds) to model the string\n *     after.\n * @return {string} Time formatted as H:MM:SS, M:SS or M:SS:MMM, e.g.\n *     0:00:12.\n * @private\n */\nconst formatTime = function(seconds, guide, msDisplayMax) {\n    // Default to using seconds as guide\n    seconds = seconds < 0 ? 0 : seconds;\n    guide = guide || seconds;\n    let s = Math.floor(seconds % 60),\n        m = Math.floor(seconds / 60 % 60),\n        h = Math.floor(seconds / 3600),\n        gm = Math.floor(guide / 60 % 60),\n        gh = Math.floor(guide / 3600),\n        ms = Math.floor((seconds - s) * 1000);\n\n    // handle invalid times\n    if (isNaN(seconds) || seconds === Infinity) {\n        // '-' is false for all relational operators (e.g. <, >=) so this\n        // setting will add the minimum number of fields specified by the\n        // guide\n        h = m = s = ms = '-';\n    }\n\n    // Check if we need to show milliseconds\n    if (guide > 0 && guide < msDisplayMax) {\n        if (ms < 100) {\n            if (ms < 10) {\n                ms = '00' + ms;\n            } else {\n                ms = '0' + ms;\n            }\n        }\n        ms = ':' + ms;\n    } else {\n        ms = '';\n    }\n\n    // Check if we need to show hours\n    h = (h > 0 || gh > 0) ? h + ':' : '';\n\n    // If hours are showing, we may need to add a leading zero.\n    // Always show at least one digit of minutes.\n    m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';\n\n    // Check if leading zero is need for seconds\n    s = ((s < 10) ? '0' + s : s);\n\n    return h + m + s + ms;\n};\n\nexport default formatTime;\n","/**\n * @file browser-shim.js\n * @since 2.0.0\n */\n\nconst setSrcObject = function (stream, element) {\n    if ('srcObject' in element) {\n        element.srcObject = stream;\n    } else if ('mozSrcObject' in element) {\n        element.mozSrcObject = stream;\n    } else {\n        element.srcObject = stream;\n    }\n};\n\nexport default setSrcObject;\n","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * @file engine-loader.js\n * @since 3.3.0\n */\n\nimport RecordRTCEngine from './record-rtc';\nimport {CONVERT_PLUGINS, TSEBML} from './convert-engine';\nimport {RECORDRTC, LIBVORBISJS, RECORDERJS, LAMEJS, OPUSRECORDER, VMSG, AUDIO_PLUGINS} from './record-engine';\n\n/**\n * Get audio plugin engine class.\n *\n * @private\n * @param {String} audioEngine - Name of the audio engine.\n * @returns {Object} Audio engine class.\n */\nconst getAudioEngine = function(audioEngine) {\n    let AudioEngineClass;\n    switch (audioEngine) {\n        case RECORDRTC:\n            // RecordRTC.js (default)\n            AudioEngineClass = RecordRTCEngine;\n            break;\n\n        case LIBVORBISJS:\n            // libvorbis.js\n            AudioEngineClass = videojs.LibVorbisEngine;\n            break;\n\n        case RECORDERJS:\n            // recorder.js\n            AudioEngineClass = videojs.RecorderjsEngine;\n            break;\n\n        case LAMEJS:\n            // lamejs\n            AudioEngineClass = videojs.LamejsEngine;\n            break;\n\n        case OPUSRECORDER:\n            // opus-recorder\n            AudioEngineClass = videojs.OpusRecorderEngine;\n            break;\n\n        case VMSG:\n            // vmsg\n            AudioEngineClass = videojs.VmsgEngine;\n            break;\n\n        default:\n            // unknown engine\n            throw new Error('Unknown audioEngine: ' + audioEngine);\n    }\n    return AudioEngineClass;\n};\n\n/**\n * Check whether any audio record plugins are enabled.\n *\n * @private\n * @param {String} audioEngine - Name of the audio engine.\n * @returns {Boolean} Whether any audio plugins are enabled or not.\n */\nconst isAudioPluginActive = function(audioEngine) {\n    return AUDIO_PLUGINS.indexOf(audioEngine) > -1;\n};\n\n/**\n * Get converter plugin engine class.\n *\n * @private\n * @param {String} convertEngine - Name of the convert engine.\n * @returns {Object} Convert engine class.\n */\nconst getConvertEngine = function(convertEngine) {\n    let ConvertEngineClass;\n    switch (convertEngine) {\n        case '':\n            // disabled (default)\n            break;\n\n        case TSEBML:\n            // ts-ebml\n            ConvertEngineClass = videojs.TsEBMLEngine;\n            break;\n\n        default:\n            // unknown engine\n            throw new Error('Unknown convertEngine: ' + convertEngine);\n    }\n    return ConvertEngineClass;\n};\n\nexport {\n    getAudioEngine, isAudioPluginActive, getConvertEngine\n};\n","/**\n * @file record-rtc.js\n * @since 2.0.0\n */\n\nimport { RecordEngine } from './record-engine';\nimport { isChrome } from '../utils/detect-browser';\nimport {IMAGE_ONLY, AUDIO_ONLY, VIDEO_ONLY, AUDIO_VIDEO, ANIMATION, SCREEN_ONLY} from './record-mode';\n\nconst Component = videojs.getComponent('Component');\n\n/**\n * Engine used with the MRecordRTC class in the RecordRTC library.\n *\n * @class\n * @augments videojs.RecordEngine\n */\nclass RecordRTCEngine extends RecordEngine {\n\n    /**\n     * Setup recording engine.\n     *\n     * @param {LocalMediaStream} stream - Media stream to record.\n     * @param {Object} mediaType - Object describing the media type of this\n     *     engine.\n     * @param {Boolean} debug - Indicating whether or not debug messages should\n     *     be printed in the console.\n     */\n    setup(stream, mediaType, debug) {\n        this.inputStream = stream;\n        this.mediaType = mediaType;\n        this.debug = debug;\n\n        if ('screen' in this.mediaType) {\n            this.mediaType.video = true;\n        }\n\n        // setup RecordRTC\n        this.engine = new RecordRTC.MRecordRTC();\n        this.engine.mediaType = this.mediaType;\n        this.engine.disableLogs = !this.debug;\n        this.engine.mimeType = this.mimeType;\n\n        // audio settings\n        this.engine.bufferSize = this.bufferSize;\n        this.engine.sampleRate = this.sampleRate;\n        this.engine.numberOfAudioChannels = this.audioChannels;\n\n        // video/canvas settings\n        this.engine.video = this.video;\n        this.engine.canvas = this.canvas;\n\n        // animated gif settings\n        this.engine.quality = this.quality;\n        this.engine.frameRate = this.frameRate;\n        if (this.onTimeStamp !== undefined) {\n            this.engine.timeSlice = this.timeSlice;\n            this.engine.onTimeStamp = this.onTimeStamp;\n        }\n\n        // connect stream to recording engine\n        this.engine.addStream(this.inputStream);\n    }\n\n    /**\n     * Remove any temporary data and references to streams.\n     */\n    dispose() {\n        super.dispose();\n\n        if (typeof this.engine.destroy === 'function') {\n            this.engine.destroy();\n        }\n    }\n\n    /**\n     * Start recording.\n     */\n    start() {\n        this.engine.startRecording();\n    }\n\n    /**\n     * Stop recording. Result will be available async when onStopRecording\n     * is called.\n     */\n    stop() {\n        this.engine.stopRecording(this.onStopRecording.bind(this));\n    }\n\n    /**\n     * Pause recording.\n     */\n    pause() {\n        this.engine.pauseRecording();\n    }\n\n    /**\n     * Resume recording.\n     */\n    resume() {\n        this.engine.resumeRecording();\n    }\n\n    /**\n     * Show save as dialog in browser so the user can store the recorded media\n     * locally.\n     *\n     * @param {object} name - Object with names for the particular blob(s)\n     *     you want to save. File extensions are added automatically. For\n     *     example: {'video': 'name-of-video-file'}. Supported keys are\n     *     'audio', 'video' and 'gif'.\n     * @example\n     * // save video file as 'foo.webm'\n     * player.record().saveAs({'video': 'foo'});\n     */\n    saveAs(name) {\n        if (this.engine && name !== undefined) {\n            this.engine.save(name);\n        }\n    }\n\n    /**\n     * Invoked when recording is stopped and resulting stream is available.\n     *\n     * @private\n     * @param {string} audioVideoURL - Reference to the recorded Blob\n     *     object, e.g. 'blob:http://localhost:8080/10100016-4248-9949-b0d6-0bb40db56eba'\n     * @param {string} type - Media type, eg. 'video' or 'audio'.\n     */\n    onStopRecording(audioVideoURL, type) {\n        // store reference to recorded stream URL\n        this.mediaURL = audioVideoURL;\n\n        // store reference to recorded stream data\n        let recordType = this.player().record().getRecordType();\n        this.engine.getBlob((recording) => {\n            switch (recordType) {\n                case AUDIO_ONLY:\n                    if (recording.audio !== undefined) {\n                        this.recordedData = recording.audio;\n                    }\n                    break;\n\n                case VIDEO_ONLY:\n                case AUDIO_VIDEO:\n                case SCREEN_ONLY:\n                    // recordrtc returns a single blob that includes both audio\n                    // and video data\n                    if (recording.video !== undefined) {\n                        this.recordedData = recording.video;\n                    }\n                    break;\n\n                case ANIMATION:\n                    if (recording.gif !== undefined) {\n                        this.recordedData = recording.gif;\n                    }\n                    break;\n            }\n            // inject file info\n            this.addFileInfo(this.recordedData);\n\n            // notify listeners\n            this.trigger('recordComplete');\n\n        });\n    }\n}\n\n// expose plugin\nvideojs.RecordRTCEngine = RecordRTCEngine;\n\nComponent.registerComponent('RecordRTCEngine', RecordRTCEngine);\n\nexport default RecordRTCEngine;\n","/**\n * @file convert-engine.js\n * @since 3.3.0\n */\n\nimport {blobToArrayBuffer, addFileInfo} from '../utils/file-util';\n\nconst Component = videojs.getComponent('Component');\n\n// supported convert plugin engines\nconst TSEBML = 'ts-ebml';\n\n// all convert plugins\nconst CONVERT_PLUGINS = [TSEBML];\n\n/**\n * Base class for converter backends.\n * @class\n * @augments videojs.Component\n */\nclass ConvertEngine extends Component {\n    /**\n     * Creates an instance of this class.\n     *\n     * @param  {Player} player - The `Player` that this class should be\n     *     attached to.\n     * @param  {Object} [options] - The key/value store of player options.\n     */\n    constructor(player, options) {\n        // auto mixin the evented mixin (required since video.js v6.6.0)\n        options.evented = true;\n\n        super(player, options);\n    }\n\n    /**\n     * Setup recording engine.\n     *\n     * @param {Object} mediaType - Object describing the media type of this\n     *     engine.\n     * @param {Boolean} debug - Indicating whether or not debug messages should\n     *     be printed in the console.\n     */\n    setup(mediaType, debug) {\n        this.mediaType = mediaType;\n        this.debug = debug;\n    }\n\n    /**\n     * Load `Blob` and return `Promise`.\n     *\n     * @param {Blob} data - `Blob` to load.\n     * @returns {Promise} - Promise with `ArrayBuffer` data.\n     */\n    loadBlob(data) {\n        return blobToArrayBuffer(data);\n    }\n\n    /**\n     * Add filename and timestamp to converted file object.\n     *\n     * @param {(Blob|File)} fileObj - `Blob` or `File` object to modify.\n     * @param {date} [now] - Optional date information, default is\n     *    current timestamp.\n     */\n    addFileInfo(fileObj, now) {\n        addFileInfo(fileObj, now);\n    }\n}\n\n// expose component for external plugins\nvideojs.ConvertEngine = ConvertEngine;\nComponent.registerComponent('ConvertEngine', ConvertEngine);\n\nexport {\n    ConvertEngine, CONVERT_PLUGINS, TSEBML\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__20__;"],"sourceRoot":""}