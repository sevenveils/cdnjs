{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap a5c7baf647b9c90dec0a","webpack:///./dist/pts.js"],"names":[],"mappings":";;;;;AAAA,cACA,2BACA,uCACA,sCACA,WACA,MACA,qCAEA,UACA,GAAC,mBACD,kBCTA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,OAzBA,YA4BA,MAGA,mBAA2C,CAAc,QAGzD,qBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,2BC5DA,CACA,cAEA,WAOA,GAAC,qDAyzBD,YAFA,mBAFA,sDA7oBA,qCAvKA,kBAEA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,OAzBA,YA4BA,MAGA,mBAAmD,CAAc,QAGjE,qBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAAmC,UAA0B,UAC7D,YAAyC,CAAe,QACxD,EAEA,aADA,QAIA,mBAA8D,wCAA+D,SAG7H,MAGA,SACA,GAEA,EAEA,iBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,UACA,cAIA,aACA,6BAQA,kBACA,eACA,8BAGA,0CAEA,GACA,wBACA,aAEA,eAEA,QADA,0BAC2C,OAAS,IACpD,eAGA,eACA,SACA,SAAc,aAAiB,GAC/B,UAAe,MAAc,KAC7B,QAAa,aAAgB,EAC7B,QAAa,aAAgB,EAC7B,QAAa,aAAgB,EAC7B,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,SAAc,MAAa,IAC3B,SAAc,MAAa,IAC3B,SAAc,MAAa,IAI3B,QACA,cACA,KAMA,iBACA,oBAA0C,OAAS,IACnD,iBACA,QAEA,SACA,QAKA,SACA,cACA,yCAA8D,QAAS,IACvE,YAEA,WACA,KAKA,UACA,wBACA,KAOA,kBACA,sBACA,0DAEA,KAOA,MACA,OACA,YACA,WAEA,KAOA,OACA,OACA,mBAAyC,OAAS,IAClD,mBAEA,OACA,QAKA,SACA,OACA,mBAA0C,OAAS,IACnD,uBAEA,SACA,SAKA,cACA,2CACA,YAKA,UACA,uFACA,YACA,IAIA,WAAmB,yBAAkC,KAKrD,eACA,iGACA,YACA,IAIA,gBAAwB,8BAAuC,KAK/D,eACA,iGACA,YACA,IAIA,gBAAwB,8BAAuC,KAK/D,aACA,6FACA,YACA,IAIA,cAAsB,4BAAqC,KAI3D,cAAmB,uBAA4C,KAI/D,YAAiB,wBAA4C,KAK7D,eACA,mBACA,QACA,IAIA,gBAAkC,qBAAqC,OAKvE,UAAkB,8BAAiE,WAKnF,cAAsB,kCAAqE,WAK3F,aAAqB,gCAAmE,WAKxF,YACA,SACA,mBACA,YACA,eACA,yBACA,IAIA,MACA,kBACA,MACA,IAIA,OACA,qBACA,KAIA,QACA,oBACA,MACA,IAIA,SACA,qBACA,OAIA,OACA,mBACA,MACA,IAIA,QACA,qBACA,MAIA,QACA,oBACA,MACA,IAIA,SACA,qBACA,OAKA,WACA,kBACA,KAKA,WACA,kBACA,KAKA,WACA,cACA,kBACA,sCAA8D,QAAS,IACvE,mBAEA,MACA,QAKA,WACA,cACA,kBACA,sCAA8D,QAAS,IACvE,mBAEA,MACA,QAKA,oBACA,4BACA,IAMA,6BACA,+DACA,SAMA,WACA,kDACA,IACA,IAOA,gBACA,qDACA,MACA,IAOA,eACA,oDACA,MACA,IAMA,eACA,yBACA,UACA,IAIA,WACA,aAAqB,eACrB,GAIA,UACA,qBACA,KACA,EACA,EAIA,KACA,qBACA,kBACA,OACA,KACA,SAAc,aAAiB,GAC/B,UAAe,MAAc,KAE7B,SAAc,aAAgB,EAE9B,SAAc,aAAgB,EAE9B,SAAc,aAAgB,EAE9B,SAAc,aAAgB,EAE9B,SAAc,yBAA8B,EAE5C,SAAc,yBAA8B,EAE5C,SAAc,yBAA8B,EAE5C,SAAc,yBAA8B,EAI5C,QACA,OACA,yBAA0C,OAAS,IACnD,mBAEA,SACA,QAMA,oBACA,OACA,wBAA0C,OAAS,IACnD,kCACA,QAEA,QACA,QAKA,sBACA,UACA,OAOA,gBACA,oBACA,YACA,QAMA,cACA,2CACA,OACA,IAOA,gBACA,sBACA,sCACA,OAOA,uBACA,aACA,YAIA,QAAa,wBAA4B,EAIzC,WACA,wBACA,KAKA,cACA,2BACA,KAKA,cAA6B,sBAA0C,KAKvE,gBAA+B,sBAA4C,OAO3E,MACA,OACA,YACA,WAEA,KAOA,OACA,OACA,mBAAyC,OAAS,IAClD,mBAEA,OACA,QAKA,eACA,mBACA,qBACA,mBACA,OACA,qEACA,OAKA,aACA,iBACA,KAKA,aACA,8CACA,gBACA,UACA,IAMA,WACA,oBAA0C,OAAS,IACnD,mCAEA,UACA,KAOA,gBACA,oBAA0C,OAAS,IACnD,sCAEA,YACA,KAOA,eACA,oBAA0C,OAAS,IACnD,qCAEA,YACA,KAMA,eACA,oBAA0C,OAAS,IACnD,qBAEA,mBACA,KAMA,wBACA,0CACA,KAMA,kBACA,UACA,yBAAgC,IAChC,4BAEA,wBAA0C,OAAS,IACnD,uBAEA,YACA,KAKA,UACA,6BACA,KAKA,eACA,kCACA,KAKA,eACA,kCACA,KAKA,aACA,gCACA,KAMA,cACA,kBACA,OAQA,6BACA,uBACA,WAMA,iBACA,uBACA,SAMA,oBACA,kBACA,SAIA,WACA,2DACA,IACA,EACA,EAGA,OAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UAGA,GACA,QACA,IACA,QACA,QACA,SACA,iBACA,WAEA,YAEA,QAEA,eAEA,SAEA,cAEA,OAEA,WAEA,MAEA,YAEA,UAEA,6BAQA,0BAEA,8BAEA,6BAEA,+BAEA,6BAEA,4BAEA,YAEA,gBAIA,mBACA,OAKA,kBACA,IACA,iBACA,SACA,+CAEA,OACA,8CAGA,0CACA,oBACA,SACA,aAA2B,MAAc,mCAGzC,WAFA,aAKA,MAEA,4BAEA,KACA,QAMA,gCACA,IACA,8BAEA,cACA,6BAEA,QACA,QACA,wBACA,eACA,aAQA,yBACA,OACA,OACA,aAAuB,MAAgB,OACvC,iBACA,2BAaA,kBAZA,eACA,2BACA,aACA,OAEA,KAIA,OAIA,QAMA,uBACA,eACA,yBACA,UAOA,sBACA,OACA,mBAAuC,OAAS,IAChD,oBAA4C,OAAU,IACtD,kBAGA,OACA,QAKA,iBACA,OACA,wBAA+C,OAAS,QACxD,GACA,aAA2B,MAAmB,OAC9C,WAEA,WACA,OACA,CACA,QAUA,4BACA,IACA,sBACA,CAOA,MANA,MACA,YAGA,SACA,MAEA,CAOA,6BACA,OACA,UAAwC,KAAS,IACjD,UAEA,KACA,QACA,EACA,sBACA,EAGA,MAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OACA,UACA,oCACA,6DAAsE,UAKtE,+BACA,OAQA,wBACA,qCACA,OAEA,YADA,iBAOA,kBACA,gDACA,GAOA,sBACA,IACA,aAEA,WACA,2BACA,eACA,SAAoB,6BACpB,KACA,CAOA,uBACA,qEACA,GAQA,8BAEA,6BACA,qCACA,gEACA,KAKA,oBACA,qDACA,CAKA,sBACA,uDACA,CAQA,qCACA,mBAEA,4BACA,WACA,6BACA,0BACA,QAOA,2BACA,sCACA,WAOA,2BACA,0BACA,yBACA,QACA,OACA,gBACA,IACA,UAEA,oCACA,qBACA,KAGA,cACA,8BACA,qBACA,KACA,qBACA,wDACA,4BACA,gBACA,OAEA,gBACA,mBAOA,UAOA,4BACA,SACA,2FACA,YAOA,mCACA,SACA,0DACA,YAOA,oCACA,oCACA,wBACA,wBAA0C,OAAS,IACnD,QAEA,aAEA,cACA,oBAOA,mCACA,6DACA,qBACA,MAKA,YAJA,gCACA,UACA,gCACA,MAQA,oCACA,SACA,oCACA,sBAAuC,OAAS,IAChD,mCACA,YAEA,MACA,QAOA,4BACA,4BACA,YAMA,sBACA,aACA,gBAAuB,EAAU,KACjC,6CAEA,KACA,QASA,0BACA,eACA,mBACA,mBACA,eACA,WACA,2BACA,gBACA,OACA,KACA,oBACA,YACA,WACA,iCACA,aAGA,WAEA,mBACA,OACA,CASA,kCACA,WACA,QACA,mBACA,SACA,iCACA,QACA,wDACA,YACA,gCACA,6BAGA,wBAEA,GAKA,iBACA,gDACA,IACA,EACA,EAKA,OACA,OAIA,mBACA,UACA,kBAOA,0BACA,6BACA,mDACA,OAOA,yBACA,4DACA,0DACA,OAMA,mBACA,UACA,WAMA,wBACA,SACA,4CACA,4BACA,cAKA,eACA,6CACA,IAKA,iBACA,mBACA,kBACA,uCACA,GAKA,kBACA,mBACA,kBACA,4DACA,GAMA,gBACA,gBACA,iBACA,wBACA,kCAEA,WAIA,gBACA,UACA,QAMA,sBACA,cACA,mCACA,gCAEA,2BAA4C,OAAS,IACrD,cAA2B,EAAO,IAClC,gBACA,qBAGA,sBACA,UAKA,kBACA,UACA,UAMA,sBACA,SACA,yBACA,yDACA,cAQA,2BACA,mBACA,kBACA,kDACA,YACA,2DACA,oEACA,OAMA,wBACA,oCACA,GAMA,+BACA,SACA,2BAAyC,OAAS,IAClD,sCACA,IAEA,SACA,QAOA,4BACA,kDACA,UACA,EACA,EAKA,YACA,OAMA,wBACA,OACA,iCACA,OACA,kCACA,UACA,IAEA,KAEA,0CACA,QAMA,uBACA,sCACA,QAOA,4BACA,YACA,2CACA,CAOA,2BACA,wBACA,uBACA,QACA,WACA,8BACA,IACA,MAEA,IADA,OAEA,iBAEA,UACA,OACA,wBAEA,UADA,UAEA,kBACA,gCAEA,UADA,oBAEA,UACA,CAOA,4BACA,SACA,4BACA,SACA,2BAA4C,OAAS,IACrD,oBACA,cAGA,MACA,QAOA,8BACA,wBACA,QACA,gBACA,YACA,SACA,IACA,SAEA,iBAEA,aACA,6BAEA,aACA,UAPA,QAQA,WACA,8BACA,sFACA,KACA,CAQA,4BACA,SACA,WACA,qBAA2C,OAAS,IACpD,0BACA,MACA,cAEA,sBACA,UAKA,iBACA,YACA,6CACA,QAKA,sBACA,YACA,YACA,4CACA,QAKA,0BACA,UACA,UAEA,gBAAuB,EAAO,IAC9B,uCACA,QAEA,OALA,EAMA,QACA,EACA,EAKA,SACA,OAKA,mBACA,8BACA,YACA,cACA,wBACA,sBACA,UAKA,qBACA,UACA,kBAMA,uBACA,uBACA,gBAMA,iBACA,OACA,0BACA,KACA,eAOA,yBACA,OACA,0BACA,GACA,kCAEA,KACA,kCAGA,iCAEA,IAOA,qBACA,SACA,wBACA,qDAGA,aAEA,KAMA,sBACA,IACA,2BACA,sBACA,kBACA,YACA,mBAMA,mBACA,IACA,2BACA,+BACA,4BACA,8DACA,MAMA,qBACA,aACA,gBACA,YACA,wBACA,eACA,eAMA,uBACA,SACA,uEACA,kEACA,cACA,mBAMA,yBACA,aACA,oCACA,qBACA,eACA,EACA,EAKA,WACA,OAKA,mBACA,eACA,WAOA,qBACA,IACA,gCACA,0BAEA,gDACA,WACA,OAOA,8BACA,IACA,gCACA,WACA,kDACA,OACA,QAOA,+BACA,IACA,gCACA,gBACA,sBACA,eACA,OACA,KACA,iBACA,GACA,8BACA,eACA,EAKA,qBAJA,MACA,eACA,2BACA,QASA,qBACA,SACA,qCACA,kCACA,oCACA,8BACA,EAIA,CAOA,yBACA,IACA,gCACA,WACA,aACA,uBACA,qBAA2C,OAAS,IACpD,kBACA,MACA,KAEA,aACA,CACA,QAEA,WAKA,eACA,IACA,gCAEA,iCACA,KACA,kBAAyC,OAAS,IAClD,kBACA,aAGA,aAGA,eACA,EAQA,0BACA,IACA,gCAEA,WACA,6BAGA,WACA,SAGA,oDACA,cACA,MACA,SACA,UAEA,iBACA,cACA,YAGA,cACA,YAGA,sBAAyC,OAAS,IAClD,SAEA,kCAIA,2BACA,UAEA,SACA,EAEA,iBACA,YAEA,KACA,EAEA,mBACA,gBAAuB,IAAiB,IACxC,aAEA,MACA,QAOA,6BACA,OACA,qBAAiD,OAAS,IAC1D,2BAEA,eAEA,QACA,QAMA,sBACA,OACA,mBAAyC,OAAS,IAClD,IACA,8BAEA,OACA,QAOA,sBACA,IACA,QACA,oBAAyC,OAAS,IAClD,wBACA,cACA,MACA,IAGA,KACA,QAKA,kBACA,yBACA,yBACA,cAEA,wBADA,iBAEA,EACA,EAKA,UACA,OAKA,mBACA,aACA,kBAAuB,EAAY,KACnC,MACA,gCAEA,IACA,QAQA,iCACA,eACA,eACA,yCACA,IACA,oBAEA,wCACA,MAMA,oBACA,oCACA,kCACA,oBACA,oCACA,gBACA,SACA,cACA,OAOA,0BACA,IACA,wBACA,kBACA,UAEA,gCACA,gBAAuB,EAAY,KACnC,4BAEA,mBACA,gBACA,SACA,iCACA,WAA+B,EAAY,KAC3C,4BAEA,SACA,GACA,CACA,CACA,QAOA,2BAQA,wGACA,gDACA,GAQA,6BACA,IACA,wBACA,kBACA,UAEA,gCACA,gBAAuB,EAAY,KACnC,0BAEA,qBACA,gBACA,SACA,iCACA,WAA+B,EAAY,KAC3C,0BAEA,WACA,GACA,CACA,CACA,QAQA,8BAQA,6FACA,kCACA,4BACA,gBACA,OACA,aAKA,4BAJA,uBACA,EACA,kCACA,IAQA,sBACA,IACA,wBACA,kBACA,UACA,cACA,qBACA,SACA,iCACA,WAA+B,EAAY,KAC3C,wBAGA,YACA,CACA,CACA,CACA,QAOA,uBAQA,4FACA,gDACA,GAQA,2BACA,IACA,wBACA,kBACA,UACA,cACA,qBACA,SACA,iCACA,IACA,gBAAmC,EAAY,KAC/C,gCAIA,0BAAmC,EAAY,KAC/C,yBAGA,SACA,GACA,CACA,CACA,QAOA,wBAQA,sLACA,gDACA,GAQA,mCAQA,0LACA,kCACA,4BACA,gBACA,OACA,aAKA,4BAJA,uBACA,EACA,kCACA,IAEA,EACA,EAGA,OAEA,kBAKA,4BACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OACA,OAGA,GACA,OAOA,0BACA,UACA,MAOA,mBACA,eACA,GAOA,oBACA,YACA,OAQA,yBACA,SACA,OACA,IAKA,MAJA,KACA,KACA,MACA,OAQA,qBACA,sBACA,MAMA,0BACA,eACA,kBACA,UAOA,6BACA,OACA,SACA,oBACA,IAMA,cACA,kBACA,oBAAyC,OAAS,IAClD,gBAEA,MACA,QAMA,kBACA,0BACA,OAMA,gBACA,oBACA,CAUA,6BACA,IACA,qBACA,iEACA,SACA,uCACA,MACA,EACA,EAGA,MACA,OAIA,qBACA,yBACA,IAIA,sBACA,iCACA,OAIA,mBACA,kBACA,UAIA,mBACA,kBACA,UAMA,sBACA,yBACA,6BACA,sBACA,UAMA,mBACA,UACA,UAOA,4BACA,0BACA,sBAAyC,OAAS,IAClD,IACA,mBACA,eAGA,MAGA,UAQA,6BACA,oBACA,eACA,kBAAuB,EAAS,IAChC,oBAEA,OACA,QAMA,qCACA,SACA,OACA,WACA,cACA,YACA,UACA,iBACA,kBACA,WACA,WACA,UAIA,4BACA,OACA,uBAOA,0BACA,qCAAoF,QAAS,IAC7F,2BACA,MAEA,SACA,QAMA,oBACA,SACA,uCACA,YAyBA,YAxBA,gBACA,2BACA,8CACA,iBACA,yBACA,aACA,cACA,eACA,cACA,wBACA,qBACA,eAGA,UACA,iBACA,KACA,EACA,KAGA,6CACA,CACA,EAQA,oBACA,0BACA,wCAEA,wCACA,sBAAyC,OAAS,QAClD,GACA,qBAA4C,OAAU,IACtD,4CAEA,IACA,CACA,QAQA,yBACA,0BACA,qCAEA,2CACA,UACA,OACA,uBAAyC,OAAS,IAClD,sBACA,8BAEA,WACA,QAQA,wBACA,yCACA,yBAEA,oCACA,wCACA,oBACA,UACA,sBAAyC,OAAS,IAClD,sBACA,8BAEA,WACA,QAOA,wBACA,0BACA,sBAAyC,OAAS,IAClD,sBACA,6DAEA,MACA,QAKA,kBACA,wBACA,eAAuB,EAAS,MAChC,eACA,WACgB,SAChB,4BADA,eAMA,kBACA,wBACA,eAAuB,EAAS,MAChC,eACA,WACgB,SAChB,4BADA,eAEA,EACA,EAGA,OACA,OAMA,qBACA,OACA,IAMA,0BACA,OACA,MAMA,2BACA,eACA,EAMA,6BACA,OACA,8CACA,EAMA,sBACA,OACA,QAMA,uBACA,SACA,kBACA,EAMA,yBACA,OACA,iDACA,EAOA,kCACA,cACA,IAOA,mCACA,UACA,MAMA,qBACA,sBACA,UAMA,sBACA,sBACA,QAMA,wBACA,oBACA,EAMA,2BACA,OACA,MACA,iBACA,mBACA,EAMA,yBACA,oBACA,EAMA,0BACA,SACA,eACA,IAMA,4BACA,OACA,wDACA,EAOA,6BACA,SACA,IACA,2EACA,UAOA,8BACA,OACA,2EACA,YAOA,gCACA,OACA,MACA,4CACA,UACA,oCAGA,iBACA,oCAEA,cAMA,uBACA,sBACA,MAMA,wBACA,YACA,QAEA,gBACA,aACA,mBAEA,YACA,cACA,mBAGA,kBACA,mBAEA,SAMA,0BACA,0DACA,CAOA,2BACA,eAEA,OADA,MAQA,8BACA,iCACA,iBACA,mBACA,sBACA,eACA,qBACA,IAOA,wBACA,OACA,mBAGA,sBAEA,EAOA,0CACA,8BACA,wBACA,YACA,IACA,kBAEA,sBACA,kCACA,MAQA,8CACA,oEACA,kFACA,CAOA,yCACA,+CACA,iBACA,mBACA,mBAGA,cAFA,SACA,IAQA,yBACA,cACA,CASA,0BACA,OACA,QACA,oBACA,KACA,EACA,EAIA,UACA,OAKA,eACA,YACA,uBACA,oBACA,MAIA,UAAe,kBAA0B,OAIzC,UAAe,kBAA0B,OAIzC,gBAAqB,kBAA0B,OAK/C,OACA,SAEA,+BACA,YACA,oBACA,cACA,cACA,gBAAuB,EAAU,QACjC,cACA,iBACA,SACA,qBACA,4BAA2C,OAAS,IACpD,gBACA,kBACA,gBAEA,IACA,aACA,YACA,YACA,OACA,KAOA,aACA,aACA,iCAAkD,OAAS,QAC3D,YACA,2BACA,iBAA2B,SAAgB,MAC3C,0DAEA,eACA,OACA,CACA,QAMA,eACA,uBACA,iDAAuD,UAAW,4BAA2B,WAC7F,6DAEA,kBACA,OACA,IAKA,SACA,aACA,kBAAuB,EAAY,SACnC,iBACA,+BAAmD,OAAS,IAC5D,0CAEA,OACA,OACA,CACA,QACA,EACA,EAGA,OAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OAGA,GACA,OAKA,gBACA,IACA,mCAA2C,OAAS,IACpD,IAGA,6BAA2C,OAAS,IACpD,gBAEA,EACA,QAKA,qBACA,IACA,mCAA2C,OAAS,IACpD,IAGA,6BAA2C,OAAS,IACpD,gBAEA,EACA,QAKA,qBACA,IACA,mCAA2C,OAAS,IACpD,IAEA,YACA,gBACA,+FAAwG,YAAa,kBAAiB,YAEtI,oBAA2C,OAAS,IACpD,UACA,IACA,CACA,QAKA,mBACA,uBACA,IACA,sBACA,yCAA2C,OAAS,IACpD,IACA,OACA,KACA,gBACA,6FAAsG,YAAa,cAAa,YAEhI,oBAA2C,OAAS,IACpD,UACA,IACA,CACA,QAIA,gBACA,gBACA,uBACA,oCACA,kBAAuC,OAAS,IAChD,YAEA,KACA,QAIA,oBACA,yBACA,EAIA,kBACA,0EACA,GAIA,oBACA,YACA,SAIA,wBACA,oBACA,kBACA,sBACA,gEACA,WAKA,cACA,qBACA,IAKA,gBACA,qBACA,MAKA,eACA,qBACA,KAKA,gBACA,qBACA,MAKA,cACA,IACA,OACA,kBAAuC,OAAS,IAChD,UACA,UACA,OAEA,WAAgB,SAChB,QAKA,cACA,IACA,OACA,kBAAuC,OAAS,IAChD,UACA,UACA,OAEA,WAAgB,SAChB,QAIA,cACA,OACA,kBAAuC,OAAS,IAChD,OACA,KACA,QAKA,gBACA,iBAAuC,OAAS,IAChD,WAEA,UACA,QACA,EACA,EAGA,MACA,OAOA,gBACA,uBACA,sBACA,uBACA,+EACA,uBACA,+DACA,aACA,sBACuC,OAAS,IAChD,qBADA,qBAGA,OACA,QASA,+BACA,aACA,WACA,oCAwB6C,OAAW,IACxD,gBAGA,wBA3BA,gBACA,uBACA,kGAAiD,OAAW,IAC5D,0BAEA,MACA,KACA,uBACA,uBACA,wGACA,uBAEA,+FACA,gCAAiD,OAAW,QAC5D,sBACA,mBAAqD,OAAW,IAChE,oBAEA,QACA,OACA,CAGA,CAKA,QAOA,0BACA,OACA,mBAAuC,OAAS,QAChD,qBACA,YAA+B,UAC/B,2BACA,WACA,cACA,KAOA,wBACA,aACA,gDACA,iBAAuB,EAAS,IAChC,aAEA,iBACA,QAIA,8BACA,UACA,UAOA,wBACA,sCACA,oCACA,gBACA,OAIA,0BACA,iEACA,GAIA,2BACA,kEACA,GAIA,0BACA,iEACA,GAIA,8BACA,iEACA,GAIA,8BACA,SACA,mBAGA,yBAFA,qBACA,IAKA,+BACA,SACA,oBAGA,4BAFA,0BACA,MAKA,8BACA,SACA,mBAGA,kBAFA,gBACA,MAOA,8BACA,cACA,kBACA,gBACA,gBACA,kBACA,0BAGA,SACA,SACA,KACA,uBACA,OACA,WACA,eACA,mBACA,yBAEA,IACA,CACA,EACA,EAGA,KAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UAIA,GACA,uBAKA,kBACA,OACA,yBACA,oBACA,uBACA,2BACA,QACA,gBACA,MAMA,2BACA,wEACA,IAGA,kBAFA,mCACA,UAEA,oBACA,IACA,2BACA,2FACA,GAIA,OACA,SACA,wBACA,aAEA,6BACA,YACA,UACA,kBACA,4BACA,aACA,mBACA,UACA,CAIA,QACA,sDACA,QAIA,cACA,uDACA,WACA,eAIA,gBACA,gDACA,SAIA,oBACA,2CACA,YACA,eAIA,uBACA,gDACA,YACA,eAIA,uBACA,4BACA,+BACA,4CACA,OACA,WAAgB,sBAAgC,MAChD,YACA,kBACA,WACA,mBACA,aAAkB,sBAAkC,QACpD,cACA,oBACA,WACA,sBACA,cAAmB,sBAAmC,SACtD,eACA,qBACA,mBACA,cACA,aACA,kBAAuB,sBAAuC,aAC9D,mBACA,yBACA,mBACA,kBACA,aACA,YAAiB,yCAAmD,CACpE,aACA,YACA,SACA,mBACA,aAAkB,yCAAmD,CACrE,cACA,YACA,SACA,mBACA,YAAiB,yCAAmD,CACpE,aACA,YACA,SACA,mBACA,QAAa,qBAAuB,CACpC,QAAa,qBAAuB,CACpC,QAAa,qBAAuB,CACpC,aAAkB,aAAqB,OAKvC,SACA,2BACA,0BACA,QACA,cACA,IACA,EACA,EAGA,OAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UAGA,GACA,OACA,cACA,MACA,SAIA,YAAiB,aAAoB,MAKrC,yBACA,WACA,wBAIA,4CACA,EACA,EAIA,OACA,iBACA,cACA,UACA,gBACA,gBACA,gCACA,aACA,aAAkB,aAAqB,OACvC,cAAmB,MAAkB,SACrC,cAAmB,aAAsB,QACzC,eAAoB,MAAmB,UACvC,kBAAuB,aAAmB,KAC1C,oBACA,IACA,SACA,sBAA4C,OAAS,IACrD,iBAEA,YACA,KAIA,OACA,OACA,KAMA,YACA,aACA,gBACA,OAIA,SACA,OACA,KAMA,oBACA,aACA,cACA,eAOA,cACA,CAEA,sBAAyC,OAAS,IAClD,eAEA,gBACA,MAKA,WACA,yBACA,SAKA,WACA,yBACA,SAKA,SACA,yBACA,OAKA,YACA,yBACA,UAKA,SACA,yBACA,OACA,EACA,EAGA,aACA,OAUA,iDACA,MACA,YACA,YACA,aACA,cACA,YAIA,YAAiB,UAAW,UAAW,IAAG,WAAY,IAAG,SAAU,MAAK,eAAgB,IAAG,SAAY,EAIvG,WAAgB,aAAmB,KACnC,EACA,EAGA,MAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OAIA,IACA,OACA,cACA,SACA,yBACA,iBAAsB,oBACtB,gBACA,oBACA,gBACA,OACA,eACA,oCACA,QACA,iBACA,WAKA,WACA,aACA,WACA,IAUA,OACA,4BAAiD,CACjD,oBACA,qBACA,iBACA,eACA,iCACA,sBAEA,qBACA,gBACA,aACA,IAKA,UACA,8BACA,WACA,IAIA,YACA,qBACA,GACA,IAMA,UACA,sDACA,YACA,aACA,mCACA,gBACA,UACA,MACA,YACA,SACA,CAGA,gCAFA,cACA,aAEA,OACA,KAKA,SACA,iBACA,OACA,MAKA,aACA,SAEA,iBACA,eAEA,aACA,2BACA,wBACA,mDAIA,sCACA,gCACA,cAEA,YAKA,YACA,8BACA,OACA,IAIA,SACA,aACA,UACA,IAKA,UACA,mBACA,MACA,IAKA,gBACA,aACA,YACA,QACA,IAKA,UACA,aACA,gCACA,MACA,IAIA,uBAA4B,MAAsB,aAClD,sBAA2B,aAAyB,WAIpD,gBAAqB,aAAsB,QAI3C,iBAAsB,mBAA2B,OAIjD,iBAAsB,4DAAgF,QAItG,WAAgB,wBAAgC,OAIhD,aAAkB,yBAA4B,EAI9C,YAAiB,mBAAyB,KAI1C,aAAkB,mBAA0B,MAC5C,EACA,UACA,iBACA,cACA,UAEA,gBACA,iBACA,iBACA,kBACA,YAIA,cACA,qBACA,QAEA,0BADA,IAOA,gBACA,cACA,qBAMA,kBACA,cACA,wBAMA,gBAEA,4DACA,oDACA,wDACA,sDACA,wDACA,YAGA,kEACA,sDACA,0DACA,wDACA,0DACA,YAEA,cACA,IAMA,gBAEA,6DACA,qDACA,wDACA,yDACA,YAGA,mEACA,uDACA,0DACA,2DACA,YAEA,cACA,IAOA,+BACA,SACA,WACA,SACA,aAAuB,SAAuB,WAC9C,YACA,gFACA,GACA,CACA,QAMA,kBACA,WACA,iBACA,+BACA,0CACA,YACA,qCACA,4BACA,IACA,UACA,eAIA,yBACA,0CACA,YACA,+BACA,kDACA,iCACA,gCACA,IACA,UACA,eAIA,mBACA,sBAEA,KAKA,cACA,CAGA,4CAFA,aACA,cAMA,YACA,CAMA,4CALA,WACA,+CACA,aACA,iBACA,cAMA,cACA,CAMA,4CALA,aACA,gBACA,iDAEA,WAMA,cACA,CAEA,4CADA,UAMA,aACA,CAKA,4CAJA,YACA,+CACA,aACA,cAMA,cACA,CAGA,YAFA,gBACA,mBAEA,EACA,EAGA,iBAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OACA,OACA,OAGA,GACA,iCAOA,iBACA,CACA,gBACA,gBACA,6BACA,oBACA,SACA,KACA,aAEA,kBACA,UACA,YAGA,kCACA,iBACA,sBAIA,YAQA,4BAGA,sDAVA,oDACA,gDACA,wCACA,YAGA,0CAKA,GAOA,kCACA,gBAEA,iBAIA,yBAHA,aACA,eACA,gBAMA,UACA,UACA,+CAAgD,OAChD,8BACA,gCACA,sBACA,+CACA,eACA,qBACA,mCACA,gDAGA,yBACA,YAEA,iCACA,QAQA,SACA,UACA,0BAEA,6CACA,OACA,IAIA,UACA,OACA,KAKA,kBACA,MAEA,0EAGA,oBACA,uBACA,yEAEA,OACA,iBAAsB,aAAyB,WAM/C,YACA,mBACA,oBAAqB,UAAW,OAAQ,eAAgB,QACxD,eACA,0CACA,YACA,aACA,sBACA,QAGA,OACA,KAKA,kBACA,gDACA,8BACA,wBAAyB,qBAGzB,wBAAyB,UAAW,OAAQ,eAAgB,QAE5D,eACA,WAIA,cACA,aACA,OAIA,aACA,aACA,UAIA,YAAiB,aAAsB,QAKvC,SAEA,iBACA,qCACA,GACA,IAKA,kBACA,MACA,sDACA,QACA,iBAAsB,aAAsB,QAO5C,gBACA,aAEA,2BACA,YACA,IAOA,eACA,QACA,UACA,gCAEA,cACA,KAOA,oBACA,QACA,UACA,oCAGA,MACA,QAOA,0BACA,OACA,UACA,UACA,mBACA,UAA8B,IAAE,KAAI,IAGpC,MACA,QACA,EACA,EAGA,WACA,iBAKA,UACA,cACA,KAQA,+BACA,WACA,4BACA,kEAA8C,KAE9C,IAOA,sBANA,gCAEA,0DACA,SAEA,iBAMA,UACA,8CACA,kCACA,cACA,cACA,SACA,SAIA,YACA,kCACA,SACA,WACA,EACA,EAGA,YACA,4BACA,eACA,CACA,kBACA,OACA,aACA,iBACA,YACA,oBACA,SACA,CACA,UACA,sBACA,sBACA,aACA,sBACA,sBACA,mBACA,iBACA,eACA,OACA,QACA,SAEA,QACA,2BACA,cAEA,mBACA,eACA,yBAAyB,WACzB,6BACA,uCACA,eACA,SACA,GACA,YAAiB,aAAoB,MAOrC,kBACA,cACA,kCAA+B,IAC/B,oDAAgC,IAAI,IACpC,EAMA,QACA,OACA,kCACA,YACA,8BAGA,8BACA,0BAEA,iBACA,IASA,YACA,OACA,kCACA,aACA,gCAGA,kBACA,2BACA,qDAEA,OACA,IAMA,YACA,qBACA,WACA,IAMA,OACA,+BACA,oBAKA,KACA,IAUA,gBACA,OACA,+BAEA,sBAEA,uBAEA,yBAEA,wBACA,wCAGA,YAEA,QACA,IAIA,QACA,wBACA,WACA,4CACA,sBAEA,gCACA,wCACA,MACA,IAOA,iBACA,kBACA,kBACA,+BACA,OACA,cACA,IAMA,SACA,QACA,kCACA,8FACA,QAKA,SACA,kBACA,oCAAiC,iBAAkB,IAAG,oBACtD,aACA,SAKA,gBACA,0BAAqC,SACrC,EAKA,kBACA,eAAuB,WACvB,EAQA,kBACA,OACA,UAKA,KAJA,kBACA,oBACA,kBACA,oEAEA,OACA,KACA,mBACA,4BAEA,6BACA,8BAGA,qBAAmC,IAAM,MAGzC,GAEA,oBAAwC,cACxC,MAQA,wBACA,CAKA,yBAJA,sBACA,wBACA,yBACA,MAUA,iCACA,OACA,eAGA,gBAEA,aAQA,wBACA,aACA,SACA,0CACA,qBACA,YACA,IAOA,wBACA,qCACA,UAIA,mBAJiC,8BAA+B,cAChE,yDACA,kBACA,QAOA,UACA,aACA,sCACA,qCACA,IACA,IAOA,qBACA,qCACA,UAIA,mBAJiC,8BAA+B,cAChE,yDACA,kBACA,QAOA,YACA,aACA,uBACA,UACA,IAMA,iBACA,SAEA,mDACA,UAIA,mBAJiC,4BAA6B,cAC9D,0BACA,gBACA,SAMA,QACA,aACA,sCACA,iBACA,QACA,IAQA,mBACA,qCACA,UASA,mBARA,UACA,sCAAwC,cACxC,UACA,SAEA,OACA,0BACA,QAQA,UACA,aACA,qBACA,UACA,IAKA,OACA,qDACA,OACA,IAIA,MACA,oBACA,sCACA,IAIA,OACA,oBACA,uCACA,IAKA,UACA,oBACA,0CACA,IACA,EACA,YACA,UACA,EAGA,UAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,GA8CA,EAGA,WAhDA,KAQA,4DACA,SACA,qBACA,oBACA,QAQA,4BACA,yBACA,uBACA,kBACA,kBAGA,gBAEA,OAOA,4BACA,oBACA,qBAEA,qBACA,YAFA,IAGA,EACA,CACA,EAMA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OACA,OACA,OACA,OACA,OAIA,GACA,iCAOA,iBACA,CACA,yBACA,OACA,6BACA,eACA,mBACA,wBACA,KACA,aAEA,iBACA,UACA,YAIA,kCACA,iBACA,UAIA,QAQA,yCAQA,4BACA,mBAQA,sBAhBA,+DACA,4CACA,cAIA,sEAdA,6DACA,qCACA,wCACA,YAGA,0CAoBA,uCACA,KAMA,0BACA,gBACA,iBAEA,sBADA,SAMA,UACA,UACA,+CAAgD,OAChD,8BACA,gCACA,sBACA,+CACA,eACA,qBACA,mCACA,gDAGA,yBACA,YAEA,uCACA,QAUA,SACA,MACA,0BACA,6CACA,qBACA,gCACA,0LACA,mBACA,GACA,UACA,gBACA,mEACA,sDAGA,YAEA,cACA,IAKA,kBACA,MAEA,0EAGA,oEAEA,MACA,iBAAsB,aAAyB,WAM/C,YACA,mBACA,kDACA,uDACA,0DACA,oDACA,UACA,0DACA,0DAIA,aACA,4DACA,oCACA,SACA,sDACA,uCAGA,WACA,0CACA,YACA,aACA,sBACA,QAGA,yBAEA,eACA,yBACA,GACA,IAKA,kBACA,kGACA,6BACA,eAEA,oEACA,kBACA,WACA,CAKA,kBAAwB,MAAoB,UAC5C,iBAAsB,aAAsB,QAI5C,iBACA,aACA,WAIA,mBACA,aACA,UAIA,mBAAwB,aAAqB,OAI7C,sBAA2B,aAAwB,UAKnD,UAAe,cAA6B,KAI5C,cACA,aACA,OAIA,aACA,aACA,UAIA,YACA,aACA,QAIA,UAAe,aAAkB,IAKjC,SAEA,UACA,4BACA,gCACA,uDACA,2EAGA,uEAEA,aACA,YACA,IAKA,kBACA,aAEA,6BACA,iFAGA,gFAGA,IACA,IAKA,aACA,MACA,qBACA,YACA,yBACA,aACA,uBACA,eACA,yBACA,2BAEA,MACA,EACA,EAIA,cACA,4BAKA,eACA,CAIA,oBACA,8BACA,4CAEA,aACA,yBAAyB,WACzB,uBACA,oCACA,4CACA,+BACA,kCACA,WACA,SACA,GAIA,YAAiB,aAAoB,MAMrC,wBAEA,2DACA,iFACA,IACA,IAKA,yBACA,aACA,4GAEA,OAMA,QACA,OACA,yBAGA,eACA,sBACA,sBAEA,aACA,IASA,gBACA,OACA,yBAGA,gBACA,uBACA,wBAEA,4BACA,wBAGA,2BACA,uBAGA,0BACA,sBAGA,YACA,IAUA,gBACA,OACA,+BAEA,sBAEA,uBAEA,yBAEA,wBACA,wCAGA,YAGA,aACA,yBACA,sBACA,IAKA,wBACA,gGACA,cACA,IAKA,gBACA,qCACA,oDAOA,wBACA,qDACA,YAQA,oBAEA,mBACA,sBACA,+BACA,oCAEA,mCACA,qCAEA,YACA,mBACA,kBAEA,cACA,sBAEA,oCACA,OAIA,QACA,mBACA,mBACA,sCAGA,mCACA,+BACA,MACA,IACA,SACA,MACA,mBACA,YACA,oBACA,QAQA,wBACA,CAEA,UACA,qBAA+B,IAC/B,4DACA,eACA,SACA,KAOA,wBAGA,OACA,wCACA,aACA,YAMA,UACA,qCACA,SACA,SACA,IAUA,wBAGA,OACA,yBACA,YASA,eACA,mBACA,qBACA,SACA,IAOA,qBACA,CAEA,cACA,SACA,SACA,SAEA,OACA,cACA,cACA,cACA,cACA,cACA,YAMA,YACA,sBACA,eACA,SACA,IAMA,iBACA,MAEA,eACA,kCACA,oBAAyC,OAAS,IAClD,IACA,4BAEA,IAKA,QACA,oBACA,aACA,SACA,IAMA,oBACA,MAEA,eACA,kCACA,oBAAyC,OAAS,IAClD,IACA,4BAEA,MACA,YAKA,WACA,uBACA,aACA,SACA,IAMA,iBACA,CAEA,eACA,kCACA,0BACA,0BACA,0BACA,MACA,YAKA,QACA,oBACA,aACA,SACA,IAQA,qBAGA,wBACA,KAOA,YACA,oBACA,YACA,IASA,kCAEA,eACA,kCACA,iCACA,8CACA,IACA,IASA,qCACA,mBACA,+BACA,uBAEA,uBACA,IACA,GACA,wBACA,IACA,YACA,sBACA,iEAEA,mBACA,SACA,+BACA,0BAGA,+BACA,kBACA,UACA,4BACA,cACA,2DACA,EACA,IACA,SACA,SACA,gCACA,gBAEA,UACA,kDACA,KACA,QACA,8CAGA,iCAEA,yBACA,0BAA2C,OAAS,IACpD,iDAEA,YACA,KAMA,mCACA,OACA,gBACA,UACA,kBACA,wBACA,sBACA,eACA,IAKA,OACA,sCACA,gEACA,iCACA,OACA,IACA,EACA,EAGA,YAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OAGA,GACA,oBAKA,kBACA,OACA,iBACA,WACA,UAKA,kBACA,cACA,YACA,2BAAuC,OAAS,IAChD,QACA,cAEA,YACA,SAKA,kBACA,IACA,uBACA,gBACA,kBACA,SAAqB,IAAM,GAAE,IAAM,GAAE,IAAM,GAAE,IAAM,GAAE,IAAM,GAAE,IAC7D,EACA,OACA,EACA,0BACA,sBAEA,qBACA,gCACA,QAKA,iBAAyB,4BAA0C,MAKnE,iBAAyB,4BAA0C,MAKnE,iBAAyB,4BAA0C,MAKnE,iBAAyB,4BAA0C,MAKnE,iBAAyB,4BAA0C,MAKnE,iBAAyB,4BAA0C,MAKnE,iBAAyB,4BAA0C,MAMnE,oBAA4B,2CAAwD,GAIpF,UAAe,sBAA6B,MAI5C,UAAe,sBAA6B,MAI5C,WAAgB,sBAA8B,OAI9C,QACA,aACA,MAEA,qBADA,QAOA,eACA,MACA,uCACA,iBACA,yCAGA,+BAEA,+BACA,aACA,QACA,IAIA,WAAgB,aAAmB,KAEnC,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAE3B,QAAa,sCAAkD,EAC/D,SACA,2BACA,EACA,SACA,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,QAAa,sCAAkD,EAC/D,SACA,2BACA,EACA,SAEA,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAC3B,QAAa,aAAgB,EAC7B,SAAc,MAAa,IAI3B,YAAiB,8BAAwC,CAKzD,gBACA,SACA,iBACA,0BACA,iBAAuB,EAAO,IAC9B,YACA,6CAGA,6CAFA,gBAGA,UACA,IAMA,iBAA+B,qBAAuC,YAKtE,mBACA,aACA,YACA,qBACA,sBACA,OACA,YAAuB,UAAc,GAAE,UAAc,GAAE,UACvD,EACA,OACA,kBAA2B,UAAoB,IAAG,UAAoB,IAAG,UAAoB,IAAG,UAEhG,GACA,gBAA0B,UAAoB,IAAG,UAAoB,IAAG,UAGxE,MAAsB,UAAW,IAAG,OAAQ,IAAG,OAAQ,IAAG,OAAQ,IAAG,UAErE,GAQA,6BACA,kBACA,eACA,WACA,iBACA,EACA,IACA,OACA,OACA,IAEA,MACA,OACA,wBACA,OACA,EACA,uBAEA,GACA,gBAEA,EACA,kBAEA,EACA,gCACA,MAQA,6BACA,IAEA,oBACA,KACA,sCACA,+BACA,MACA,QACA,sBACA,IACA,QAEA,YAGA,QACA,QAMA,2BACA,gDACA,MAQA,6BACA,kBACA,eACA,WACA,WACA,MACA,YAEA,UACA,QACA,uBAEA,GACA,gBAEA,EACA,kBAGA,4BACA,MAQA,6BACA,IAEA,iBACA,aACA,OACA,WACA,YACA,aACA,UACA,iBACA,wBAEA,WACA,SACA,wCACA,MAQA,6BACA,WACA,qCACA,iBAQA,6BACA,WACA,qCACA,iBAQA,6BACA,WACA,qCACA,iBAQA,6BACA,WACA,qCACA,iBAQA,6BACA,WACA,qCACA,iBAQA,6BACA,WACA,qCACA,iBAQA,6BACA,WACA,iCAAuB,EAAO,IAC9B,mDAEA,gBAEA,+IACA,kBACA,aAQA,6BACA,kBACA,eACA,2BACA,kCACA,iCAGA,uBAAuB,EAAO,IAC9B,+DACA,kBAEA,2BAEA,wCACA,kBACA,aAQA,6BACA,4BAEA,mBACA,8CACA,UACA,uDACA,kBACA,aAQA,6BACA,WACA,6BACA,WACA,eACA,WACA,OACA,oCACA,KACA,MAEA,QAIA,mDACA,kBACA,aAQA,6BACA,gBACA,+BACA,mBACA,QACA,oCACA,mDACA,+CACA,YACA,0CACA,MAQA,6BACA,gBACA,0BACA,MACA,+BACA,qDACA,+CACA,SACA,aACA,WACA,8BACA,yBACA,0BACA,MAQA,6BACA,WACA,+DACA,mDACA,MAQA,6BACA,WACA,qCACA,4CACA,MAEA,EACA,kCAGA,GACA,SACA,4DACA,+DACA,6DACA,qEACA,iEACA,uEACA,iEACA,OACA,EAGA,OAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OACA,OACA,OAGA,GAmHA,EAGA,OArHA,KAOA,iCACA,aACA,kBAAuB,EAAW,IAClC,2BACA,OACA,gCACA,QACA,gCACA,oBAEA,OACA,QAMA,6BACA,4BACA,GAGA,mBAFA,sBACA,KAUA,gCACA,WACA,sBACA,+DACA,iBACA,qBACA,gBAAuB,EAAU,IACjC,cAA2B,EAAa,IACxC,4CAGA,QACA,QAQA,wBACA,WACA,sBACA,+DACA,cACA,aAAuB,EAAU,IACjC,cAA2B,EAAa,IACxC,wFAGA,UACA,QAOA,wBACA,aACA,gBACA,mBAAuB,EAAW,IAClC,2CAEA,eACA,QASA,uCACA,YACA,iBACA,sBAAyC,OAAS,QAClD,aACA,iBACA,gBACA,sBACA,OACA,UACA,OACA,CACA,QAMA,mBACA,UACA,OACA,GAKA,QACA,kCACA,oCACA,oCAKA,yBACA,4EACA,2EACA,0EACA,4EACA,yEACA,2EACA,6EACA,0EACA,uEACA,2EACA,yEACA,wEAKA,KACA,oBAKA,kBACA,OACA,gBACA,wBAEA,iBACA,SAMA,gBACA,kBACA,KAMA,cACA,SACA,QAKA,QACA,MACA,SACA,SACA,KACA,cACA,eAAuB,EAAS,MAChC,0BACA,kCAEA,MAIA,UACA,qBACA,oBACA,iBACA,mBACA,8CACA,gDACA,gDACA,oDACA,6BACA,MACA,2DACA,KACA,EACA,EAKA,QACA,uBACA,cACA,UACA,sBACA,EAMA,eACA,IACA,oBACA,cACA,cAEA,SACA,aAAuB,EAAO,IAC9B,IACA,wCAEA,eACA,eACA,qBAEA,sCACA,QACA,KAEA,mBAA6C,OAAS,QACtD,OACA,OACA,OACA,gBACA,yBAEA,SACA,OACA,mBACA,6BAEA,6BACA,GACA,iBACA,qBACA,GACA,QAEA,iCAIA,uCACA,cACA,GAEA,OAEA,eACA,OACA,kCAEA,aACA,mBAA4C,OAAS,IACrD,MACA,qBACA,QACA,iBACA,eAGA,iBACA,MAKA,UACA,OACA,UACA,sBAAuC,OAAS,IAChD,gBAEA,mBACA,QAKA,OACA,aACA,KAOA,oBACA,aACA,aACA,kBACA,WACA,yCAEA,oBACA,cAMA,aACA,OACA,UACA,kBACA,WACA,0BAEA,SACA,QAKA,UACA,oBAA2B,UAAmB,IAAG,UACjD,yBAA2B,UAAmB,IAAG,UACjD,yBAA2B,UAAmB,IAAG,UACjD,KAKA,iBACA,YACA,UACA,sBAA0C,OAAS,IACnD,aACA,kBAEA,iBACA,gCACA,cACA,sEACA,IAQA,wBACA,8BACA,KASA,wBACA,eACA,yBACA,CACA,IACA,IACA,IACA,6BAEA,gBAKA,kBACA,aACA,OACA,iBACA,SACA,KACA,SACA,SACA,SACA,+BACA,YACA,cACA,GACA,KACA,CAEA,CACA,QACA,EACA,EAGA,UAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UACA,OACA,OACA,OACA,OACA,OAGA,GACA,0BAOA,iBACA,IACA,mBACA,yBACA,kDACA,0CAAgE,OAChE,6BACA,aACA,SACA,CAKA,UAAe,cAA0B,KAIzC,cACA,aACA,OAMA,YACA,cACA,mCACA,gBAA8B,gBAAiB,IAAG,iBAClD,YAAwB,gBACxB,aAAyB,iBACzB,SACA,qCAEA,QACA,IAOA,yBACA,WACA,4BACA,kEAA8C,KAE9C,IAKA,sCAJA,+CACA,UAEA,iBAMA,UACA,8CACA,kCACA,cACA,cACA,SACA,SAIA,YACA,kCACA,SACA,WACA,EACA,EAIA,WACA,4BAKA,eACA,CACA,kBACA,OACA,aACA,iBACA,YACA,oBACA,SACA,CACA,UACA,gBACA,cACA,sBACA,oBACA,yBAEA,eACA,2BACA,cAEA,mBACA,eACA,yBAAyB,WACzB,6BACA,uCACA,eACA,SACA,GAIA,YAAiB,aAAoB,MAMrC,aACA,cACA,kCAA+B,IAC/B,2CACA,UAMA,QACA,OACA,iCAGA,0BACA,0BAEA,WACA,IASA,gBACA,OACA,iCAGA,2BACA,2BAEA,4BAEA,kCAEA,qCAEA,qBACA,IAMA,OACA,+BACA,oBAKA,KACA,IAUA,gBACA,OACA,+BAEA,sBAEA,uBAEA,yBAEA,wBACA,wCAGA,YAEA,QACA,IAIA,QACA,wBACA,WACA,8BACA,sBACA,oBACA,yBAEA,mCACA,wCACA,MACA,IAOA,iBACA,kBACA,kBACA,+BACA,OACA,cACA,IAMA,SACA,QACA,kCACA,8FACA,QAKA,SACA,kBACA,oCAAiC,iBAAkB,IAAG,oBACtD,aACA,SAKA,gBACA,0BAAqC,SACrC,EAKA,kBACA,eAAuB,WACvB,EAQA,kBACA,OACA,UAKA,KAJA,kBACA,cACA,kBACA,oEAEA,OACA,KACA,mBACA,sBAEA,6BACA,wBAGA,qBAAmC,IAAM,MAGzC,GAEA,6BAA6C,cAC7C,MASA,iCACA,OACA,eAGA,gBAEA,aAQA,wBACA,aACA,sBACA,YACA,IAOA,wBACA,uCACA,UAQA,4BAPA,MACA,QACA,GACA,oCAA+C,cAE/C,iBACA,QAOA,UACA,aACA,sCACA,IACA,IAUA,wBACA,qCACA,8BACA,8BACA,8CACA,iCAEA,UACA,kBACA,WAAuB,IAAS,IAAG,IAAc,OAAU,KAAO,MAAK,SAAwB,KAAM,IAAG,IAAO,IAAG,IAClH,GAMA,4BALA,CACA,iCAA4C,cAE5C,iBACA,QAUA,eACA,aACA,oBACA,gBACA,IAOA,qBACA,qCACA,UASA,4BARA,KACA,SACA,WACA,WACA,oCAA+C,cAE/C,iBACA,QAOA,YACA,aACA,uBACA,UACA,IAMA,iBACA,SAEA,kBACA,oBACA,kDACA,UASA,4BARA,SACA,WACA,WACA,WACA,iCAA6C,cAE7C,iBACA,SAMA,QACA,aACA,qBACA,QACA,IAOA,uBACA,SAEA,mEACA,iCAAiD,IAAK,IAAG,IAAK,IAC9D,IAMA,4BALA,CACA,0CAAgD,cAEhD,iBACA,SAOA,oBACA,UACA,aAKA,WACA,aACA,wBACA,QACA,IAMA,iBACA,SAEA,mDACA,iCACA,4BACA,QASA,4BARA,QACA,UACA,WACA,YACA,iCAA6C,cAE7C,iBACA,SAMA,QACA,aACA,qBACA,QACA,IAQA,mBACA,qCACA,UAUA,4BATA,kBACA,WACA,OACA,WACA,gCAA6C,cAE7C,OACA,0BACA,QAQA,UACA,aACA,qBACA,UACA,IAKA,OACA,qDACA,OACA,IACA,EACA,YACA,UACA,EAGA,SAEA,kBAKA,aACA,qCAA8C,CAAc,WAC5D,UAGA,GACA,MACA,YACA,kBACA,0BACA,wBACA,0BACA,uBACA,MAAC,2BAAoD,KACrD,mBACA,yEACA,OACA,OAIA,qBACA,MACA,aACA,aACA,WACA,wBACA,EAIA,SAAc,aAAiB,GAC/B,UAAe,MAAc,KAK7B,SACA,aACA,cAMA,QACA,aACA,cACA,IAMA,OACA,oBACA,YACA,IAMA,YACA,wBACA,kBACA,kCAKA,WAKA,UACA,mBACA,QAKA,YACA,OACA,uBACA,wBAEA,mCACA,kBAEA,mCACA,sBAGA,gBAEA,wBACA,QACA,EACA,EAGA,KACA,iBACA,qBACA,CACA,4BACA,CAIA,aAAkB,aAAqB,OAKvC,WACA,MACA,qCACA,KAMA,aACA,4BACA,mCACA,MACA,EACA,EAGA,UAEA,kBAEA,aAEA,qCAA8C,CAAc,WAC5D,UACA,OACA,QACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,OACA,OACA,QAEA,GAQA,wBAAgC,CAGhC,eAVA,SACA,eACA,QACA,sBAGA,oCAMA,GACA","file":"pts.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Pts\"] = factory();\n\telse\n\t\troot[\"Pts\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a5c7baf647b9c90dec0a","/*!\n * pts.js - Copyright © 2017-2018 William Ngan and contributors.\n * Licensed under Apache 2.0 License.\n * See https://github.com/williamngan/pts for details.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Pts\"] = factory();\n\telse\n\t\troot[\"Pts\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 15);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = __webpack_require__(1);\nconst Num_1 = __webpack_require__(3);\nconst LinearAlgebra_1 = __webpack_require__(4);\nexports.PtBaseArray = Float32Array;\n/**\n * Pt is a subclass of Float32Array with additional properties and functions to support vector and geometric calculations.\n * See [Pt guide](../../guide/Pt-0200.html) for details\n */\nclass Pt extends exports.PtBaseArray {\n    /**\n     * Create a Pt. If no parameter is provided, this will instantiate a Pt with 2 dimensions [0, 0].\n     *\n     * Note that `new Pt(3)` will only instantiate Pt with length of 3 (ie, same as `new Float32Array(3)` ). If you need a Pt with 1 dimension of value 3, use `new Pt([3])`.\n     * @example `new Pt()`, `new Pt(1,2,3,4,5)`, `new Pt([1,2])`, `new Pt({x:0, y:1})`, `new Pt(pt)`\n     * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties\n     */\n    constructor(...args) {\n        if (args.length === 1 && typeof args[0] == \"number\") {\n            super(args[0]); // init with the TypedArray's length. Needed this in order to make \".map\", \".slice\" etc work.\n        }\n        else {\n            super((args.length > 0) ? Util_1.Util.getArgs(args) : [0, 0]);\n        }\n    }\n    static make(dimensions, defaultValue = 0, randomize = false) {\n        let p = new exports.PtBaseArray(dimensions);\n        if (defaultValue)\n            p.fill(defaultValue);\n        if (randomize) {\n            for (let i = 0, len = p.length; i < len; i++) {\n                p[i] = p[i] * Math.random();\n            }\n        }\n        return new Pt(p);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get x() { return this[0]; }\n    get y() { return this[1]; }\n    get z() { return this[2]; }\n    get w() { return this[3]; }\n    set x(n) { this[0] = n; }\n    set y(n) { this[1] = n; }\n    set z(n) { this[2] = n; }\n    set w(n) { this[3] = n; }\n    /**\n     * Clone this Pt\n     */\n    clone() {\n        return new Pt(this);\n    }\n    /**\n     * Check if another Pt is equal to this Pt, within a threshold\n     * @param p another Pt to compare with\n     * @param threshold a threshold value within which the two Pts are considered equal. Default is 0.000001.\n     */\n    equals(p, threshold = 0.000001) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            if (Math.abs(this[i] - p[i]) > threshold)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Update the values of this Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    to(...args) {\n        let p = Util_1.Util.getArgs(args);\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            this[i] = p[i];\n        }\n        return this;\n    }\n    /**\n     * Like `to()` but returns a new Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    $to(...args) {\n        return this.clone().to(...args);\n    }\n    /**\n     * Update the values of this Pt to point at a specific angle\n     * @param radian target angle in radian\n     * @param magnitude Optional magnitude if known. If not provided, it'll calculate and use this Pt's magnitude.\n     * @param anchorFromPt If `true`, translate to new position from current position. Default is `false` which update the position from origin (0,0);\n     */\n    toAngle(radian, magnitude, anchorFromPt = false) {\n        let m = (magnitude != undefined) ? magnitude : this.magnitude();\n        let change = [Math.cos(radian) * m, Math.sin(radian) * m];\n        return (anchorFromPt) ? this.add(change) : this.to(change);\n    }\n    /**\n     * Create an operation using this Pt, passing this Pt into a custom function's first parameter. See the [Op guide](../../guide/Op-0400.html) for details.\n     * For example: `let myOp = pt.op( fn ); let result = myOp( [1,2,3] );`\n     * @param fn any function that takes a Pt as its first parameter\n     * @returns a resulting function that takes other parameters required in `fn`\n     */\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    /**\n     * This combines a series of operations into an array. See `op()` for details.\n     * For example: `let myOps = pt.ops([fn1, fn2, fn3]); let results = myOps.map( (op) => op([1,2,3]) );`\n     * @param fns an array of functions for `op`\n     * @returns an array of resulting functions\n     */\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    /**\n     * Take specific dimensional values from this Pt and create a new Pt\n     * @param axis a string such as \"xy\" (use Const.xy) or an array to specify index for two dimensions\n     */\n    $take(axis) {\n        let p = [];\n        for (let i = 0, len = axis.length; i < len; i++) {\n            p.push(this[axis[i]] || 0);\n        }\n        return new Pt(p);\n    }\n    /**\n     * Concatenate this Pt with addition dimensional values and return as a new Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    $concat(...args) {\n        return new Pt(this.toArray().concat(Util_1.Util.getArgs(args)));\n    }\n    /**\n     * Add scalar or vector values to this Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    add(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? LinearAlgebra_1.Vec.add(this, args[0]) : LinearAlgebra_1.Vec.add(this, Util_1.Util.getArgs(args));\n        return this;\n    }\n    /**\n     * Like `add`, but returns result as a new Pt\n     */\n    $add(...args) { return this.clone().add(...args); }\n    /**\n     * Subtract scalar or vector values from this Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    subtract(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? LinearAlgebra_1.Vec.subtract(this, args[0]) : LinearAlgebra_1.Vec.subtract(this, Util_1.Util.getArgs(args));\n        return this;\n    }\n    /**\n     * Like `subtract`, but returns result as a new Pt\n     */\n    $subtract(...args) { return this.clone().subtract(...args); }\n    /**\n     * Multiply scalar or vector values (as element-wise) with this Pt.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    multiply(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? LinearAlgebra_1.Vec.multiply(this, args[0]) : LinearAlgebra_1.Vec.multiply(this, Util_1.Util.getArgs(args));\n        return this;\n    }\n    /**\n     * Like `multiply`, but returns result as a new Pt\n     */\n    $multiply(...args) { return this.clone().multiply(...args); }\n    /**\n     * Divide this Pt over scalar or vector values (as element-wise)\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    divide(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? LinearAlgebra_1.Vec.divide(this, args[0]) : LinearAlgebra_1.Vec.divide(this, Util_1.Util.getArgs(args));\n        return this;\n    }\n    /**\n     * Like `divide`, but returns result as a new Pt\n     */\n    $divide(...args) { return this.clone().divide(...args); }\n    /**\n     * Get the sqaured distance (magnitude) of this Pt from origin\n     */\n    magnitudeSq() { return LinearAlgebra_1.Vec.dot(this, this); }\n    /**\n     * Get the distance (magnitude) of this Pt from origin\n     */\n    magnitude() { return LinearAlgebra_1.Vec.magnitude(this); }\n    /**\n     * Convert to a unit vector, which is a normalized vector whose magnitude equals 1.\n     * @param magnitude Optional: if the magnitude is known, pass it as a parameter to avoid duplicate calculation.\n     */\n    unit(magnitude = undefined) {\n        LinearAlgebra_1.Vec.unit(this, magnitude);\n        return this;\n    }\n    /**\n     * Get a unit vector from this Pt\n     */\n    $unit(magnitude = undefined) { return this.clone().unit(magnitude); }\n    /**\n     * Dot product of this Pt and another Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    dot(...args) { return LinearAlgebra_1.Vec.dot(this, Util_1.Util.getArgs(args)); }\n    /**\n     * 2D Cross product of this Pt and another Pt. Return results as a new Pt.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    cross2D(...args) { return LinearAlgebra_1.Vec.cross2D(this, Util_1.Util.getArgs(args)); }\n    /**\n     * 3D Cross product of this Pt and another Pt. Return results as a new Pt.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    $cross(...args) { return LinearAlgebra_1.Vec.cross(this, Util_1.Util.getArgs(args)); }\n    /**\n     * Calculate vector projection of this Pt on another Pt. Returns result as a new Pt.\n     * @param p a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    $project(p) {\n        let m = p.magnitude();\n        let a = this.$unit();\n        let b = p.$divide(m);\n        let dot = a.dot(b);\n        return a.multiply(m * dot);\n    }\n    /**\n     * Absolute values for all values in this pt\n     */\n    abs() {\n        LinearAlgebra_1.Vec.abs(this);\n        return this;\n    }\n    /**\n     * Get a new Pt with absolute values of this Pt\n     */\n    $abs() {\n        return this.clone().abs();\n    }\n    /**\n     * Floor values for all values in this pt\n     */\n    floor() {\n        LinearAlgebra_1.Vec.floor(this);\n        return this;\n    }\n    /**\n     * Get a new Pt with floor values of this Pt\n     */\n    $floor() {\n        return this.clone().floor();\n    }\n    /**\n     * Ceil values for all values in this pt\n     */\n    ceil() {\n        LinearAlgebra_1.Vec.ceil(this);\n        return this;\n    }\n    /**\n     * Get a new Pt with ceil values of this Pt\n     */\n    $ceil() {\n        return this.clone().ceil();\n    }\n    /**\n     * Round values for all values in this pt\n     */\n    round() {\n        LinearAlgebra_1.Vec.round(this);\n        return this;\n    }\n    /**\n     * Get a new Pt with round values of this Pt\n     */\n    $round() {\n        return this.clone().round();\n    }\n    /**\n     * Find the minimum value across all dimensions in this Pt\n     * @returns an object with `value` and `index` which returns the minimum value and its dimensional index\n     */\n    minValue() {\n        return LinearAlgebra_1.Vec.min(this);\n    }\n    /**\n     * Find the maximum value across all dimensions in this Pt\n     * @returns an object with `value` and `index` which returns the maximum value and its dimensional index\n     */\n    maxValue() {\n        return LinearAlgebra_1.Vec.max(this);\n    }\n    /**\n     * Get a new Pt that has the minimum dimensional values of this Pt and another Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    $min(...args) {\n        let p = Util_1.Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.min(this[i], p[i]);\n        }\n        return m;\n    }\n    /**\n     * Get a new Pt that has the maximum dimensional values of this Pt and another Pt\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    $max(...args) {\n        let p = Util_1.Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.max(this[i], p[i]);\n        }\n        return m;\n    }\n    /**\n     * Get angle of this vector from origin\n     * @param axis a string such as \"xy\" (use Const.xy) or an array to specify index for two dimensions\n     */\n    angle(axis = Util_1.Const.xy) {\n        return Math.atan2(this[axis[1]], this[axis[0]]);\n    }\n    /**\n     * Get the angle between this and another Pt\n     * @param p the other Pt\n     * @param axis a string such as \"xy\" (use Const.xy) or an array to specify index for two dimensions\n     */\n    angleBetween(p, axis = Util_1.Const.xy) {\n        return Num_1.Geom.boundRadian(this.angle(axis)) - Num_1.Geom.boundRadian(p.angle(axis));\n    }\n    /**\n     * Scale this Pt from origin or from an anchor point\n     * @param scale scale ratio\n     * @param anchor optional anchor point to scale from\n     */\n    scale(scale, anchor) {\n        Num_1.Geom.scale(this, scale, anchor || Pt.make(this.length, 0));\n        return this;\n    }\n    /**\n     * Rotate this Pt from origin or from an anchor point in 2D\n     * @param angle rotate angle\n     * @param anchor optional anchor point to scale from\n     * @param axis optional string such as \"yz\" to specify a 2D plane\n     */\n    rotate2D(angle, anchor, axis) {\n        Num_1.Geom.rotate2D(this, angle, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    /**\n     * Shear this Pt from origin or from an anchor point in 2D\n     * @param shear shearing value which can be a number or an array of 2 numbers\n     * @param anchor optional anchor point to scale from\n     * @param axis optional string such as \"yz\" to specify a 2D plane\n     */\n    shear2D(scale, anchor, axis) {\n        Num_1.Geom.shear2D(this, scale, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    /**\n     * Reflect this Pt along a 2D line\n     * @param line a Group of 2 Pts that defines a line for reflection\n     * @param axis optional axis such as \"yz\" to define a 2D plane of reflection\n     */\n    reflect2D(line, axis) {\n        Num_1.Geom.reflect2D(this, line, axis);\n        return this;\n    }\n    /**\n     * A string representation of this Pt: \"Pt(1, 2, 3)\"\n     */\n    toString() {\n        return `Pt(${this.join(\", \")})`;\n    }\n    /**\n     * Convert this Pt to a javascript Array\n     */\n    toArray() {\n        return [].slice.call(this);\n    }\n}\nexports.Pt = Pt;\n/**\n * A Group is a subclass of Array. It should onnly contain Pt instances. You can think of it as an array of arrays (Float32Arrays to be specific).\n * See [Group guide](../../guide/Group-0300.html) for details\n */\nclass Group extends Array {\n    constructor(...args) {\n        super(...args);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    /** The first Pt in this group */\n    get p1() { return this[0]; }\n    /** The second Pt in this group */\n    get p2() { return this[1]; }\n    /** The third Pt in this group */\n    get p3() { return this[2]; }\n    /** The forth Pt in this group */\n    get p4() { return this[3]; }\n    /** The last Pt in this group */\n    get q1() { return this[this.length - 1]; }\n    /** The second-last Pt in this group */\n    get q2() { return this[this.length - 2]; }\n    /** The third-last Pt in this group */\n    get q3() { return this[this.length - 3]; }\n    /** The forth-last Pt in this group */\n    get q4() { return this[this.length - 4]; }\n    /**\n     * Depp clone this group and its Pts\n     */\n    clone() {\n        let group = new Group();\n        for (let i = 0, len = this.length; i < len; i++) {\n            group.push(this[i].clone());\n        }\n        return group;\n    }\n    /**\n     * Convert an array of numeric arrays into a Group of Pts\n     * @param list an array of numeric arrays\n     * @example `Group.fromArray( [[1,2], [3,4], [5,6]] )`\n     */\n    static fromArray(list) {\n        let g = new Group();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = (list[i] instanceof Pt) ? list[i] : new Pt(list[i]);\n            g.push(p);\n        }\n        return g;\n    }\n    /**\n     * Convert an array of Pts into a Group.\n     * @param list an array of Pts\n     */\n    static fromPtArray(list) {\n        return Group.from(list);\n    }\n    /**\n     * Split this Group into an array of sub-groups\n     * @param chunkSize number of items per sub-group\n     * @param stride forward-steps after each sub-group\n     * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed\n     */\n    split(chunkSize, stride, loopBack = false) {\n        let sp = Util_1.Util.split(this, chunkSize, stride, loopBack);\n        return sp;\n    }\n    /**\n     * Insert a Pt into this group\n     * @param pts Another group of Pts\n     * @param index the index position to insert into\n     */\n    insert(pts, index = 0) {\n        Group.prototype.splice.apply(this, [index, 0, ...pts]);\n        return this;\n    }\n    /**\n     * Like Array's splice function, with support for negative index and a friendlier name.\n     * @param index start index, which can be negative (where -1 is at index 0, -2 at index 1, etc)\n     * @param count number of items to remove\n     * @returns The items that are removed.\n     */\n    remove(index = 0, count = 1) {\n        let param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        return Group.prototype.splice.apply(this, param);\n    }\n    /**\n     * Split this group into an array of sub-group segments\n     * @param pts_per_segment number of Pts in each segment\n     * @param stride forward-step to take\n     * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed\n     */\n    segments(pts_per_segment = 2, stride = 1, loopBack = false) {\n        return this.split(pts_per_segment, stride, loopBack);\n    }\n    /**\n     * Get all the line segments (ie, edges in a graph) of this group\n     */\n    lines() { return this.segments(2, 1); }\n    /**\n     * Find the centroid of this group's Pts, which is the average middle point.\n     */\n    centroid() {\n        return Num_1.Geom.centroid(this);\n    }\n    /**\n     * Find the rectangular bounding box of this group's Pts.\n     * @returns a Group of 2 Pts representing the top-left and bottom-right of the rectangle\n     */\n    boundingBox() {\n        return Num_1.Geom.boundingBox(this);\n    }\n    /**\n     * Anchor all the Pts in this Group using a target Pt as origin. (ie, subtract all Pt with the target anchor to get a relative position). All the Pts' values will be updated.\n     * @param ptOrIndex a Pt, or a numeric index to target a specific Pt in this Group\n     */\n    anchorTo(ptOrIndex = 0) { Num_1.Geom.anchor(this, ptOrIndex, \"to\"); }\n    /**\n     * Anchor all the Pts in this Group by its absolute position from a target Pt. (ie, add all Pt with the target anchor to get an absolute position).  All the Pts' values will be updated.\n     * @param ptOrIndex a Pt, or a numeric index to target a specific Pt in this Group\n     */\n    anchorFrom(ptOrIndex = 0) { Num_1.Geom.anchor(this, ptOrIndex, \"from\"); }\n    /**\n     * Create an operation using this Group, passing this Group into a custom function's first parameter.  See the [Op guide](../../guide/Op-0400.html) for details.\n     * For example: `let myOp = group.op( fn ); let result = myOp( [1,2,3] );`\n     * @param fn any function that takes a Group as its first parameter\n     * @returns a resulting function that takes other parameters required in `fn`\n     */\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    /**\n     * This combines a series of operations into an array. See `op()` for details.\n     * For example: `let myOps = pt.ops([fn1, fn2, fn3]); let results = myOps.map( (op) => op([1,2,3]) );`\n     * @param fns an array of functions for `op`\n     * @returns an array of resulting functions\n     */\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    /**\n     * Get an interpolated point on the line segments defined by this Group\n     * @param t a value between 0 to 1 usually\n     */\n    interpolate(t) {\n        t = Num_1.Num.clamp(t, 0, 1);\n        let chunk = this.length - 1;\n        let tc = 1 / (this.length - 1);\n        let idx = Math.floor(t / tc);\n        return Num_1.Geom.interpolate(this[idx], this[Math.min(this.length - 1, idx + 1)], (t - idx * tc) * chunk);\n    }\n    /**\n     * Move every Pt's position by a specific amount. Same as `add`.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    moveBy(...args) {\n        return this.add(...args);\n    }\n    /**\n     * Move the first Pt in this group to a specific position, and move all the other Pts correspondingly\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    moveTo(...args) {\n        let d = new Pt(Util_1.Util.getArgs(args)).subtract(this[0]);\n        this.moveBy(d);\n        return this;\n    }\n    /**\n     * Scale this group's Pts from an anchor point. Default anchor point is the first Pt in this group.\n     * @param scale scale ratio\n     * @param anchor optional anchor point to scale from\n     */\n    scale(scale, anchor) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Num_1.Geom.scale(this[i], scale, anchor || this[0]);\n        }\n        return this;\n    }\n    /**\n     * Rotate this group's Pt from an anchor point in 2D. Default anchor point is the first Pt in this group.\n     * @param angle rotate angle\n     * @param anchor optional anchor point to scale from\n     * @param axis optional string such as \"yz\" to specify a 2D plane\n     */\n    rotate2D(angle, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Num_1.Geom.rotate2D(this[i], angle, anchor || this[0], axis);\n        }\n        return this;\n    }\n    /**\n     * Shear this group's Pt from an anchor point in 2D. Default anchor point is the first Pt in this group.\n     * @param shear shearing value which can be a number or an array of 2 numbers\n     * @param anchor optional anchor point to scale from\n     * @param axis optional string such as \"yz\" to specify a 2D plane\n     */\n    shear2D(scale, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Num_1.Geom.shear2D(this[i], scale, anchor || this[0], axis);\n        }\n        return this;\n    }\n    /**\n     * Reflect this group's Pts along a 2D line. Default anchor point is the first Pt in this group.\n     * @param line a Group of 2 Pts that defines a line for reflection\n     * @param axis optional axis such as \"yz\" to define a 2D plane of reflection\n     */\n    reflect2D(line, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Num_1.Geom.reflect2D(this[i], line, axis);\n        }\n        return this;\n    }\n    /**\n     * Sort this group's Pts by values in a specific dimension\n     * @param dim dimensional index\n     * @param desc if true, sort descending. Default is false (ascending)\n     */\n    sortByDimension(dim, desc = false) {\n        return this.sort((a, b) => (desc) ? b[dim] - a[dim] : a[dim] - b[dim]);\n    }\n    /**\n     * Update each Pt in this Group with a Pt function\n     * @param ptFn string name of an existing Pt function. Note that the function must return Pt.\n     * @param args arguments for the function specified in ptFn\n     */\n    forEachPt(ptFn, ...args) {\n        if (!this[0][ptFn]) {\n            Util_1.Util.warn(`${ptFn} is not a function of Pt`);\n            return this;\n        }\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i] = this[i][ptFn](...args);\n        }\n        return this;\n    }\n    /**\n     * Add scalar or vector values to this group's Pts.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    add(...args) {\n        return this.forEachPt(\"add\", ...args);\n    }\n    /**\n     * Subtract scalar or vector values from this group's Pts.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    subtract(...args) {\n        return this.forEachPt(\"subtract\", ...args);\n    }\n    /**\n     * Multiply scalar or vector values (as element-wise) with this group's Pts.\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    multiply(...args) {\n        return this.forEachPt(\"multiply\", ...args);\n    }\n    /**\n     * Divide this group's Pts over scalar or vector values (as element-wise)\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    divide(...args) {\n        return this.forEachPt(\"divide\", ...args);\n    }\n    /**\n     * Apply this group as a matrix and calculate matrix addition\n     * @param g a scalar number, an array of numeric arrays, or a group of Pt\n     * @returns a new Group\n     */\n    $matrixAdd(g) {\n        return LinearAlgebra_1.Mat.add(this, g);\n    }\n    /**\n     * Apply this group as a matrix and calculate matrix multiplication\n     * @param g a scalar number, an array of numeric arrays, or a Group of K Pts, each with N dimensions (K-rows, N-columns) -- or if transposed is true, then N Pts with K dimensions\n     * @param transposed (Only applicable if it's not elementwise multiplication) If true, then a and b's columns should match (ie, each Pt should have the same dimensions). Default is `false`.\n     * @param elementwise if true, then the multiplication is done element-wise. Default is `false`.\n     * @returns If not elementwise, this will return a new  Group with M Pt, each with N dimensions (M-rows, N-columns).\n     */\n    $matrixMultiply(g, transposed = false, elementwise = false) {\n        return LinearAlgebra_1.Mat.multiply(this, g, transposed, elementwise);\n    }\n    /**\n     * Zip one slice of an array of Pt. Imagine the Pts are organized in rows, then this function will take the values in a specific column.\n     * @param idx index to zip at\n     * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.\n     */\n    zipSlice(index, defaultValue = false) {\n        return LinearAlgebra_1.Mat.zipSlice(this, index, defaultValue);\n    }\n    /**\n     * Zip a group of Pt. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]\n     * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.\n     * @param useLongest If true, find the longest list of values in a Pt and use its length for zipping. Default is false, which uses the first item's length for zipping.\n     */\n    $zip(defaultValue = undefined, useLongest = false) {\n        return LinearAlgebra_1.Mat.zip(this, defaultValue, useLongest);\n    }\n    /**\n     * Get a string representation of this group\n     */\n    toString() {\n        return \"Group[ \" + this.reduce((p, c) => p + c.toString() + \" \", \"\") + \" ]\";\n    }\n}\nexports.Group = Group;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0.\n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pt_1 = __webpack_require__(0);\n/**\n * Various constant values for enumerations and calculations\n */\nexports.Const = {\n    xy: \"xy\",\n    yz: \"yz\",\n    xz: \"xz\",\n    xyz: \"xyz\",\n    horizontal: 0,\n    vertical: 1,\n    /* represents identical point or value */\n    identical: 0,\n    /* represents right position or direction */\n    right: 4,\n    /* represents bottom right position or direction */\n    bottom_right: 5,\n    /* represents bottom position or direction */\n    bottom: 6,\n    /* represents bottom left position or direction */\n    bottom_left: 7,\n    /* represents left position or direction */\n    left: 8,\n    /* represents top left position or direction */\n    top_left: 1,\n    /* represents top position or direction */\n    top: 2,\n    /* represents top right position or direction */\n    top_right: 3,\n    /* represents an arbitrary very small number. It is set as 0.0001 here. */\n    epsilon: 0.0001,\n    /* represents Number.MAX_VALUE */\n    max: Number.MAX_VALUE,\n    /* represents Number.MIN_VALUE */\n    min: Number.MIN_VALUE,\n    /* pi radian (180 deg) */\n    pi: Math.PI,\n    /* two pi radian (360deg) */\n    two_pi: 6.283185307179586,\n    /* half pi radian (90deg) */\n    half_pi: 1.5707963267948966,\n    /* pi/4 radian (45deg) */\n    quarter_pi: 0.7853981633974483,\n    /* pi/180: 1 degree in radian */\n    one_degree: 0.017453292519943295,\n    /* multiply this constant with a radian to get a degree */\n    rad_to_deg: 57.29577951308232,\n    /* multiply this constant with a degree to get a radian */\n    deg_to_rad: 0.017453292519943295,\n    /* Gravity acceleration (unit: m/s^2) and gravity force (unit: Newton) on 1kg of mass. */\n    gravity: 9.81,\n    /* 1 Newton: 0.10197 Kilogram-force */\n    newton: 0.10197,\n    /* Gaussian constant (1 / Math.sqrt(2 * Math.PI)) */\n    gaussian: 0.3989422804014327\n};\n/**\n * Util provides various helper functions\n */\nclass Util {\n    /**\n     * Convert different kinds of parameters (arguments, array, object) into an array of numbers\n     * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties\n     */\n    static getArgs(args) {\n        if (args.length < 1)\n            return [];\n        let pos = [];\n        let isArray = Array.isArray(args[0]) || ArrayBuffer.isView(args[0]);\n        // positional arguments: x,y,z,w,...\n        if (typeof args[0] === 'number') {\n            pos = Array.prototype.slice.call(args);\n            // as an object of {x, y?, z?, w?}\n        }\n        else if (typeof args[0] === 'object' && !isArray) {\n            let a = [\"x\", \"y\", \"z\", \"w\"];\n            let p = args[0];\n            for (let i = 0; i < a.length; i++) {\n                if ((p.length && i >= p.length) || !(a[i] in p))\n                    break; // check for length and key exist\n                pos.push(p[a[i]]);\n            }\n            // as an array of values\n        }\n        else if (isArray) {\n            pos = [].slice.call(args[0]);\n        }\n        return pos;\n    }\n    /**\n     * Send a warning message based on Util.warnLevel global setting. This allows you to dynamically set whether minor errors should be thrown or printed in console or muted.\n     * @param message any error or warning message\n     * @param defaultReturn optional return value\n     */\n    static warn(message = \"error\", defaultReturn = undefined) {\n        if (Util.warnLevel == \"error\") {\n            throw new Error(message);\n        }\n        else if (Util.warnLevel == \"warn\") {\n            console.warn(message);\n        }\n        return defaultReturn;\n    }\n    static randomInt(range, start = 0) {\n        return Math.floor(Math.random() * range) + start;\n    }\n    /**\n     * Split an array into chunks of sub-array\n     * @param pts an array\n     * @param size chunk size, ie, number of items in a chunk\n     * @param stride optional parameter to \"walk through\" the array in steps\n     * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed\n     */\n    static split(pts, size, stride, loopBack = false) {\n        let st = stride || size;\n        let chunks = [];\n        for (let i = 0; i < pts.length; i++) {\n            if (i * st + size > pts.length) {\n                if (loopBack) {\n                    let g = pts.slice(i * st);\n                    g = g.concat(pts.slice(0, (i * st + size) % size));\n                    chunks.push(g);\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                chunks.push(pts.slice(i * st, i * st + size));\n            }\n        }\n        return chunks;\n    }\n    /**\n     * Flatten an array of arrays such as Group[] to a flat Array or Group\n     * @param pts an array, usually an array of Groups\n     * @param flattenAsGroup a boolean to specify whether the return type should be a Group or Array. Default is `true` which returns a Group.\n     */\n    static flatten(pts, flattenAsGroup = true) {\n        let arr = (flattenAsGroup) ? new Pt_1.Group() : new Array();\n        return arr.concat.apply(arr, pts);\n    }\n    /**\n   * Given two arrays of object<T>, and a function that operate on two object<T>, return an array of T\n   * @param a an array of object<T>, eg [ Group, Group, ... ]\n   * @param b another array of object<T>\n   * @param op a function that takes two parameters (a, b) and returns a T\n   */\n    static combine(a, b, op) {\n        let result = [];\n        for (let i = 0, len = a.length; i < len; i++) {\n            for (let k = 0, lenB = b.length; k < lenB; k++) {\n                result.push(op(a[i], b[k]));\n            }\n        }\n        return result;\n    }\n    /**\n     * Zip arrays. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]\n     * @param arrays an array of arrays\n     */\n    static zip(...arrays) {\n        let z = [];\n        for (let i = 0, len = arrays[0].length; i < len; i++) {\n            let p = [];\n            for (let k = 0; k < arrays.length; k++) {\n                p.push(arrays[k][i]);\n            }\n            z.push(p);\n        }\n        return z;\n    }\n    /**\n     * Create a convenient stepper. This returns a function which you can call repeatedly to step a counter.\n     * @param max Maximum of the stepper range. The resulting stepper will return (min to max-1) values.\n     * @param min Minimum of the stepper range. Default is 0.\n     * @param stride Stride of the step. Default is 1.\n     * @param callback An optional callback function( step ), which will be called each tiem when stepper function is called.\n     * @example `let counter = stepper(100); let c = counter(); c = counter(); ...`\n     * @returns a function which will increment the stepper and return its value at each call.\n     */\n    static stepper(max, min = 0, stride = 1, callback) {\n        let c = min;\n        return function () {\n            c += stride;\n            if (c >= max) {\n                c = min + (c - max);\n            }\n            if (callback)\n                callback(c);\n            return c;\n        };\n    }\n    /**\n     * A convenient way to step through a range. Same as `for (i=0; i<range; i++)`, except this also stores the resulting return values at each step and return them as an array.\n     * @param range a range to step through\n     * @param fn a callback function(index). If this function returns a value, it will be stored at each step\n     * @returns an array of returned values at each step\n     */\n    static forRange(fn, range, start = 0, step = 1) {\n        let temp = [];\n        for (let i = start, len = range; i < len; i += step) {\n            temp[i] = fn(i);\n        }\n        return temp;\n    }\n}\nUtil.warnLevel = \"default\";\nexports.Util = Util;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = __webpack_require__(1);\nconst Num_1 = __webpack_require__(3);\nconst Pt_1 = __webpack_require__(0);\nconst LinearAlgebra_1 = __webpack_require__(4);\nlet _errorLength = (obj, param = \"expected\") => Util_1.Util.warn(\"Group's length is less than \" + param, obj);\nlet _errorOutofBound = (obj, param = \"\") => Util_1.Util.warn(`Index ${param} is out of bound in Group`, obj);\n/**\n * Line class provides static functions to create and operate on lines. A line is usually represented as a Group of 2 Pts.\n * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.\n * See [Op guide](../../guide/Op-0400.html) for details.\n */\nclass Line {\n    /**\n     * Create a line by \"drawing\" from an anchor point, given an angle and a magnitude\n     * @param anchor an anchor Pt\n     * @param angle an angle in radian\n     * @param magnitude magnitude of the line\n     * @return a Group of 2 Pts representing a line segement\n     */\n    static fromAngle(anchor, angle, magnitude) {\n        let g = new Pt_1.Group(new Pt_1.Pt(anchor), new Pt_1.Pt(anchor));\n        g[1].toAngle(angle, magnitude, true);\n        return g;\n    }\n    /**\n     * Calculate the slope of a line\n     * @param p1 line's first end point\n     * @param p2 line's second end point\n     */\n    static slope(p1, p2) {\n        return (p2[0] - p1[0] === 0) ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n    /**\n     * Calculate the slope and xy intercepts of a line\n     * @param p1 line's first end point\n     * @param p2 line's second end point\n     * @returns an object with `slope`, `xi`, `yi` properties\n     */\n    static intercept(p1, p2) {\n        if (p2[0] - p1[0] === 0) {\n            return undefined;\n        }\n        else {\n            let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n            let c = p1[1] - m * p1[0];\n            return { slope: m, yi: c, xi: (m === 0) ? undefined : -c / m };\n        }\n    }\n    /**\n     * Given a 2D path and a point, find whether the point is on left or right side of the line\n     * @param line  a Group of at least 2 Pts\n     * @param pt a Pt\n     * @returns a negative value if on left and a positive value if on right. If collinear, then the return value is 0.\n     */\n    static sideOfPt2D(line, pt) {\n        return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n    }\n    /**\n     * Check if three Pts are collinear, ie, on the same straight path.\n     * @param p1 first Pt\n     * @param p2 second Pt\n     * @param p3 third Pt\n     * @param threshold a threshold where a smaller value means higher precision threshold for the straight line. Default is 0.01.\n     */\n    static collinear(p1, p2, p3, threshold = 0.01) {\n        // Use cross product method\n        let a = new Pt_1.Pt(0, 0, 0).to(p1).$subtract(p2);\n        let b = new Pt_1.Pt(0, 0, 0).to(p1).$subtract(p3);\n        return a.$cross(b).divide(1000).equals(new Pt_1.Pt(0, 0, 0), threshold);\n    }\n    /**\n     * Get magnitude of a line segment\n     * @param line a Group of at least 2 Pts\n     */\n    static magnitude(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitude() : 0;\n    }\n    /**\n     * Get squared magnitude of a line segment\n     * @param line a Group of at least 2 Pts\n     */\n    static magnitudeSq(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n    }\n    /**\n     * Find a point on a line that is perpendicular (shortest distance) to a target point\n     * @param pt a target Pt\n     * @param ln a group of Pts that defines a line\n     * @param asProjection if true, this returns the projection vector instead. Default is false.\n     * @returns a Pt on the line that is perpendicular to the target Pt, or a projection vector if `asProjection` is true.\n     */\n    static perpendicularFromPt(line, pt, asProjection = false) {\n        if (line[0].equals(line[1]))\n            return undefined;\n        let a = line[0].$subtract(line[1]);\n        let b = line[1].$subtract(pt);\n        let proj = b.$subtract(a.$project(b));\n        return (asProjection) ? proj : proj.$add(pt);\n    }\n    /**\n     * Given a line and a point, find the shortest distance from the point to the line\n     * @param line a Group of 2 Pts\n     * @param pt a Pt\n     * @see `Line.perpendicularFromPt`\n     */\n    static distanceFromPt(line, pt) {\n        return Line.perpendicularFromPt(line, pt, true).magnitude();\n    }\n    /**\n     * Given two lines as rays (infinite lines), find their intersection point if any.\n     * @param la a Group of 2 Pts representing a ray\n     * @param lb a Group of 2 Pts representing a ray\n     * @returns an intersection Pt or undefined if no intersection\n     */\n    static intersectRay2D(la, lb) {\n        let a = Line.intercept(la[0], la[1]);\n        let b = Line.intercept(lb[0], lb[1]);\n        let pa = la[0];\n        let pb = lb[0];\n        if (a == undefined) {\n            if (b == undefined)\n                return undefined;\n            // one of them is vertical line, while the other is not, so they will intersect\n            let y1 = -b.slope * (pb[0] - pa[0]) + pb[1]; // -slope * x + y\n            return new Pt_1.Pt(pa[0], y1);\n        }\n        else {\n            // diff slope, or b slope is vertical line\n            if (b == undefined) {\n                let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n                return new Pt_1.Pt(pb[0], y1);\n            }\n            else if (b.slope != a.slope) {\n                let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n                let py = a.slope * (px - pa[0]) + pa[1];\n                return new Pt_1.Pt(px, py);\n            }\n            else {\n                if (a.yi == b.yi) {\n                    return new Pt_1.Pt(pa[0], pa[1]);\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n    }\n    /**\n     * Given two line segemnts, find their intersection point if any.\n     * @param la a Group of 2 Pts representing a line segment\n     * @param lb a Group of 2 Pts representing a line segment\n     * @returns an intersection Pt or undefined if no intersection\n     */\n    static intersectLine2D(la, lb) {\n        let pt = Line.intersectRay2D(la, lb);\n        return (pt && Num_1.Geom.withinBound(pt, la[0], la[1]) && Num_1.Geom.withinBound(pt, lb[0], lb[1])) ? pt : undefined;\n    }\n    /**\n     * Given a line segemnt and a ray (infinite line), find their intersection point if any.\n     * @param line a Group of 2 Pts representing a line segment\n     * @param ray a Group of 2 Pts representing a ray\n     * @returns an intersection Pt or undefined if no intersection\n     */\n    static intersectLineWithRay2D(line, ray) {\n        let pt = Line.intersectRay2D(line, ray);\n        return (pt && Num_1.Geom.withinBound(pt, line[0], line[1])) ? pt : undefined;\n    }\n    /**\n     * Given a line segemnt and a ray (infinite line), find its intersection point(s) with a polygon.\n     * @param lineOrRay a Group of 2 Pts representing a line or ray\n     * @param poly a Group of Pts representing a polygon\n     * @param sourceIsRay a boolean value to treat the line as a ray (infinite line). Default is `false`.\n     */\n    static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n        let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        let pts = new Pt_1.Group();\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let d = fn(poly[i], lineOrRay);\n            if (d)\n                pts.push(d);\n        }\n        return (pts.length > 0) ? pts : undefined;\n    }\n    /**\n     * Get two intersection Pts of a ray with a 2D grid point\n     * @param ray a ray specified by 2 Pts\n     * @param gridPt a Pt on the grid\n     * @returns a group of two intersecting Pts. The first one is horizontal intersection and the second one is vertical intersection.\n     */\n    static intersectGridWithRay2D(ray, gridPt) {\n        let t = Line.intercept(new Pt_1.Pt(ray[0]).subtract(gridPt), new Pt_1.Pt(ray[1]).subtract(gridPt));\n        let g = new Pt_1.Group();\n        if (t && t.xi)\n            g.push(new Pt_1.Pt(gridPt[0] + t.xi, gridPt[1]));\n        if (t && t.yi)\n            g.push(new Pt_1.Pt(gridPt[0], gridPt[1] + t.yi));\n        return g;\n    }\n    /**\n     * Get two intersection Pts of a line segment with a 2D grid point\n     * @param ray a ray specified by 2 Pts\n     * @param gridPt a Pt on the grid\n     * @returns a group of two intersecting Pts. The first one is horizontal intersection and the second one is vertical intersection.\n     */\n    static intersectGridWithLine2D(line, gridPt) {\n        let g = Line.intersectGridWithRay2D(line, gridPt);\n        let gg = new Pt_1.Group();\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (Num_1.Geom.withinBound(g[i], line[0], line[1]))\n                gg.push(g[i]);\n        }\n        return gg;\n    }\n    /**\n     * Quick way to check rectangle intersection.\n     * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersect2D()`.\n     * @param line a Group representing a line\n     * @param rect a Group representing a rectangle\n     */\n    static intersectRect2D(line, rect) {\n        return Rectangle.intersectRect2D(Line.toRect(line), rect);\n    }\n    /**\n     * Get evenly distributed points on a line\n     * @param line a Group representing a line\n     * @param num number of points to get\n     */\n    static subpoints(line, num) {\n        let pts = new Pt_1.Group();\n        for (let i = 1; i <= num; i++) {\n            pts.push(Num_1.Geom.interpolate(line[0], line[1], i / (num + 1)));\n        }\n        return pts;\n    }\n    /**\n     * Crop this line by a circle or rectangle at end point.\n     * @param line line to crop\n     * @param size size of circle or rectangle as Pt\n     * @param index line's end point index, ie, 0 = start and 1 = end.\n     * @param cropAsCircle a boolean to specify whether the `size` parameter should be treated as circle. Default is `true`.\n     * @return an intersecting point on the line that can be used for cropping.\n     */\n    static crop(line, size, index = 0, cropAsCircle = true) {\n        let tdx = (index === 0) ? 1 : 0;\n        let ls = line[tdx].$subtract(line[index]);\n        if (ls[0] === 0 || size[0] === 0)\n            return line[index];\n        if (cropAsCircle) {\n            let d = ls.unit().multiply(size[1]);\n            return line[index].$add(d);\n        }\n        else {\n            let rect = Rectangle.fromCenter(line[index], size);\n            let sides = Rectangle.sides(rect);\n            let sideIdx = 0;\n            if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n                sideIdx = (ls[1] < 0) ? 0 : 2;\n            }\n            else {\n                sideIdx = (ls[0] < 0) ? 3 : 1;\n            }\n            return Line.intersectRay2D(sides[sideIdx], line);\n        }\n    }\n    /**\n     * Create an marker arrow or line, placed at an end point of this line\n     * @param line line to place marker\n     * @param size size of the marker as Pt\n     * @param graphic either \"arrow\" or \"line\"\n     * @param atTail a boolean, if `true`, the marker will be positioned at tail of the line (ie, index = 1). Default is `true`.\n     * @returns a Group that defines the marker's shape\n     */\n    static marker(line, size, graphic = (\"arrow\" || \"line\"), atTail = true) {\n        let h = atTail ? 0 : 1;\n        let t = atTail ? 1 : 0;\n        let unit = line[h].$subtract(line[t]);\n        if (unit.magnitudeSq() === 0)\n            return new Pt_1.Group();\n        unit.unit();\n        let ps = Num_1.Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n        if (graphic == \"arrow\") {\n            ps.add(unit.$multiply(size[1]));\n            return new Pt_1.Group(line[t], ps[0], ps[1]);\n        }\n        else {\n            return new Pt_1.Group(ps[0], ps[1]);\n        }\n    }\n    /**\n     * Convert this line to a rectangle representation\n     * @param line a Group representing a line\n     */\n    static toRect(line) {\n        return new Pt_1.Group(line[0].$min(line[1]), line[0].$max(line[1]));\n    }\n}\nexports.Line = Line;\n/**\n * Rectangle class provides static functions to create and operate on rectangles. A rectangle is usually represented as a Group of 2 Pts, marking the top-left and bottom-right corners of the rectangle.\n * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.\n * See [Op guide](../../guide/Op-0400.html) for details.\n */\nclass Rectangle {\n    /**\n     * Same as `Rectangle.fromTopLeft`\n     */\n    static from(topLeft, widthOrSize, height) {\n        return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n    }\n    /**\n     * Create a rectangle given a top-left position and a size\n     * @param topLeft top-left point\n     * @param widthOrSize width as a number, or a Pt that defines its size\n     * @param height optional height as a number\n     */\n    static fromTopLeft(topLeft, widthOrSize, height) {\n        let size = (typeof widthOrSize == \"number\") ? [widthOrSize, (height || widthOrSize)] : widthOrSize;\n        return new Pt_1.Group(new Pt_1.Pt(topLeft), new Pt_1.Pt(topLeft).add(size));\n    }\n    /**\n     * Create a rectangle given a center position and a size\n     * @param topLeft top-left point\n     * @param widthOrSize width as a number, or a Pt that defines its size\n     * @param height optional height as a number\n     */\n    static fromCenter(center, widthOrSize, height) {\n        let half = (typeof widthOrSize == \"number\") ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt_1.Pt(widthOrSize).divide(2);\n        return new Pt_1.Group(new Pt_1.Pt(center).subtract(half), new Pt_1.Pt(center).add(half));\n    }\n    /**\n     * Convert this rectangle to a circle that fits within the rectangle\n     * @returns a Group that represents a circle\n     * @see `Circle`\n     */\n    static toCircle(pts) {\n        return Circle.fromRect(pts);\n    }\n    /**\n     * Create a square that either fits within or encloses a rectangle\n     * @param pts a Group of 2 Pts representing a rectangle\n     * @param enclose if `true`, the square will enclose the rectangle. Default is `false`, which will fit the square inside the rectangle.\n     */\n    static toSquare(pts, enclose = false) {\n        let s = Rectangle.size(pts);\n        let m = (enclose) ? s.maxValue().value : s.minValue().value;\n        return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n    }\n    /**\n     * Get the size of this rectangle as a Pt\n     * @param pts a Group of 2 Pts representing a Rectangle\n     */\n    static size(pts) {\n        return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n    }\n    /**\n     * Get the center of this rectangle\n     * @param pts a Group of 2 Pts representing a Rectangle\n     */\n    static center(pts) {\n        let min = pts[0].$min(pts[1]);\n        let max = pts[0].$max(pts[1]);\n        return min.add(max.$subtract(min).divide(2));\n    }\n    /**\n     * Get the 4 corners of this rectangle as a Group\n     * @param rect a Group of 2 Pts representing a Rectangle\n     */\n    static corners(rect) {\n        let p0 = rect[0].$min(rect[1]);\n        let p2 = rect[0].$max(rect[1]);\n        return new Pt_1.Group(p0, new Pt_1.Pt(p2.x, p0.y), p2, new Pt_1.Pt(p0.x, p2.y));\n    }\n    /**\n     * Get the 4 sides of this rectangle as an array of 4 Groups\n     * @param rect a Group of 2 Pts representing a Rectangle\n     * @returns an array of 4 Groups, each of which represents a line segment\n     */\n    static sides(rect) {\n        let [p0, p1, p2, p3] = Rectangle.corners(rect);\n        return [\n            new Pt_1.Group(p0, p1), new Pt_1.Group(p1, p2),\n            new Pt_1.Group(p2, p3), new Pt_1.Group(p3, p0)\n        ];\n    }\n    /**\n     * Same as `Rectangle.sides`\n     */\n    static lines(rect) {\n        return Rectangle.sides(rect);\n    }\n    /**\n     * Given an array of rectangles, get a rectangle that bounds all of them\n     * @param rects an array of Groups that represent rectangles\n     * @returns the bounding rectangle as a Group\n     */\n    static boundingBox(rects) {\n        let merged = Util_1.Util.flatten(rects, false);\n        let min = Pt_1.Pt.make(2, Number.MAX_VALUE);\n        let max = Pt_1.Pt.make(2, Number.MIN_VALUE);\n        // calculate min max in a single pass\n        for (let i = 0, len = merged.length; i < len; i++) {\n            for (let k = 0; k < 2; k++) {\n                min[k] = Math.min(min[k], merged[i][k]);\n                max[k] = Math.max(max[k], merged[i][k]);\n            }\n        }\n        return new Pt_1.Group(min, max);\n    }\n    /**\n     * Convert this rectangle into a Group representing a polygon\n     * @param rect a Group of 2 Pts representing a Rectangle\n     */\n    static polygon(rect) {\n        return Rectangle.corners(rect);\n    }\n    /**\n     * Subdivide a rectangle into 4 rectangles, one for each quadrant\n     * @param rect a Group of 2 Pts representing a Rectangle\n     * @returns an array of 4 Groups of rectangles\n     */\n    static quadrants(rect, center) {\n        let corners = Rectangle.corners(rect);\n        let _center = (center != undefined) ? new Pt_1.Pt(center) : Rectangle.center(rect);\n        return corners.map((c) => new Pt_1.Group(c, _center).boundingBox());\n    }\n    /**\n     * Subdivde a rectangle into 2 rectangles, by row or by column\n     * @param rect Group of 2 Pts representing a Rectangle\n     * @param ratio a value between 0 to 1 to indicate the split ratio\n     * @param asRows if `true`, split into 2 rows. Default is `false` which splits into 2 columns.\n     * @returns an array of 2 Groups of rectangles\n     */\n    static halves(rect, ratio = 0.5, asRows = false) {\n        let min = rect[0].$min(rect[1]);\n        let max = rect[0].$max(rect[1]);\n        let mid = (asRows) ? Num_1.Num.lerp(min[1], max[1], ratio) : Num_1.Num.lerp(min[0], max[0], ratio);\n        return (asRows)\n            ? [new Pt_1.Group(min, new Pt_1.Pt(max[0], mid)), new Pt_1.Group(new Pt_1.Pt(min[0], mid), max)]\n            : [new Pt_1.Group(min, new Pt_1.Pt(mid, max[1])), new Pt_1.Group(new Pt_1.Pt(mid, min[1]), max)];\n    }\n    /**\n     * Check if a point is within a rectangle\n     * @param rect a Group of 2 Pts representing a Rectangle\n     * @param pt the point to check\n     */\n    static withinBound(rect, pt) {\n        return Num_1.Geom.withinBound(pt, rect[0], rect[1]);\n    }\n    /**\n     * Check if a rectangle is within the bounds of another rectangle\n     * @param rect1 a Group of 2 Pts representing a rectangle\n     * @param rect2 a Group of 2 Pts representing a rectangle\n     */\n    static hasIntersectRect2D(rect1, rect2) {\n        let pts = Rectangle.corners(rect1);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (Num_1.Geom.withinBound(pts[i], rect2[0], rect2[1]))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Quick way to check rectangle intersection.\n     * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersect2D()`.\n     * @param rect1 a Group of 2 Pts representing a rectangle\n     * @param rect2 a Group of 2 Pts representing a rectangle\n     */\n    static intersectRect2D(rect1, rect2) {\n        return Util_1.Util.flatten(Polygon.intersect2D(Rectangle.sides(rect1), Rectangle.sides(rect2)));\n    }\n}\nexports.Rectangle = Rectangle;\n/**\n * Circle class provides static functions to create and operate on circles. A circle is usually represented as a Group of 2 Pts, where the first Pt specifies the center, and the second Pt specifies the radius.\n * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.\n * See [Op guide](../../guide/Op-0400.html) for details.\n */\nclass Circle {\n    /**\n     * Create a circle that either fits within or encloses a rectangle\n     * @param pts a Group of 2 Pts representing a rectangle\n     * @param enclose if `true`, the circle will enclose the rectangle. Default is `false`, which will fit the circle inside the rectangle.\n     */\n    static fromRect(pts, enclose = false) {\n        let r = 0;\n        let min = r = Rectangle.size(pts).minValue().value / 2;\n        if (enclose) {\n            let max = Rectangle.size(pts).maxValue().value / 2;\n            r = Math.sqrt(min * min + max * max);\n        }\n        else {\n            r = min;\n        }\n        return new Pt_1.Group(Rectangle.center(pts), new Pt_1.Pt(r, r));\n    }\n    /**\n     * Create a circle based on a center point and a radius\n     * @param pt center point of circle\n     * @param radius radius of circle\n     */\n    static fromCenter(pt, radius) {\n        return new Pt_1.Group(new Pt_1.Pt(pt), new Pt_1.Pt(radius, radius));\n    }\n    /**\n     * Check if a point is within a circle\n     * @param pts a Group of 2 Pts representing a circle\n     * @param pt the point to checks\n     * @param threshold an optional small number to set threshold. Default is 0.\n     */\n    static withinBound(pts, pt, threshold = 0) {\n        let d = pts[0].$subtract(pt);\n        return d.dot(d) + threshold < pts[1].x * pts[1].x;\n    }\n    /**\n     * Get the intersection points between a circle and a ray (infinite line)\n     * @param pts a Group of 2 Pts representing a circle\n     * @param ray a Group of 2 Pts representing a ray\n     * @returns a Group of intersection points, or an empty Group if no intersection is found\n     */\n    static intersectRay2D(pts, ray) {\n        let d = ray[0].$subtract(ray[1]);\n        let f = pts[0].$subtract(ray[0]);\n        let a = d.dot(d);\n        let b = f.dot(d);\n        let c = f.dot(f) - pts[1].x * pts[1].x;\n        let p = b / a;\n        let q = c / a;\n        let disc = p * p - q; // discriminant\n        if (disc < 0) {\n            return new Pt_1.Group();\n        }\n        else {\n            let discSqrt = Math.sqrt(disc);\n            let t1 = -p + discSqrt;\n            let p1 = ray[0].$subtract(d.$multiply(t1));\n            if (disc === 0)\n                return new Pt_1.Group(p1);\n            let t2 = -p - discSqrt;\n            let p2 = ray[0].$subtract(d.$multiply(t2));\n            return new Pt_1.Group(p1, p2);\n        }\n    }\n    /**\n     * Get the intersection points between a circle and a line segment\n     * @param pts a Group of 2 Pts representing a circle\n     * @param ray a Group of 2 Pts representing a line\n     * @returns a Group of intersection points, or an empty Group if no intersection is found\n     */\n    static intersectLine2D(pts, line) {\n        let ps = Circle.intersectRay2D(pts, line);\n        let g = new Pt_1.Group();\n        if (ps.length > 0) {\n            for (let i = 0, len = ps.length; i < len; i++) {\n                if (Rectangle.withinBound(line, ps[i]))\n                    g.push(ps[i]);\n            }\n        }\n        return g;\n    }\n    /**\n     * Get the intersection points between two circles\n     * @param pts a Group of 2 Pts representing a circle\n     * @param circle a Group of 2 Pts representing a circle\n     * @returns a Group of intersection points, or an empty Group if no intersection is found\n     */\n    static intersectCircle2D(pts, circle) {\n        let dv = circle[0].$subtract(pts[0]);\n        let dr2 = dv.magnitudeSq();\n        let dr = Math.sqrt(dr2);\n        let ar = pts[1].x;\n        let br = circle[1].x;\n        let ar2 = ar * ar;\n        let br2 = br * br;\n        if (dr > ar + br) {\n            return new Pt_1.Group();\n        }\n        else if (dr < Math.abs(ar - br)) {\n            return new Pt_1.Group(pts[0].clone());\n        }\n        else {\n            let a = (ar2 - br2 + dr2) / (2 * dr);\n            let h = Math.sqrt(ar2 - a * a);\n            let p = dv.$multiply(a / dr).add(pts[0]);\n            return new Pt_1.Group(new Pt_1.Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt_1.Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n        }\n    }\n    /**\n     * Quick way to check rectangle intersection with a circle.\n     * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersect2D()`.\n     * @param pts a Group of 2 Pts representing a circle\n     * @param rect a Group of 2 Pts representing a rectangle\n     * @returns a Group of intersection points, or an empty Group if no intersection is found\n     */\n    static intersectRect2D(pts, rect) {\n        let sides = Rectangle.sides(rect);\n        let g = [];\n        for (let i = 0, len = sides.length; i < len; i++) {\n            let ps = Circle.intersectLine2D(pts, sides[i]);\n            if (ps.length > 0)\n                g.push(ps);\n        }\n        return Util_1.Util.flatten(g);\n    }\n    /**\n     * Convert this cirlce to a rectangle that encloses this circle\n     * @param pts a Group of 2 Pts representing a circle\n     */\n    static toRect(pts) {\n        let r = pts[1][0];\n        return new Pt_1.Group(pts[0].$subtract(r), pts[0].$add(r));\n    }\n    /**\n     * Convert this cirlce to a rectangle that fits within this circle\n     * @param pts a Group of 2 Pts representing a circle\n     */\n    static toInnerRect(pts) {\n        let r = pts[1][0];\n        let half = Math.sqrt(r * r) / 2;\n        return new Pt_1.Group(pts[0].$subtract(half), pts[0].$add(half));\n    }\n    /**\n     * Convert this cirlce to a triangle that fits within this circle\n     * @param pts a Group of 2 Pts representing a circle\n     */\n    static toInnerTriangle(pts) {\n        let ang = -Math.PI / 2;\n        let inc = Math.PI * 2 / 3;\n        let g = new Pt_1.Group();\n        for (let i = 0; i < 3; i++) {\n            g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n            ang += inc;\n        }\n        return g;\n    }\n}\nexports.Circle = Circle;\n/**\n * Triangle class provides static functions to create and operate on trianges. A triange is usually represented as a Group of 3 Pts.\n * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.\n * See [Op guide](../../guide/Op-0400.html) for details.\n */\nclass Triangle {\n    /**\n     * Create a triangle from a rectangle. The triangle will be isosceles, with the bottom of the rectangle as its base.\n     * @param rect a Group of 2 Pts representing a rectangle\n     */\n    static fromRect(rect) {\n        let top = rect[0].$add(rect[1]).divide(2);\n        top.y = rect[0][1];\n        let left = rect[1].clone();\n        left.x = rect[0][0];\n        return new Pt_1.Group(top, rect[1].clone(), left);\n    }\n    /**\n     * Create a triangle that fits within a circle\n     * @param circle a Group of 2 Pts representing a circle\n     */\n    static fromCircle(circle) {\n        return Circle.toInnerTriangle(circle);\n    }\n    /**\n     * Create an equilateral triangle based on a center point and a size\n     * @param pt the center point\n     * @param size size is the magnitude of lines from center to the triangle's vertices, like a \"radius\".\n     */\n    static fromCenter(pt, size) {\n        return Triangle.fromCircle(Circle.fromCenter(pt, size));\n    }\n    /**\n     * Get the medial, which is an inner triangle formed by connecting the midpoints of this triangle's sides\n     * @param pts a Group of Pts\n     * @returns a Group representing a medial triangle\n     */\n    static medial(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Pt_1.Group(), 3);\n        return Polygon.midpoints(pts, true);\n    }\n    /**\n     * Given a point of the triangle, the opposite side is the side which the point doesn't touch.\n     * @param pts a Group of Pts\n     * @param index a Pt on the triangle group\n     * @returns a Group that represents a line of the opposite side\n     */\n    static oppositeSide(pts, index) {\n        if (pts.length < 3)\n            return _errorLength(new Pt_1.Group(), 3);\n        if (index === 0) {\n            return Pt_1.Group.fromPtArray([pts[1], pts[2]]);\n        }\n        else if (index === 1) {\n            return Pt_1.Group.fromPtArray([pts[0], pts[2]]);\n        }\n        else {\n            return Pt_1.Group.fromPtArray([pts[0], pts[1]]);\n        }\n    }\n    /**\n     * Get a triangle's altitude, which is a line from a triangle's point to its opposite side, and perpendicular to its opposite side.\n     * @param pts a Group of Pts\n     * @param index a Pt on the triangle group\n     * @returns a Group that represents the altitude line\n     */\n    static altitude(pts, index) {\n        let opp = Triangle.oppositeSide(pts, index);\n        if (opp.length > 1) {\n            return new Pt_1.Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n        }\n        else {\n            return new Pt_1.Group();\n        }\n    }\n    /**\n     * Get orthocenter, which is the intersection point of a triangle's 3 altitudes (the 3 lines that are perpendicular to its 3 opposite sides).\n     * @param pts a Group of Pts\n     * @returns the orthocenter as a Pt\n     */\n    static orthocenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Triangle.altitude(pts, 0);\n        let b = Triangle.altitude(pts, 1);\n        return Line.intersectRay2D(a, b);\n    }\n    /**\n     * Get incenter, which is the center point of its inner circle, and also the intersection point of its 3 angle bisector lines (each of which cuts one of the 3 angles in half).\n     * @param pts a Group of Pts\n     * @returns the incenter as a Pt\n     */\n    static incenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Polygon.bisector(pts, 0).add(pts[0]);\n        let b = Polygon.bisector(pts, 1).add(pts[1]);\n        return Line.intersectRay2D(new Pt_1.Group(pts[0], a), new Pt_1.Group(pts[1], b));\n    }\n    /**\n     * Get an interior circle, which is the largest circle completed enclosed by this triangle\n     * @param pts a Group of Pts\n     * @param center Optional parameter if the incenter is already known. Otherwise, leave it empty and the incenter will be calculated\n     */\n    static incircle(pts, center) {\n        let c = (center) ? center : Triangle.incenter(pts);\n        let area = Polygon.area(pts);\n        let perim = Polygon.perimeter(pts, true);\n        let r = 2 * area / perim.total;\n        return Circle.fromCenter(c, r);\n    }\n    /**\n     * Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)\n     * @param pts a Group of Pts\n     * @returns the circumcenter as a Pt\n     */\n    static circumcenter(pts) {\n        let md = Triangle.medial(pts);\n        let a = [md[0], Num_1.Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n        let b = [md[1], Num_1.Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n        return Line.intersectRay2D(a, b);\n    }\n    /**\n     * Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)\n     * @param pts a Group of Pts\n     * @param center Optional parameter if the circumcenter is already known. Otherwise, leave it empty and the circumcenter will be calculated\n     */\n    static circumcircle(pts, center) {\n        let c = (center) ? center : Triangle.circumcenter(pts);\n        let r = pts[0].$subtract(c).magnitude();\n        return Circle.fromCenter(c, r);\n    }\n}\nexports.Triangle = Triangle;\n/**\n * Polygon class provides static functions to create and operate on polygons. A polygon is usually represented as a Group of 3 or more Pts.\n * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.\n * See [Op guide](../../guide/Op-0400.html) for details.\n */\nclass Polygon {\n    /**\n     * Get the centroid of a polygon, which is the average of all its points.\n     * @param pts a Group of Pts representing a polygon\n     */\n    static centroid(pts) {\n        return Num_1.Geom.centroid(pts);\n    }\n    /**\n     * Get the line segments in this polygon\n     * @param pts a Group of Pts\n     * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).\n     * @returns an array of Groups which has 2 Pts in each group\n     */\n    static lines(pts, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Pt_1.Group(), 2);\n        let sp = Util_1.Util.split(pts, 2, 1);\n        if (closePath)\n            sp.push(new Pt_1.Group(pts[pts.length - 1], pts[0]));\n        return sp.map((g) => g);\n    }\n    /**\n     * Get a new polygon group that is derived from midpoints in this polygon\n     * @param pts a Group of Pts\n     * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).\n     * @param t a value between 0 to 1 for interpolation. Default to 0.5 which will get the middle point.\n     */\n    static midpoints(pts, closePath = false, t = 0.5) {\n        if (pts.length < 2)\n            return _errorLength(new Pt_1.Group(), 2);\n        let sides = Polygon.lines(pts, closePath);\n        let mids = sides.map((s) => Num_1.Geom.interpolate(s[0], s[1], t));\n        return mids;\n    }\n    /**\n     * Given a Pt in the polygon group, the adjacent sides are the two sides which the Pt touches.\n     * @param pts a group of Pts\n     * @param index the target Pt\n     * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).\n     */\n    static adjacentSides(pts, index, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Pt_1.Group(), 2);\n        if (index < 0 || index >= pts.length)\n            return _errorOutofBound(new Pt_1.Group(), index);\n        let gs = [];\n        let left = index - 1;\n        if (closePath && left < 0)\n            left = pts.length - 1;\n        if (left >= 0)\n            gs.push(new Pt_1.Group(pts[index], pts[left]));\n        let right = index + 1;\n        if (closePath && right > pts.length - 1)\n            right = 0;\n        if (right <= pts.length - 1)\n            gs.push(new Pt_1.Group(pts[index], pts[right]));\n        return gs;\n    }\n    /**\n     * Get a bisector which is a line that split between two sides of a polygon equally.\n     * @param pts a group of Pts\n     * @param index the Pt in the polygon to bisect from\n     * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).\n     * @returns a bisector Pt that's a normalized unit vector\n     */\n    static bisector(pts, index) {\n        let sides = Polygon.adjacentSides(pts, index, true);\n        if (sides.length >= 2) {\n            let a = sides[0][1].$subtract(sides[0][0]).unit();\n            let b = sides[1][1].$subtract(sides[1][0]).unit();\n            return a.add(b).divide(2);\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Find the perimeter of this polygon, ie, the lengths of its sides.\n     * @param pts a group of Pts\n     * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).\n     * @returns an object with `total` length, and `segments` which is a Pt that stores each segment's length\n     */\n    static perimeter(pts, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Pt_1.Group(), 2);\n        let lines = Polygon.lines(pts, closePath);\n        let mag = 0;\n        let p = Pt_1.Pt.make(lines.length, 0);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            let m = Line.magnitude(lines[i]);\n            mag += m;\n            p[i] = m;\n        }\n        return {\n            total: mag,\n            segments: p\n        };\n    }\n    /**\n     * Find the area of a *convex* polygon.\n     * @param pts a group of Pts\n     */\n    static area(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Pt_1.Group(), 3);\n        // determinant\n        let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n        let area = 0;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i < pts.length - 1) {\n                area += det(pts[i], pts[i + 1]);\n            }\n            else {\n                area += det(pts[i], pts[0]);\n            }\n        }\n        return Math.abs(area / 2);\n    }\n    /**\n     * Get a convex hull of the point set using Melkman's algorithm\n     * (Reference: http://geomalgorithms.com/a12-_hull-3.html)\n     * @param pts a group of Pt\n     * @param sorted a boolean value to indicate if the group is pre-sorted by x position. Default is false.\n     * @returns a group of Pt that defines the convex hull polygon\n     */\n    static convexHull(pts, sorted = false) {\n        if (pts.length < 3)\n            return _errorLength(new Pt_1.Group(), 3);\n        if (!sorted) {\n            pts = pts.slice();\n            pts.sort((a, b) => a[0] - b[0]);\n        }\n        // check if is on left of ray a-b\n        let left = (a, b, c) => {\n            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n        };\n        // double end queue\n        let dq = [];\n        let bot = pts.length - 2;\n        let top = bot + 3;\n        dq[bot] = pts[2];\n        dq[top] = pts[2];\n        // first 3 pt as counter-clockwise triangle\n        if (left(pts[0], pts[1], pts[2])) {\n            dq[bot + 1] = pts[0];\n            dq[bot + 2] = pts[1];\n        }\n        else {\n            dq[bot + 1] = pts[1];\n            dq[bot + 2] = pts[0];\n        }\n        // remaining pts\n        for (let i = 3, len = pts.length; i < len; i++) {\n            let pt = pts[i];\n            // if inside the hull\n            if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n                continue;\n            }\n            // rightmost tangent\n            while (!left(dq[bot], dq[bot + 1], pt)) {\n                bot += 1;\n            }\n            bot -= 1;\n            dq[bot] = pt;\n            // leftmost tangent\n            while (!left(dq[top - 1], dq[top], pt)) {\n                top -= 1;\n            }\n            top += 1;\n            dq[top] = pt;\n        }\n        let hull = new Pt_1.Group();\n        for (let h = 0; h < (top - bot); h++) {\n            hull.push(dq[bot + h]);\n        }\n        return hull;\n    }\n    /**\n     * Find intersection points of 2 polygons\n     * @param poly a Group representing a polygon\n     * @param linesOrRays an array of Groups representing lines\n     * @param sourceIsRay a boolean value to treat the line as a ray (infinite line). Default is `false`.\n     */\n    static intersect2D(poly, linesOrRays, sourceIsRay = false) {\n        let groups = [];\n        for (let i = 0, len = linesOrRays.length; i < len; i++) {\n            let _ip = Line.intersectPolygon2D(linesOrRays[i], poly, sourceIsRay);\n            if (_ip)\n                groups.push(_ip);\n        }\n        return groups;\n    }\n    /**\n     * Given a point in the polygon as an origin, get an array of lines that connect all the remaining points to the origin point.\n     * @param pts a Group representing a polygon\n     * @param originIndex the origin point's index in the polygon\n     */\n    static network(pts, originIndex = 0) {\n        let g = [];\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i != originIndex)\n                g.push(new Pt_1.Group(pts[originIndex], pts[i]));\n        }\n        return g;\n    }\n    /**\n     * Given a target Pt, find a Pt in a Group that's nearest to it.\n     * @param pts a Group of Pt\n     * @param pt Pt to check\n     * @returns an index in the pts indicating the nearest Pt, or -1 if none found\n     */\n    static nearestPt(pts, pt) {\n        let _near = Number.MAX_VALUE;\n        let _item = -1;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let d = pts[i].$subtract(pt).magnitudeSq();\n            if (d < _near) {\n                _near = d;\n                _item = i;\n            }\n        }\n        return _item;\n    }\n    /**\n     * Get a bounding box for each polygon group, as well as a union bounding-box for all groups\n     * @param polys an array of Groups, or an array of Pt arrays\n     */\n    static toRects(poly) {\n        let boxes = poly.map((g) => Num_1.Geom.boundingBox(g));\n        let merged = Util_1.Util.flatten(boxes, false);\n        boxes.unshift(Num_1.Geom.boundingBox(merged));\n        return boxes;\n    }\n}\nexports.Polygon = Polygon;\n/**\n * Curve class provides static functions to interpolate curves. A curve is usually represented as a Group of 3 control points.\n * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.\n * See [Op guide](../../guide/Op-0400.html) for details.\n */\nclass Curve {\n    /**\n     * Get a precalculated coefficients per step\n     * @param steps number of steps\n     */\n    static getSteps(steps) {\n        let ts = new Pt_1.Group();\n        for (let i = 0; i <= steps; i++) {\n            let t = i / steps;\n            ts.push(new Pt_1.Pt(t * t * t, t * t, t, 1));\n        }\n        return ts;\n    }\n    /**\n     * Given an index for the starting position in a Pt group, get the control and/or end points of a curve segment\n     * @param pts a group of Pt\n     * @param index start index in `pts` array. Default is 0.\n     * @param copyStart an optional boolean value to indicate if the start index should be used twice. Default is false.\n     * @returns a group of 4 Pts\n     */\n    static controlPoints(pts, index = 0, copyStart = false) {\n        if (index > pts.length - 1)\n            return new Pt_1.Group();\n        let _index = (i) => (i < pts.length - 1) ? i : pts.length - 1;\n        let p0 = pts[index];\n        index = (copyStart) ? index : index + 1;\n        // get points based on index\n        return new Pt_1.Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n    }\n    /**\n     * Calulcate weighted sum to get the interpolated points\n     * @param ctrls anchors\n     * @param params parameters\n     */\n    static _calcPt(ctrls, params) {\n        let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n        let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n        if (ctrls[0].length > 2) {\n            let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n            return new Pt_1.Pt(x, y, z);\n        }\n        return new Pt_1.Pt(x, y);\n    }\n    /**\n     * Create a Catmull-Rom curve. Catmull-Rom is a kind of Cardinal curve with smooth-looking curve.\n     * @param pts a group of anchor Pt\n     * @param steps the number of line segments per curve. Defaults to 10 steps.\n     * @returns a curve as a group of interpolated Pt\n     */\n    static catmullRom(pts, steps = 10) {\n        if (pts.length < 2)\n            return new Pt_1.Group();\n        let ps = new Pt_1.Group();\n        let ts = Curve.getSteps(steps);\n        // use first point twice\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.catmullRomStep(ts[i], c));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.catmullRomStep(ts[i], cp));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    /**\n     * Interpolate to get a point on Catmull-Rom curve\n     * @param step the coefficients [t*t*t, t*t, t, 1]\n     * @param ctrls a group of anchor Pts\n     * @return an interpolated Pt on the curve\n     */\n    static catmullRomStep(step, ctrls) {\n        /*\n        * Basis Matrix (http://mrl.nyu.edu/~perlin/courses/fall2002/hw/12.html)\n        * [-0.5,  1.5, -1.5, 0.5],\n        * [ 1  , -2.5,  2  ,-0.5],\n        * [-0.5,  0  ,  0.5, 0  ],\n        * [ 0  ,  1  ,  0  , 0  ]\n        */\n        let m = new Pt_1.Group(new Pt_1.Pt(-0.5, 1, -0.5, 0), new Pt_1.Pt(1.5, -2.5, 0, 1), new Pt_1.Pt(-1.5, 2, 0.5, 0), new Pt_1.Pt(0.5, -0.5, 0, 0));\n        return Curve._calcPt(ctrls, LinearAlgebra_1.Mat.multiply([step], m, true)[0]);\n    }\n    /**\n     * Create a Cardinal spline curve\n     * @param pts a group of anchor Pt\n     * @param steps the number of line segments per curve. Defaults to 10 steps.\n     * @param tension optional value between 0 to 1 to specify a \"tension\". Default to 0.5 which is the tension for Catmull-Rom curve.\n     * @returns a curve as a group of interpolated Pt\n     */\n    static cardinal(pts, steps = 10, tension = 0.5) {\n        if (pts.length < 2)\n            return new Pt_1.Group();\n        let ps = new Pt_1.Group();\n        let ts = Curve.getSteps(steps);\n        // use first point twice\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.cardinalStep(ts[i], c, tension));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.cardinalStep(ts[i], cp, tension));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    /**\n     * Interpolate to get a point on Catmull-Rom curve\n     * @param step the coefficients [t*t*t, t*t, t, 1]\n     * @param ctrls a group of anchor Pts\n     * @param tension optional value between 0 to 1 to specify a \"tension\". Default to 0.5 which is the tension for Catmull-Rom curve\n     * @return an interpolated Pt on the curve\n     */\n    static cardinalStep(step, ctrls, tension = 0.5) {\n        /*\n        * Basis Matrix (http://algorithmist.wordpress.com/2009/10/06/cardinal-splines-part-4/)\n        * [ -s  2-s  s-2   s ]\n        * [ 2s  s-3  3-2s -s ]\n        * [ -s   0    s    0 ]\n        * [  0   1    0    0 ]\n        */\n        let m = new Pt_1.Group(new Pt_1.Pt(-1, 2, -1, 0), new Pt_1.Pt(-1, 1, 0, 0), new Pt_1.Pt(1, -2, 1, 0), new Pt_1.Pt(1, -1, 0, 0));\n        let h = LinearAlgebra_1.Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n    /**\n     * Create a Bezier curve. In a cubic bezier curve, the first and 4th anchors are end-points, and 2nd and 3rd anchors are control-points.\n     * @param pts a group of anchor Pt\n     * @param steps the number of line segments per curve. Defaults to 10 steps.\n     * @returns a curve as a group of interpolated Pt\n     */\n    static bezier(pts, steps = 10) {\n        if (pts.length < 4)\n            return new Pt_1.Group();\n        let ps = new Pt_1.Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.bezierStep(ts[i], c));\n                }\n                // go to the next set of point, but assume current end pt is next start pt\n                k += 3;\n            }\n        }\n        return ps;\n    }\n    /**\n     * Interpolate to get a point on a cubic Bezier curve\n     * @param step the coefficients [t*t*t, t*t, t, 1]\n     * @param ctrls a group of anchor Pts\n     * @return an interpolated Pt on the curve\n     */\n    static bezierStep(step, ctrls) {\n        /*\n        * Bezier basis matrix\n        * [ -1,  3, -3,  1 ]\n        * [  3, -6,  3,  0 ]\n        * [ -3,  3,  0,  0 ]\n        * [  1,  0,  0,  0 ]\n        */\n        let m = new Pt_1.Group(new Pt_1.Pt(-1, 3, -3, 1), new Pt_1.Pt(3, -6, 3, 0), new Pt_1.Pt(-3, 3, 0, 0), new Pt_1.Pt(1, 0, 0, 0));\n        return Curve._calcPt(ctrls, LinearAlgebra_1.Mat.multiply([step], m, true)[0]);\n    }\n    /**\n     * Create a B-spline curve\n     * @param pts a group of anchor Pt\n     * @param steps the number of line segments per curve. Defaults to 10 steps.\n     * @param tension optional value between 0 to n to specify a \"tension\". Default is 1 which is the usual tension.\n     * @returns a curve as a group of interpolated Pt\n     */\n    static bspline(pts, steps = 10, tension = 1) {\n        if (pts.length < 2)\n            return new Pt_1.Group();\n        let ps = new Pt_1.Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                if (tension !== 1) {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n                    }\n                }\n                else {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineStep(ts[i], c));\n                    }\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    /**\n     * Interpolate to get a point on a B-spline curve\n     * @param step the coefficients [t*t*t, t*t, t, 1]\n     * @param ctrls a group of anchor Pts\n     * @return an interpolated Pt on the curve\n     */\n    static bsplineStep(step, ctrls) {\n        /*\n        * Basis matrix:\n        * [ -1.0/6.0,  3.0/6.0, -3.0/6.0, 1.0/6.0 ],\n        * [  3.0/6.0, -6.0/6.0,  3.0/6.0,    0.0 ],\n        * [ -3.0/6.0,      0.0,  3.0/6.0,    0.0 ],\n        * [  1.0/6.0,  4.0/6.0,  1.0/6.0,    0.0 ]\n        */\n        let m = new Pt_1.Group(new Pt_1.Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt_1.Pt(0.5, -1, 0, 0.6666666666666666), new Pt_1.Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt_1.Pt(0.16666666666666666, 0, 0, 0));\n        return Curve._calcPt(ctrls, LinearAlgebra_1.Mat.multiply([step], m, true)[0]);\n    }\n    /**\n     * Interpolate to get a point on a B-spline curve\n     * @param step the coefficients [t*t*t, t*t, t, 1]\n     * @param ctrls a group of anchor Pts\n     * @param tension optional value between 0 to n to specify a \"tension\". Default to 1 which is the usual tension.\n     * @return an interpolated Pt on the curve\n     */\n    static bsplineTensionStep(step, ctrls, tension = 1) {\n        /*\n        * Basis matrix:\n        * [ -1/6a, 2 - 1.5a, 1.5a - 2, 1/6a ]\n        * [ 0.5a,  2a-3,     3-2.5a    0 ]\n        * [ -0.5a, 0,        0.5a,     0 ]\n        * [ 1/6a,  1 - 1/3a, 1/6a,     0 ]\n        */\n        let m = new Pt_1.Group(new Pt_1.Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt_1.Pt(-1.5, 2, 0, -0.3333333333333333), new Pt_1.Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt_1.Pt(0.16666666666666666, 0, 0, 0));\n        let h = LinearAlgebra_1.Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n}\nexports.Curve = Curve;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = __webpack_require__(1);\nconst Op_1 = __webpack_require__(2);\nconst Pt_1 = __webpack_require__(0);\nconst LinearAlgebra_1 = __webpack_require__(4);\n/**\n * Num class provides various helper functions for basic numeric operations\n */\nclass Num {\n    /**\n     * Check if two numbers are equal or almost equal within a threshold\n     * @param a number a\n     * @param b number b\n     * @param threshold a threshold within which the two numbers are considered equal\n     */\n    static equals(a, b, threshold = 0.00001) {\n        return Math.abs(a - b) < threshold;\n    }\n    /**\n     * Linear interpolation\n     * @param a start value\n     * @param b end value\n     * @param t usually a value between 0 to 1\n     */\n    static lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n    }\n    /**\n     * Clamp values between min and max\n     * @param val value to clamp\n     * @param min min value\n     * @param max max value\n     */\n    static clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    }\n    /**\n     * Different from Num.clamp in that the value out-of-bound will be \"looped back\" to the other end.\n     * @param val value to bound\n     * @param min min value\n     * @param max max value\n     * @example `boundValue(361, 0, 360)` will return 1\n     */\n    static boundValue(val, min, max) {\n        let len = Math.abs(max - min);\n        let a = val % len;\n        if (a > max)\n            a -= len;\n        else if (a < min)\n            a += len;\n        return a;\n    }\n    /**\n     * Check if a value is within\n     * @param p\n     * @param a\n     * @param b\n     */\n    static within(p, a, b) {\n        return p >= Math.min(a, b) && p <= Math.max(a, b);\n    }\n    /**\n     * Get a random number within a range\n     * @param a range value 1\n     * @param b range value 2\n     */\n    static randomRange(a, b = 0) {\n        let r = (a > b) ? (a - b) : (b - a);\n        return a + Math.random() * r;\n    }\n    /**\n     * Normalize a value within a range\n     * @param n the value to normalize\n     * @param a range value 1\n     * @param b range value 1\n     */\n    static normalizeValue(n, a, b) {\n        let min = Math.min(a, b);\n        let max = Math.max(a, b);\n        return (n - min) / (max - min);\n    }\n    /**\n     * Sum a group of numeric arrays\n     * @param pts an array of numeric arrays\n     * @returns a array of sums\n     */\n    static sum(pts) {\n        let c = new Pt_1.Pt(pts[0]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            LinearAlgebra_1.Vec.add(c, pts[i]);\n        }\n        return c;\n    }\n    /**\n     * Sum a group of numeric arrays\n     * @param pts an array of numeric arrays\n     * @returns a array of sums\n     */\n    static average(pts) {\n        return Num.sum(pts).divide(pts.length);\n    }\n    /**\n     * Given a value between 0 to 1, returns a value that cycles between 0 -> 1 -> 0 using sine method.\n     * @param t a value between 0 to 1\n     * @return a value between 0 to 1\n     */\n    static cycle(t) {\n        return (Math.sin(Math.PI * 2 * t) + 1) / 2;\n    }\n    /**\n     * Map a value from one range to another\n     * @param n a value in the first range\n     * @param currMin lower bound of the first range\n     * @param currMax upper bound of the first range\n     * @param targetMin lower bound of the second range\n     * @param targetMax upper bound of the second range\n     * @returns a remapped value in the second range\n     */\n    static mapToRange(n, currA, currB, targetA, targetB) {\n        if (currA == currB)\n            throw new Error(\"[currMin, currMax] must define a range that is not zero\");\n        let min = Math.min(targetA, targetB);\n        let max = Math.max(targetA, targetB);\n        return Num.normalizeValue(n, currA, currB) * (max - min) + min;\n    }\n}\nexports.Num = Num;\n/**\n * Geom class provides various helper functions for basic geometric operations\n */\nclass Geom {\n    /**\n     * Bound an angle between 0 to 360 degrees\n     */\n    static boundAngle(angle) {\n        return Num.boundValue(angle, 0, 360);\n    }\n    /**\n     * Bound a radian between 0 to 2-PI\n     */\n    static boundRadian(angle) {\n        return Num.boundValue(angle, 0, Util_1.Const.two_pi);\n    }\n    /**\n     * Convert an angle in degree to radian\n     */\n    static toRadian(angle) {\n        return angle * Util_1.Const.deg_to_rad;\n    }\n    /**\n     * Convert an angle in radian to degree\n     */\n    static toDegree(radian) {\n        return radian * Util_1.Const.rad_to_deg;\n    }\n    /**\n     * Get a bounding box for a set of Pts\n     * @param pts a Group or an array of Pts\n     * @return a Group of two Pts, representing the top-left and bottom-right corners.\n     */\n    static boundingBox(pts) {\n        let minPt = pts.reduce((a, p) => a.$min(p));\n        let maxPt = pts.reduce((a, p) => a.$max(p));\n        return new Pt_1.Group(minPt, maxPt);\n    }\n    /**\n     * Get a centroid (the average middle point) for a set of Pts\n     * @param pts a Group or an array of Pts\n     * @return a centroid Pt\n     */\n    static centroid(pts) {\n        return Num.average(pts);\n    }\n    /**\n     * Given an anchor Pt, rebase all Pts in this group either to or from this anchor base.\n     * @param pts a Group or array of Pt\n     * @param ptOrIndex an index for the Pt array, or an external Pt\n     * @param direction \"to\" (subtract all Pt with this anchor base) or \"from\" (add all Pt from this anchor base)\n     */\n    static anchor(pts, ptOrIndex = 0, direction = \"to\") {\n        let method = (direction == \"to\") ? \"subtract\" : \"add\";\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (typeof ptOrIndex == \"number\") {\n                if (ptOrIndex !== i)\n                    pts[i][method](pts[ptOrIndex]);\n            }\n            else {\n                pts[i][method](ptOrIndex);\n            }\n        }\n    }\n    /**\n     * Get an interpolated (or extrapolated) value between two Pts\n     * @param a first Pt\n     * @param b second Pt\n     * @param t a value between 0 to 1 to interpolate, or any other value to extrapolate\n     * @returns interpolated point as a new Pt\n     */\n    static interpolate(a, b, t = 0.5) {\n        let len = Math.min(a.length, b.length);\n        let d = Pt_1.Pt.make(len);\n        for (let i = 0; i < len; i++) {\n            d[i] = a[i] * (1 - t) + b[i] * t;\n        }\n        return d;\n    }\n    /**\n     * Find two Pt that are perpendicular to this Pt (2D)\n     * @param axis a string such as \"xy\" (use Const.xy) or an array to specify index for two dimensions\n     * @returns an array of two Pt that are perpendicular to this Pt\n     */\n    static perpendicular(pt, axis = Util_1.Const.xy) {\n        let y = axis[1];\n        let x = axis[0];\n        let p = new Pt_1.Pt(pt);\n        let pa = new Pt_1.Pt(p);\n        pa[x] = -p[y];\n        pa[y] = p[x];\n        let pb = new Pt_1.Pt(p);\n        pb[x] = p[y];\n        pb[y] = -p[x];\n        return new Pt_1.Group(pa, pb);\n    }\n    /**\n     * Check if two Pts (vectors) are perpendicular to each other\n     */\n    static isPerpendicular(p1, p2) {\n        return new Pt_1.Pt(p1).dot(p2) === 0;\n    }\n    /**\n     * Check if a Pt is within the rectangular boundary defined by two Pts\n     * @param pt the Pt to check\n     * @param boundPt1 boundary Pt 1\n     * @param boundPt2 boundary Pt 2\n     */\n    static withinBound(pt, boundPt1, boundPt2) {\n        for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\n            if (!Num.within(pt[i], boundPt1[i], boundPt2[i]))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Sort the Pts so that their edges will form a non-overlapping polygon\n     * Ref: https://stackoverflow.com/questions/6989100/sort-points-in-clockwise-order\n     * @param pts an array of Pts\n     */\n    static sortEdges(pts) {\n        let bounds = Geom.boundingBox(pts);\n        let center = bounds[1].add(bounds[0]).divide(2);\n        let fn = (a, b) => {\n            if (a.length < 2 || b.length < 2)\n                throw new Error(\"Pt dimension cannot be less than 2\");\n            let da = a.$subtract(center);\n            let db = b.$subtract(center);\n            if (da[0] >= 0 && db[0] < 0)\n                return 1;\n            if (da[0] < 0 && db[0] >= 0)\n                return -1;\n            if (da[0] == 0 && db[0] == 0) {\n                if (da[1] >= 0 || db[1] >= 0)\n                    return (da[1] > db[1]) ? 1 : -1;\n                return (db[1] > da[1]) ? 1 : -1;\n            }\n            // compute the cross product of vectors (center -> a) x (center -> b)\n            let det = da.cross2D(db);\n            if (det < 0)\n                return 1;\n            if (det > 0)\n                return -1;\n            // points a and b are on the same line from the center\n            // check which point is closer to the center\n            return (da[0] * da[0] + da[1] * da[1] > db[0] * db[0] + db[1] * db[1]) ? 1 : -1;\n        };\n        return pts.sort(fn);\n    }\n    /**\n     * Scale a Pt or a Group of Pts\n     * @param ps a Pt or a Group of Pts\n     * @param scale scale value\n     * @param anchor optional anchor point to scale from\n     */\n    static scale(ps, scale, anchor) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let scs = (typeof scale == \"number\") ? Pt_1.Pt.make(pts[0].length, scale) : scale;\n        if (!anchor)\n            anchor = Pt_1.Pt.make(pts[0].length, 0);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = pts[i];\n            for (let k = 0, lenP = p.length; k < lenP; k++) {\n                p[k] = (anchor && anchor[k]) ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\n            }\n        }\n        return Geom;\n    }\n    /**\n     * Rotate a Pt or a Group of Pts in 2D space\n     * @param ps a Pt or a Group of Pts\n     * @param angle rotate angle\n     * @param anchor optional anchor point to rotate from\n     * @param axis optional axis such as \"yz\" to define a 2D plane of rotation\n     */\n    static rotate2D(ps, angle, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let fn = (anchor) ? LinearAlgebra_1.Mat.rotateAt2DMatrix : LinearAlgebra_1.Mat.rotate2DMatrix;\n        if (!anchor)\n            anchor = Pt_1.Pt.make(pts[0].length, 0);\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(LinearAlgebra_1.Mat.transform2D(p, fn(cos, sin, anchor)));\n        }\n        return Geom;\n    }\n    /**\n     * Shear a Pt or a Group of Pts in 2D space\n     * @param ps a Pt or a Group of Pts\n     * @param scale shearing value which can be a number or an array of 2 numbers\n     * @param anchor optional anchor point to shear from\n     * @param axis optional axis such as \"yz\" to define a 2D plane of shearing\n     */\n    static shear2D(ps, scale, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let s = (typeof scale == \"number\") ? [scale, scale] : scale;\n        if (!anchor)\n            anchor = Pt_1.Pt.make(pts[0].length, 0);\n        let fn = (anchor) ? LinearAlgebra_1.Mat.shearAt2DMatrix : LinearAlgebra_1.Mat.shear2DMatrix;\n        let tanx = Math.tan(s[0]);\n        let tany = Math.tan(s[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(LinearAlgebra_1.Mat.transform2D(p, fn(tanx, tany, anchor)));\n        }\n        return Geom;\n    }\n    /**\n     * Reflect a Pt or a Group of Pts along a 2D line\n     * @param ps a Pt or a Group of Pts\n     * @param line a Group of 2 Pts that defines a line for reflection\n     * @param axis optional axis such as \"yz\" to define a 2D plane of reflection\n     */\n    static reflect2D(ps, line, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(LinearAlgebra_1.Mat.transform2D(p, LinearAlgebra_1.Mat.reflectAt2DMatrix(line[0], line[1])));\n        }\n        return Geom;\n    }\n    /**\n     * Generate a sine and cosine lookup table\n     * @returns an object with 2 tables (array of 360 values) and 2 functions to get sin/cos given a radian parameter. { sinTable:Float64Array, cosTable:Float64Array, sin:(rad)=>number, cos:(rad)=>number }\n     */\n    static cosTable() {\n        let cos = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            cos[i] = Math.cos(i * Math.PI / 180);\n        let find = (rad) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: cos, cos: find };\n    }\n    /**\n     * Generate a sine and cosine lookup table\n     * @returns an object with 2 tables (array of 360 values) and 2 functions to get sin/cos given a radian parameter. { sinTable:Float64Array, cosTable:Float64Array, sin:(rad)=>number, cos:(rad)=>number }\n     */\n    static sinTable() {\n        let sin = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            sin[i] = Math.sin(i * Math.PI / 180);\n        let find = (rad) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: sin, sin: find };\n    }\n}\nexports.Geom = Geom;\n/**\n * Shaping provides various shaping/easing functions to interpolate a value non-linearly.\n */\nclass Shaping {\n    /**\n     * Linear mapping\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static linear(t, c = 1) {\n        return c * t;\n    }\n    /**\n     * Quadratic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n    */\n    static quadraticIn(t, c = 1) {\n        return c * t * t;\n    }\n    /**\n     * Quadratic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n    */\n    static quadraticOut(t, c = 1) {\n        return -c * t * (t - 2);\n    }\n    /**\n     * Quadratic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static quadraticInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\n    }\n    /**\n     * Cubic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static cubicIn(t, c = 1) {\n        return c * t * t * t;\n    }\n    /**\n     * Cubic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static cubicOut(t, c = 1) {\n        let dt = t - 1;\n        return c * (dt * dt * dt + 1);\n    }\n    /**\n     * Cubic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static cubicInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\n    }\n    /**\n     * Exponential ease In, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p a value between 0 to 1 to control the curve. Default is 0.25.\n     */\n    static exponentialIn(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, 1 / p);\n    }\n    /**\n     * Exponential ease out, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p a value between 0 to 1 to control the curve. Default is 0.25.\n     */\n    static exponentialOut(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, p);\n    }\n    /**\n     * Sinuous in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static sineIn(t, c = 1) {\n        return -c * Math.cos(t * Util_1.Const.half_pi) + c;\n    }\n    /**\n     * Sinuous out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static sineOut(t, c = 1) {\n        return c * Math.sin(t * Util_1.Const.half_pi);\n    }\n    /**\n     * Sinuous in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static sineInOut(t, c = 1) {\n        return -c / 2 * (Math.cos(Math.PI * t) - 1);\n    }\n    /**\n     * A faster way to approximate cosine ease in-out using Blinn-Wyvill Approximation. Adapated from Golan Levin's [polynomial shaping](http://www.flong.com/texts/code/shapers_poly/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static cosineApprox(t, c = 1) {\n        let t2 = t * t;\n        let t4 = t2 * t2;\n        let t6 = t4 * t2;\n        return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\n    }\n    /**\n     * Circular in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static circularIn(t, c = 1) {\n        return -c * (Math.sqrt(1 - t * t) - 1);\n    }\n    /**\n     * Circular out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static circularOut(t, c = 1) {\n        let dt = t - 1;\n        return c * Math.sqrt(1 - dt * dt);\n    }\n    /**\n     * Circular in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static circularInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\n    }\n    /**\n     * Elastic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.\n     */\n    static elasticIn(t, c = 1, p = 0.7) {\n        let dt = t - 1;\n        let s = (p / Util_1.Const.two_pi) * 1.5707963267948966;\n        return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Util_1.Const.two_pi / p));\n    }\n    /**\n     * Elastic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.\n     */\n    static elasticOut(t, c = 1, p = 0.7) {\n        let s = (p / Util_1.Const.two_pi) * 1.5707963267948966;\n        return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Util_1.Const.two_pi / p)) + c;\n    }\n    /**\n     * Elastic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.6.\n     */\n    static elasticInOut(t, c = 1, p = 0.6) {\n        let dt = t * 2;\n        let s = (p / Util_1.Const.two_pi) * 1.5707963267948966;\n        if (t < 0.5) {\n            dt -= 1;\n            return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Util_1.Const.two_pi / p)));\n        }\n        else {\n            dt -= 1;\n            return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Util_1.Const.two_pi / p))) + c;\n        }\n    }\n    /**\n     * Bounce in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static bounceIn(t, c = 1) {\n        return c - Shaping.bounceOut((1 - t), c);\n    }\n    /**\n     * Bounce out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static bounceOut(t, c = 1) {\n        if (t < (1 / 2.75)) {\n            return c * (7.5625 * t * t);\n        }\n        else if (t < (2 / 2.75)) {\n            t -= 1.5 / 2.75;\n            return c * (7.5625 * t * t + 0.75);\n        }\n        else if (t < (2.5 / 2.75)) {\n            t -= 2.25 / 2.75;\n            return c * (7.5625 * t * t + 0.9375);\n        }\n        else {\n            t -= 2.625 / 2.75;\n            return c * (7.5625 * t * t + 0.984375);\n        }\n    }\n    /**\n     * Bounce in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     */\n    static bounceInOut(t, c = 1) {\n        return (t < 0.5) ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\n    }\n    /**\n     * Sigmoid curve changes its shape adapted from the input value, but always returns a value between 0 to 1.\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p the larger the value, the \"steeper\" the curve will be. Default is 10.\n     */\n    static sigmoid(t, c = 1, p = 10) {\n        let d = p * (t - 0.5);\n        return c / (1 + Math.exp(-d));\n    }\n    /**\n     * The Logistic Sigmoid is a useful curve. Adapted from Golan Levin's [shaping function](http://www.flong.com/texts/code/shapers_exp/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.7.\n     */\n    static logSigmoid(t, c = 1, p = 0.7) {\n        p = Math.max(Util_1.Const.epsilon, Math.min(1 - Util_1.Const.epsilon, p));\n        p = 1 / (1 - p);\n        let A = 1 / (1 + Math.exp(((t - 0.5) * p * -2)));\n        let B = 1 / (1 + Math.exp(p));\n        let C = 1 / (1 + Math.exp(-p));\n        return c * (A - B) / (C - B);\n    }\n    /**\n     * An exponential seat curve. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.5.\n     */\n    static seat(t, c = 1, p = 0.5) {\n        if ((t < 0.5)) {\n            return c * (Math.pow(2 * t, 1 - p)) / 2;\n        }\n        else {\n            return c * (1 - (Math.pow(2 * (1 - t), 1 - p)) / 2);\n        }\n    }\n    /**\n     * Quadratic bezier curve. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p1 a Pt object specifying the first control Pt, or a value specifying the control Pt's x position (its y position will default to 0.5). Default is `Pt(0.95, 0.95)\n     */\n    static quadraticBezier(t, c = 1, p = [0.05, 0.95]) {\n        let a = (typeof p != \"number\") ? p[0] : p;\n        let b = (typeof p != \"number\") ? p[1] : 0.5;\n        let om2a = 1 - 2 * a;\n        if (om2a === 0) {\n            om2a = Util_1.Const.epsilon;\n        }\n        let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\n        return c * ((1 - 2 * b) * (d * d) + (2 * b) * d);\n    }\n    /**\n     * Cubic bezier curve. This reuses the bezier functions in Curve class.\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p1` a Pt object specifying the first control Pt. Default is `Pt(0.1, 0.7).\n     * @parma p2` a Pt object specifying the second control Pt. Default is `Pt(0.9, 0.2).\n     */\n    static cubicBezier(t, c = 1, p1 = [0.1, 0.7], p2 = [0.9, 0.2]) {\n        let curve = new Pt_1.Group(new Pt_1.Pt(0, 0), new Pt_1.Pt(p1), new Pt_1.Pt(p2), new Pt_1.Pt(1, 1));\n        return c * Op_1.Curve.bezierStep(new Pt_1.Pt(t * t * t, t * t, t, 1), Op_1.Curve.controlPoints(curve)).y;\n    }\n    /**\n     * Give a Pt, draw a quadratic curve that will pass through that Pt as closely as possible. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_poly/)\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p1` a Pt object specifying the Pt to pass through. Default is `Pt(0.2, 0.35)\n     */\n    static quadraticTarget(t, c = 1, p1 = [0.2, 0.35]) {\n        let a = Math.min(1 - Util_1.Const.epsilon, Math.max(Util_1.Const.epsilon, p1[0]));\n        let b = Math.min(1, Math.max(0, p1[1]));\n        let A = (1 - b) / (1 - a) - (b / a);\n        let B = (A * (a * a) - b) / a;\n        let y = A * (t * t) - B * t;\n        return c * Math.min(1, Math.max(0, y));\n    }\n    /**\n     * Step function is a simple jump from 0 to 1 at a specific Pt in time\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma p usually a value between 0 to 1, which specify the Pt to \"jump\". Default is 0.5 which is in the middle.\n     */\n    static cliff(t, c = 1, p = 0.5) {\n        return (t > p) ? c : 0;\n    }\n    /**\n     * Convert any shaping functions into a series of steps\n     * @parma fn the original shaping function\n     * @parma steps the number of steps\n     * @parma t a value between 0 to 1\n     * @parma c the value to shape, default is 1\n     * @parma args optional paramters to pass to original function\n     */\n    static step(fn, steps, t, c, ...args) {\n        let s = 1 / steps;\n        let tt = Math.floor(t / s) * s;\n        return fn(tt, c, ...args);\n    }\n}\nexports.Shaping = Shaping;\n/**\n * Range object keeps track of a Group of n-dimensional Pts to provide its minimum, maximum, and magnitude in each dimension.\n * It also provides convenient functions such as mapping the Group to another range.\n */\nclass Range {\n    /**\n     * Construct a Range instance for a Group of Pts,\n     * @param g a Group or an array of Pts\n     */\n    constructor(g) {\n        this._dims = 0;\n        this._source = Pt_1.Group.fromPtArray(g);\n        this.calc();\n    }\n    /**\n     * Get this Range's maximum values per dimension\n     */\n    get max() { return this._max.clone(); }\n    /**\n     * Get this Range's minimum values per dimension\n     */\n    get min() { return this._min.clone(); }\n    /**\n     * Get this Range's magnitude in each dimension\n     */\n    get magnitude() { return this._mag.clone(); }\n    /**\n     * Go through the group and find its min and max values.\n     * Usually you don't need to call this function directly.\n     */\n    calc() {\n        if (!this._source)\n            return;\n        let dims = this._source[0].length;\n        this._dims = dims;\n        let max = new Pt_1.Pt(dims);\n        let min = new Pt_1.Pt(dims);\n        let mag = new Pt_1.Pt(dims);\n        for (let i = 0; i < dims; i++) {\n            max[i] = Util_1.Const.min;\n            min[i] = Util_1.Const.max;\n            mag[i] = 0;\n            let s = this._source.zipSlice(i);\n            for (let k = 0, len = s.length; k < len; k++) {\n                max[i] = Math.max(max[i], s[k]);\n                min[i] = Math.min(min[i], s[k]);\n                mag[i] = max[i] - min[i];\n            }\n        }\n        this._max = max;\n        this._min = min;\n        this._mag = mag;\n        return this;\n    }\n    /**\n     * Map this Range to another range of values\n     * @param min target range's minimum value\n     * @param max target range's maximum value\n     * @param exclude Optional boolean array where `true` means excluding the conversion in that specific dimension.\n     */\n    mapTo(min, max, exclude) {\n        let target = new Pt_1.Group();\n        for (let i = 0, len = this._source.length; i < len; i++) {\n            let g = this._source[i];\n            let n = new Pt_1.Pt(this._dims);\n            for (let k = 0; k < this._dims; k++) {\n                n[k] = (exclude && exclude[k]) ? g[k] : Num.mapToRange(g[k], this._min[k], this._max[k], min, max);\n            }\n            target.push(n);\n        }\n        return target;\n    }\n    /**\n     * Add more Pts to this Range and recalculate its min and max values\n     * @param g a Group or an array of Pts to append to this Range\n     * @param update Optional. Set the parameter to `false` if you want to append without immediately updating this Range's min and max values. Default is `true`.\n     */\n    append(g, update = true) {\n        if (g[0].length !== this._dims)\n            throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${g[0].length} provided in parameter. `);\n        this._source = this._source.concat(g);\n        if (update)\n            this.calc();\n        return this;\n    }\n    /**\n     * Create a number of evenly spaced \"ticks\" that span this Range's min and max value.\n     * @param count number of subdivision. For example, 10 subdivision will return 11 tick values, which include first(min) and last(max) values.\n     */\n    ticks(count) {\n        let g = new Pt_1.Group();\n        for (let i = 0; i <= count; i++) {\n            let p = new Pt_1.Pt(this._dims);\n            for (let k = 0, len = this._max.length; k < len; k++) {\n                p[k] = Num.lerp(this._min[k], this._max[k], i / count);\n            }\n            g.push(p);\n        }\n        return g;\n    }\n}\nexports.Range = Range;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pt_1 = __webpack_require__(0);\nconst Op_1 = __webpack_require__(2);\n/**\n * Vec provides static function for vector operations. It's not yet optimized but good enough to use.\n */\nclass Vec {\n    /**\n     * Add b to vector `a`\n     * @returns vector `a`\n     */\n    static add(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b[i] || 0;\n        }\n        return a;\n    }\n    /**\n     * Subtract `b` from vector `a`\n     * @returns vector `a`\n     */\n    static subtract(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b[i] || 0;\n        }\n        return a;\n    }\n    /**\n     * Multiply `b` with vector `a`\n     * @returns vector `a`\n     */\n    static multiply(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise multiply since the array lengths don't match: ${a.toString()} multiply-with ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b[i];\n        }\n        return a;\n    }\n    /**\n     * Divide `a` over `b`\n     * @returns vector `a`\n     */\n    static divide(a, b) {\n        if (typeof b == \"number\") {\n            if (b === 0)\n                throw new Error(\"Cannot divide by zero\");\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise divide since the array lengths don't match. ${a.toString()} divide-by ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b[i];\n        }\n        return a;\n    }\n    /**\n     * Dot product of `a` and `b`\n     */\n    static dot(a, b) {\n        if (a.length != b.length)\n            throw new Error(\"Array lengths don't match\");\n        let d = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            d += a[i] * b[i];\n        }\n        return d;\n    }\n    /**\n     * 2D cross product of `a` and `b`\n     */\n    static cross2D(a, b) {\n        return a[0] * b[1] - a[1] * b[0];\n    }\n    /**\n     * 3D Cross product of `a` and `b`\n     */\n    static cross(a, b) {\n        return new Pt_1.Pt((a[1] * b[2] - a[2] * b[1]), (a[2] * b[0] - a[0] * b[2]), (a[0] * b[1] - a[1] * b[0]));\n    }\n    /**\n     * Magnitude of `a`\n     */\n    static magnitude(a) {\n        return Math.sqrt(Vec.dot(a, a));\n    }\n    /**\n     * Unit vector of `a`. If magnitude of `a` is already known, pass it in the second paramter to optimize calculation.\n     */\n    static unit(a, magnitude = undefined) {\n        let m = (magnitude === undefined) ? Vec.magnitude(a) : magnitude;\n        if (m === 0)\n            throw new Error(\"Cannot calculate unit vector because magnitude is 0\");\n        return Vec.divide(a, m);\n    }\n    /**\n     * Set `a` to its absolute value in each dimension\n     * @returns vector `a`\n     */\n    static abs(a) {\n        return Vec.map(a, Math.abs);\n    }\n    /**\n     * Set `a` to its floor value in each dimension\n     * @returns vector `a`\n     */\n    static floor(a) {\n        return Vec.map(a, Math.floor);\n    }\n    /**\n     * Set `a` to its ceiling value in each dimension\n     * @returns vector `a`\n     */\n    static ceil(a) {\n        return Vec.map(a, Math.ceil);\n    }\n    /**\n     * Set `a` to its rounded value in each dimension\n     * @returns vector `a`\n     */\n    static round(a) {\n        return Vec.map(a, Math.round);\n    }\n    /**\n     * Find the max value within a vector's dimensions\n     * @returns an object with `value` and `index` that specifies the max value and its corresponding dimension.\n     */\n    static max(a) {\n        let m = Number.MIN_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.max(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    /**\n     * Find the min value within a vector's dimensions\n     * @returns an object with `value` and `index` that specifies the min value and its corresponding dimension.\n     */\n    static min(a) {\n        let m = Number.MAX_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.min(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    /**\n     * Sum all the dimensions' values\n     */\n    static sum(a) {\n        let s = 0;\n        for (let i = 0, len = a.length; i < len; i++)\n            s += a[i];\n        return s;\n    }\n    /**\n     * Given a mapping function, update `a`'s value in each dimension\n     * @returns vector `a`\n     */\n    static map(a, fn) {\n        for (let i = 0, len = a.length; i < len; i++) {\n            a[i] = fn(a[i], i, a);\n        }\n        return a;\n    }\n}\nexports.Vec = Vec;\n/**\n * Mat provides static function for matrix operations. It's not yet optimized but good enough to use.\n */\nclass Mat {\n    /**\n     * Matrix additions. Matrices should have the same rows and columns.\n     * @param a a group of Pt\n     * @param b a scalar number, an array of numeric arrays, or a group of Pt\n     * @returns a group with the same rows and columns as a and b\n     */\n    static add(a, b) {\n        if (typeof b != \"number\") {\n            if (a[0].length != b[0].length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n            if (a.length != b.length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n        }\n        let g = new Pt_1.Group();\n        let isNum = typeof b == \"number\";\n        for (let i = 0, len = a.length; i < len; i++) {\n            g.push(a[i].$add((isNum) ? b : b[i]));\n        }\n        return g;\n    }\n    /**\n     * Matrix multiplication\n     * @param a a Group of M Pts, each with K dimensions (M-rows, K-columns)\n     * @param b a scalar number, an array of numeric arrays, or a Group of K Pts, each with N dimensions (K-rows, N-columns) -- or if transposed is true, then N Pts with K dimensions\n     * @param transposed (Only applicable if it's not elementwise multiplication) If true, then a and b's columns should match (ie, each Pt should have the same dimensions). Default is `false`.\n     * @param elementwise if true, then the multiplication is done element-wise. Default is `false`.\n     * @returns If not elementwise, this will return a group with M Pt, each with N dimensions (M-rows, N-columns).\n     */\n    static multiply(a, b, transposed = false, elementwise = false) {\n        let g = new Pt_1.Group();\n        if (typeof b != \"number\") {\n            if (elementwise) {\n                if (a.length != b.length)\n                    throw new Error(\"Cannot multiply matrix element-wise because the matrices' sizes don't match.\");\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    g.push(a[ai].$multiply(b[ai]));\n                }\n            }\n            else {\n                if (!transposed && a[0].length != b.length)\n                    throw new Error(\"Cannot multiply matrix if rows in matrix-a don't match columns in matrix-b.\");\n                if (transposed && a[0].length != b[0].length)\n                    throw new Error(\"Cannot multiply matrix if transposed and the columns in both matrices don't match.\");\n                if (!transposed)\n                    b = Mat.transpose(b);\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    let p = Pt_1.Pt.make(b.length, 0);\n                    for (let bi = 0, blen = b.length; bi < blen; bi++) {\n                        p[bi] = Vec.dot(a[ai], b[bi]);\n                    }\n                    g.push(p);\n                }\n            }\n        }\n        else {\n            for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                g.push(a[ai].$multiply(b));\n            }\n        }\n        return g;\n    }\n    /**\n     * Zip one slice of an array of Pt. Imagine the Pts are organized in rows, then this function will take the values in a specific column.\n     * @param g a group of Pt\n     * @param idx index to zip at\n     * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.\n     */\n    static zipSlice(g, index, defaultValue = false) {\n        let z = [];\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (g[i].length - 1 < index && defaultValue === false)\n                throw `Index ${index} is out of bounds`;\n            z.push(g[i][index] || defaultValue);\n        }\n        return new Pt_1.Pt(z);\n    }\n    /**\n     * Zip a group of Pt. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]\n     * @param g a group of Pt\n     * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.\n     * @param useLongest If true, find the longest list of values in a Pt and use its length for zipping. Default is false, which uses the first item's length for zipping.\n     */\n    static zip(g, defaultValue = false, useLongest = false) {\n        let ps = new Pt_1.Group();\n        let len = (useLongest) ? g.reduce((a, b) => Math.max(a, b.length), 0) : g[0].length;\n        for (let i = 0; i < len; i++) {\n            ps.push(Mat.zipSlice(g, i, defaultValue));\n        }\n        return ps;\n    }\n    /**\n     * Same as `zip` function\n     */\n    static transpose(g, defaultValue = false, useLongest = false) {\n        return Mat.zip(g, defaultValue, useLongest);\n    }\n    /**\n     * Transform a 2D point given a 2x3 or 3x3 matrix\n     * @param pt a Pt to be transformed\n     * @param m 2x3 or 3x3 matrix\n     * @returns a new transformed Pt\n     */\n    static transform2D(pt, m) {\n        let x = pt[0] * m[0][0] + pt[1] * m[1][0] + m[2][0];\n        let y = pt[0] * m[0][1] + pt[1] * m[1][1] + m[2][1];\n        return new Pt_1.Pt(x, y);\n    }\n    /**\n     * Get a scale matrix for use in `transform2D`\n     */\n    static scale2DMatrix(x, y) {\n        return new Pt_1.Group(new Pt_1.Pt(x, 0, 0), new Pt_1.Pt(0, y, 0), new Pt_1.Pt(0, 0, 1));\n    }\n    /**\n     * Get a rotate matrix for use in `transform2D`\n     */\n    static rotate2DMatrix(cosA, sinA) {\n        return new Pt_1.Group(new Pt_1.Pt(cosA, sinA, 0), new Pt_1.Pt(-sinA, cosA, 0), new Pt_1.Pt(0, 0, 1));\n    }\n    /**\n     * Get a shear matrix for use in `transform2D`\n     */\n    static shear2DMatrix(tanX, tanY) {\n        return new Pt_1.Group(new Pt_1.Pt(1, tanX, 0), new Pt_1.Pt(tanY, 1, 0), new Pt_1.Pt(0, 0, 1));\n    }\n    /**\n     * Get a translate matrix for use in `transform2D`\n     */\n    static translate2DMatrix(x, y) {\n        return new Pt_1.Group(new Pt_1.Pt(1, 0, 0), new Pt_1.Pt(0, 1, 0), new Pt_1.Pt(x, y, 1));\n    }\n    /**\n     * Get a matrix to scale a point from an origin point. For use in `transform2D`\n     */\n    static scaleAt2DMatrix(sx, sy, at) {\n        let m = Mat.scale2DMatrix(sx, sy);\n        m[2][0] = -at[0] * sx + at[0];\n        m[2][1] = -at[1] * sy + at[1];\n        return m;\n    }\n    /**\n     * Get a matrix to rotate a point from an origin point. For use in `transform2D`\n     */\n    static rotateAt2DMatrix(cosA, sinA, at) {\n        let m = Mat.rotate2DMatrix(cosA, sinA);\n        m[2][0] = at[0] * (1 - cosA) + at[1] * sinA;\n        m[2][1] = at[1] * (1 - cosA) - at[0] * sinA;\n        return m;\n    }\n    /**\n     * Get a matrix to shear a point from an origin point. For use in `transform2D`\n     */\n    static shearAt2DMatrix(tanX, tanY, at) {\n        let m = Mat.shear2DMatrix(tanX, tanY);\n        m[2][0] = -at[1] * tanY;\n        m[2][1] = -at[0] * tanX;\n        return m;\n    }\n    /**\n     * Get a matrix to reflect a point along a line. For use in `transform2D`\n     * @param p1 first end point to define the reflection line\n     * @param p1 second end point to define the reflection line\n     */\n    static reflectAt2DMatrix(p1, p2) {\n        let intercept = Op_1.Line.intercept(p1, p2);\n        if (intercept == undefined) {\n            return [\n                new Pt_1.Pt([-1, 0, 0]),\n                new Pt_1.Pt([0, 1, 0]),\n                new Pt_1.Pt([p1[0] + p2[0], 0, 1])\n            ];\n        }\n        else {\n            let yi = intercept.yi;\n            let ang2 = Math.atan(intercept.slope) * 2;\n            let cosA = Math.cos(ang2);\n            let sinA = Math.sin(ang2);\n            return [\n                new Pt_1.Pt([cosA, sinA, 0]),\n                new Pt_1.Pt([sinA, -cosA, 0]),\n                new Pt_1.Pt([-yi * sinA, yi + yi * cosA, 1])\n            ];\n        }\n    }\n}\nexports.Mat = Mat;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pt_1 = __webpack_require__(0);\n/**\n * Bound is a subclass of Group that represents a rectangular boundary.\n * It includes some convenient properties such as `x`, `y`, bottomRight`, `center`, and `size`.\n */\nclass Bound extends Pt_1.Group {\n    /**\n     * Create a Bound. This is similar to the Group constructor.\n     * @param args a list of Pt as parameters\n     */\n    constructor(...args) {\n        super(...args);\n        this._center = new Pt_1.Pt();\n        this._size = new Pt_1.Pt();\n        this._topLeft = new Pt_1.Pt();\n        this._bottomRight = new Pt_1.Pt();\n        this._inited = false;\n        this.init();\n    }\n    /**\n     * Create a Bound from a [ClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) object.\n     * @param rect an object has top/left/bottom/right/width/height properties\n     * @returns a Bound object\n     */\n    static fromBoundingRect(rect) {\n        let b = new Bound(new Pt_1.Pt(rect.left || 0, rect.top || 0), new Pt_1.Pt(rect.right || 0, rect.bottom || 0));\n        if (rect.width && rect.height)\n            b.size = new Pt_1.Pt(rect.width, rect.height);\n        return b;\n    }\n    static fromGroup(g) {\n        if (g.length < 2)\n            throw new Error(\"Cannot create a Bound from a group that has less than 2 Pt\");\n        return new Bound(g[0], g[g.length - 1]);\n    }\n    /**\n     * Initiate the bound's properties.\n     */\n    init() {\n        if (this.p1) {\n            this._size = this.p1.clone();\n            this._inited = true;\n        }\n        if (this.p1 && this.p2) {\n            let a = this.p1;\n            let b = this.p2;\n            this.topLeft = a.$min(b);\n            this._bottomRight = a.$max(b);\n            this._updateSize();\n            this._inited = true;\n        }\n    }\n    /**\n     * Clone this bound and return a new one\n     */\n    clone() {\n        return new Bound(this._topLeft.clone(), this._bottomRight.clone());\n    }\n    /**\n     * Recalculte size and center\n     */\n    _updateSize() {\n        this._size = this._bottomRight.$subtract(this._topLeft).abs();\n        this._updateCenter();\n    }\n    /**\n     * Recalculate center\n     */\n    _updateCenter() {\n        this._center = this._size.$multiply(0.5).add(this._topLeft);\n    }\n    /**\n     * Recalculate based on top-left position and size\n     */\n    _updatePosFromTop() {\n        this._bottomRight = this._topLeft.$add(this._size);\n        this._updateCenter();\n    }\n    /**\n     * Recalculate based on bottom-right position and size\n     */\n    _updatePosFromBottom() {\n        this._topLeft = this._bottomRight.$subtract(this._size);\n        this._updateCenter();\n    }\n    /**\n     * Recalculate based on center position and size\n     */\n    _updatePosFromCenter() {\n        let half = this._size.$multiply(0.5);\n        this._topLeft = this._center.$subtract(half);\n        this._bottomRight = this._center.$add(half);\n    }\n    get size() { return new Pt_1.Pt(this._size); }\n    set size(p) {\n        this._size = new Pt_1.Pt(p);\n        this._updatePosFromTop();\n    }\n    get center() { return new Pt_1.Pt(this._center); }\n    set center(p) {\n        this._center = new Pt_1.Pt(p);\n        this._updatePosFromCenter();\n    }\n    get topLeft() { return new Pt_1.Pt(this._topLeft); }\n    set topLeft(p) {\n        this._topLeft = new Pt_1.Pt(p);\n        this[0] = this._topLeft;\n        this._updateSize();\n    }\n    get bottomRight() { return new Pt_1.Pt(this._bottomRight); }\n    set bottomRight(p) {\n        this._bottomRight = new Pt_1.Pt(p);\n        this[1] = this._bottomRight;\n        this._updateSize();\n    }\n    get width() { return (this._size.length > 0) ? this._size.x : 0; }\n    set width(w) {\n        this._size.x = w;\n        this._updatePosFromTop();\n    }\n    get height() { return (this._size.length > 1) ? this._size.y : 0; }\n    set height(h) {\n        this._size.y = h;\n        this._updatePosFromTop();\n    }\n    get depth() { return (this._size.length > 2) ? this._size.z : 0; }\n    set depth(d) {\n        this._size.z = d;\n        this._updatePosFromTop();\n    }\n    get x() { return this.topLeft.x; }\n    get y() { return this.topLeft.y; }\n    get z() { return this.topLeft.z; }\n    get inited() { return this._inited; }\n    /**\n     * If the Group elements are changed, call this function to update the Bound's properties.\n     * It's preferable to change the topLeft/bottomRight etc properties instead of changing the Group array directly.\n     */\n    update() {\n        this._topLeft = this[0];\n        this._bottomRight = this[1];\n        this._updateSize();\n        return this;\n    }\n}\nexports.Bound = Bound;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Util_1 = __webpack_require__(1);\n/**\n* Form is an abstract class that represents a form that's used in a Space for expressions.\n*/\nclass Form {\n    constructor() {\n        this._ready = false;\n    }\n    /**\n    * get whether the Form has received the Space's rendering context\n    */\n    get ready() { return this._ready; }\n    /**\n     * Check number of items in a Group against a required number\n     * @param pts\n     */\n    static _checkSize(pts, required = 2) {\n        if (pts.length < required) {\n            Util_1.Util.warn(\"Requires 2 or more Pts in this Group.\");\n            return false;\n        }\n        return true;\n    }\n}\nexports.Form = Form;\n/**\n* VisualForm is an abstract class that represents a form that can be used to express Pts visually.\n* For example, CanvasForm is an implementation of VisualForm that draws on CanvasSpace which represents a html canvas.\n*/\nclass VisualForm extends Form {\n    constructor() {\n        super(...arguments);\n        this._filled = true;\n        this._stroked = true;\n        this._font = new Font(14, \"sans-serif\");\n    }\n    get filled() { return this._filled; }\n    set filled(b) { this._filled = b; }\n    get stroked() { return this._stroked; }\n    set stroked(b) { this._stroked = b; }\n    get currentFont() { return this._font; }\n    _multiple(groups, shape, ...rest) {\n        if (!groups)\n            return this;\n        for (let i = 0, len = groups.length; i < len; i++) {\n            this[shape](groups[i], ...rest);\n        }\n        return this;\n    }\n    /**\n    * Set fill color (not implemented)\n    */\n    fill(c) {\n        return this;\n    }\n    /**\n    * Set current fill style and without stroke.\n    * @example `form.fillOnly(\"#F90\")`, `form.fillOnly(\"rgba(0,0,0,.5\")`\n    * @param c fill color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle))\n    */\n    fillOnly(c) {\n        this.stroke(false);\n        return this.fill(c);\n    }\n    /**\n    * Set stroke style (not implemented)\n    */\n    stroke(c, width, linejoin, linecap) {\n        return this;\n    }\n    /**\n    * Set current stroke style and without fill.\n    * @example `form.strokeOnly(\"#F90\")`, `form.strokeOnly(\"#000\", 0.5, 'round', 'square')`\n    * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle)\n    */\n    strokeOnly(c, width, linejoin, linecap) {\n        this.fill(false);\n        return this.stroke(c, width, linejoin, linecap);\n    }\n    /**\n    * Draw multiple points at once\n    * @param pts an array of Pt or an array of number arrays\n    * @param radius radius of the point. Default is 5.\n    * @param shape The shape of the point. Defaults to \"square\", but it can be \"circle\" or a custom shape function in your own implementation.\n    */\n    points(pts, radius, shape) {\n        if (!pts)\n            return;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            this.point(pts[i], radius, shape);\n        }\n        return this;\n    }\n    /**\n    * Draw multiple circles at once\n    * @param groups an array of Groups that defines multiple circles\n    */\n    circles(groups) {\n        return this._multiple(groups, \"circle\");\n    }\n    /**\n    * Draw multiple squares at once\n    * @param groups an array of Groups that defines multiple circles\n    */\n    squares(groups) {\n        return this._multiple(groups, \"square\");\n    }\n    /**\n    * Draw multiple lines at once\n    * @param groups An array of Groups of Pts\n    */\n    lines(groups) {\n        return this._multiple(groups, \"line\");\n    }\n    /**\n    * Draw multiple polygons at once\n    * @param groups An array of Groups of Pts\n    */\n    polygons(groups) {\n        return this._multiple(groups, \"polygon\");\n    }\n    /**\n    * Draw multiple rectangles at once\n    * @param groups An array of Groups of Pts\n    */\n    rects(groups) {\n        return this._multiple(groups, \"rect\");\n    }\n}\nexports.VisualForm = VisualForm;\n/**\n* Font class lets you create a specific font style with properties for its size and style\n*/\nclass Font {\n    /**\n    * Create a font style\n    * @param size font size. Defaults is 12px.\n    * @param face Optional font-family, use css-like string such as \"Helvetica\" or \"Helvetica, sans-serif\". Default is \"sans-serif\".\n    * @param weight Optional font weight such as \"bold\". Default is \"\" (none).\n    * @param style Optional font style such as \"italic\". Default is \"\" (none).\n    * @param lineHeight Optional line height. Default is 1.5.\n    * @example `new Font(12, \"Frutiger, sans-serif\", \"bold\", \"underline\", 1.5)`\n    */\n    constructor(size = 12, face = \"sans-serif\", weight = \"\", style = \"\", lineHeight = 1.5) {\n        this.size = size;\n        this.face = face;\n        this.style = style;\n        this.weight = weight;\n        this.lineHeight = lineHeight;\n    }\n    /**\n    * Get a string representing the font style, in css-like string such as \"italic bold 12px/1.5 sans-serif\"\n    */\n    get value() { return `${this.style} ${this.weight} ${this.size}px/${this.lineHeight} ${this.face}`; }\n    /**\n    * Get a string representing the font style, in css-like string such as \"italic bold 12px/1.5 sans-serif\"\n    */\n    toString() { return this.value; }\n}\nexports.Font = Font;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Bound_1 = __webpack_require__(5);\nconst Pt_1 = __webpack_require__(0);\nconst UI_1 = __webpack_require__(14);\n/**\n* Space is an abstract class that represents a general context for expressing Pts.\n* See [Space guide](../../guide/Space-0500.html) for details.\n*/\nclass Space {\n    constructor() {\n        this.id = \"space\";\n        this.bound = new Bound_1.Bound();\n        this._time = { prev: 0, diff: 0, end: -1 };\n        this.players = {};\n        this.playerCount = 0;\n        this._animID = -1;\n        this._pause = false;\n        this._refresh = undefined;\n        this._pointer = new Pt_1.Pt();\n        this._isReady = false;\n        this._playing = false;\n    }\n    /**\n    * Set whether the rendering should be repainted on each frame\n    * @param b a boolean value to set whether to repaint each frame\n    */\n    refresh(b) {\n        this._refresh = b;\n        return this;\n    }\n    /**\n    * Add an IPlayer to this space. An IPlayer can define the following callback functions:\n    * - `animate( time, ftime, space )`\n    * - `start(bound, space)`\n    * - `resize( size, event )`\n    * - `action( type, x, y, event )`\n    * Subclasses of Space may define other callback functions.\n    * @param player an IPlayer object with animate function, or simply a function(time, ftime){}\n    */\n    add(p) {\n        let player = (typeof p == \"function\") ? { animate: p } : p;\n        let k = this.playerCount++;\n        let pid = this.id + k;\n        this.players[pid] = player;\n        player.animateID = pid;\n        if (player.resize && this.bound.inited)\n            player.resize(this.bound);\n        // if _refresh is not set, set it to true\n        if (this._refresh === undefined)\n            this._refresh = true;\n        return this;\n    }\n    /**\n    * Remove a player from this Space\n    * @param player an IPlayer that has an `animateID` property\n    */\n    remove(player) {\n        delete this.players[player.animateID];\n        return this;\n    }\n    /**\n    * Remove all players from this Space\n    */\n    removeAll() {\n        this.players = {};\n        return this;\n    }\n    /**\n    * Main play loop. This implements window.requestAnimationFrame and calls it recursively.\n    * Override this `play()` function to implemenet your own animation loop.\n    * @param time current time\n    */\n    play(time = 0) {\n        this._animID = requestAnimationFrame(this.play.bind(this));\n        if (this._pause)\n            return this;\n        this._time.diff = time - this._time.prev;\n        this._time.prev = time;\n        try {\n            this.playItems(time);\n        }\n        catch (err) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n            throw err;\n        }\n        return this;\n    }\n    /**\n    * Replay the animation after `stop()`. This resets the end-time counter.\n    * You may also use `pause()` and `resume()` for temporary pause.\n    */\n    replay() {\n        this._time.end = -1;\n        this.play();\n    }\n    /**\n    * Main animate function. This calls all the items to perform\n    * @param time current time\n    */\n    playItems(time) {\n        this._playing = true;\n        // clear before draw if refresh is true\n        if (this._refresh)\n            this.clear();\n        // animate all players\n        if (this._isReady) {\n            for (let k in this.players) {\n                if (this.players[k].animate)\n                    this.players[k].animate(time, this._time.diff, this);\n            }\n        }\n        // stop if time ended\n        if (this._time.end >= 0 && time > this._time.end) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n        }\n    }\n    /**\n    * Pause the animation\n    * @param toggle a boolean value to set if this function call should be a toggle (between pause and resume)\n    */\n    pause(toggle = false) {\n        this._pause = (toggle) ? !this._pause : true;\n        return this;\n    }\n    /**\n    * Resume the pause animation\n    */\n    resume() {\n        this._pause = false;\n        return this;\n    }\n    /**\n    * Specify when the animation should stop: immediately, after a time period, or never stops.\n    * @param t a value in millisecond to specify a time period to play before stopping, or `-1` to play forever, or `0` to end immediately. Default is 0 which will stop the animation immediately.\n    */\n    stop(t = 0) {\n        this._time.end = t;\n        return this;\n    }\n    /**\n    * Play animation loop, and then stop after `duration` time has passed.\n    * @param duration a value in millisecond to specify a time period to play before stopping, or `-1` to play forever\n    */\n    playOnce(duration = 5000) {\n        this.play();\n        this.stop(duration);\n        return this;\n    }\n    /**\n    * Custom rendering\n    * @param context rendering context\n    */\n    render(context) {\n        if (this._renderFunc)\n            this._renderFunc(context, this);\n        return this;\n    }\n    /**\n    * Set a custom rendering `function(graphics_context, canvas_space)` if needed\n    */\n    set customRendering(f) { this._renderFunc = f; }\n    get customRendering() { return this._renderFunc; }\n    /**\n     * Get a boolean to indicate whether the animation is playing\n     */\n    get isPlaying() { return this._playing; }\n    /**\n    * Get this space's bounding box\n    */\n    get outerBound() { return this.bound.clone(); }\n    /**\n    * The bounding box of the canvas\n    */\n    get innerBound() { return new Bound_1.Bound(Pt_1.Pt.make(this.size.length, 0), this.size.clone()); }\n    /**\n    * Get the size of this bounding box as a Pt\n    */\n    get size() { return this.bound.size.clone(); }\n    /**\n    * Get the size of this bounding box as a Pt\n    */\n    get center() { return this.size.divide(2); }\n    /**\n    * Get width of canvas\n    */\n    get width() { return this.bound.width; }\n    /**\n    * Get height of canvas\n    */\n    get height() { return this.bound.height; }\n}\nexports.Space = Space;\nclass MultiTouchSpace extends Space {\n    constructor() {\n        super(...arguments);\n        // track mouse dragging\n        this._pressed = false;\n        this._dragged = false;\n        this._hasMouse = false;\n        this._hasTouch = false;\n    }\n    /**\n    * Get the mouse or touch pointer that stores the last action\n    */\n    get pointer() {\n        let p = this._pointer.clone();\n        p.id = this._pointer.id;\n        return p;\n    }\n    /**\n    * Bind event listener in canvas element. You can also use `bindMouse` or `bindTouch` to bind mouse or touch events conveniently.\n    * @param evt an event string such as \"mousedown\"\n    * @param callback callback function for this event\n    */\n    bindCanvas(evt, callback) {\n        this._canvas.addEventListener(evt, callback);\n    }\n    /**\n    * Unbind a callback from the event listener\n    * @param evt an event string such as \"mousedown\"\n    * @param callback callback function to unbind\n    */\n    unbindCanvas(evt, callback) {\n        this._canvas.removeEventListener(evt, callback);\n    }\n    /**\n    * A convenient method to bind (or unbind) all mouse events in canvas element. All \"players\" added to this space that implements an `action` callback property will receive mouse event callbacks. The types of mouse actions are defined by UIPointerActions constants: \"up\", \"down\", \"move\", \"drag\", \"drop\", \"over\", and \"out\". See `Space`'s `add()` function for more details.\n    * @param _bind a boolean value to bind mouse events if set to `true`. If `false`, all mouse events will be unbound. Default is true.\n    * @see Space`'s [`add`](./_space_.space.html#add) function\n    */\n    bindMouse(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.bindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.bindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.bindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.bindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = true;\n        }\n        else {\n            this.unbindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.unbindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.unbindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = false;\n        }\n        return this;\n    }\n    /**\n    * A convenient method to bind (or unbind) all touch events in canvas element. All \"players\" added to this space that implements an `action` callback property will receive mouse event callbacks. The types of mouse actions are: \"up\", \"down\", \"move\", \"drag\", \"drop\", \"over\", and \"out\".\n    * @param _bind a boolean value to bind touch events if set to `true`. If `false`, all mouse events will be unbound. Default is true.\n    * @see Space`'s [`add`](./_space_.space.html#add) function\n    */\n    bindTouch(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.bindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.bindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.bindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = true;\n        }\n        else {\n            this.unbindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.unbindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = false;\n        }\n        return this;\n    }\n    /**\n    * A convenient method to convert the touch points in a touch event to an array of `Pt`.\n    * @param evt a touch event which contains touches, changedTouches, and targetTouches list\n    * @param which a string to select a touches list: \"touches\", \"changedTouches\", or \"targetTouches\". Default is \"touches\"\n    * @return an array of Pt, whose origin position (0,0) is offset to the top-left of this space\n    */\n    touchesToPoints(evt, which = \"touches\") {\n        if (!evt || !evt[which])\n            return [];\n        let ts = [];\n        for (var i = 0; i < evt[which].length; i++) {\n            let t = evt[which].item(i);\n            ts.push(new Pt_1.Pt(t.pageX - this.bound.topLeft.x, t.pageY - this.bound.topLeft.y));\n        }\n        return ts;\n    }\n    /**\n    * Go through all the `players` and call its `action` callback function\n    * @param type an UIPointerActions constant or string: \"up\", \"down\", \"move\", \"drag\", \"drop\", \"over\", and \"out\"\n    * @param evt mouse or touch event\n    */\n    _mouseAction(type, evt) {\n        let px = 0, py = 0;\n        if (evt instanceof MouseEvent) {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    px = evt.pageX - this.outerBound.x;\n                    py = evt.pageY - this.outerBound.y;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        else {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    let c = evt.changedTouches && evt.changedTouches.length > 0;\n                    let touch = evt.changedTouches.item(0);\n                    px = (c) ? touch.pageX - this.outerBound.x : 0;\n                    py = (c) ? touch.pageY - this.outerBound.y : 0;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        if (type) {\n            this._pointer.to(px, py);\n            this._pointer.id = type;\n        }\n    }\n    /**\n    * MouseDown handler\n    * @param evt\n    */\n    _mouseDown(evt) {\n        this._mouseAction(UI_1.UIPointerActions.down, evt);\n        this._pressed = true;\n        return false;\n    }\n    /**\n    * MouseUp handler\n    * @param evt\n    */\n    _mouseUp(evt) {\n        this._mouseAction(UI_1.UIPointerActions.up, evt);\n        if (this._dragged)\n            this._mouseAction(UI_1.UIPointerActions.down, evt);\n        this._pressed = false;\n        this._dragged = false;\n        return false;\n    }\n    /**\n    * MouseMove handler\n    * @param evt\n    */\n    _mouseMove(evt) {\n        this._mouseAction(UI_1.UIPointerActions.move, evt);\n        if (this._pressed) {\n            this._dragged = true;\n            this._mouseAction(UI_1.UIPointerActions.drag, evt);\n        }\n        return false;\n    }\n    /**\n    * MouseOver handler\n    * @param evt\n    */\n    _mouseOver(evt) {\n        this._mouseAction(UI_1.UIPointerActions.over, evt);\n        return false;\n    }\n    /**\n    * MouseOut handler\n    * @param evt\n    */\n    _mouseOut(evt) {\n        this._mouseAction(UI_1.UIPointerActions.out, evt);\n        if (this._dragged)\n            this._mouseAction(UI_1.UIPointerActions.drop, evt);\n        this._dragged = false;\n        return false;\n    }\n    /**\n    * TouchMove handler\n    * @param evt\n    */\n    _touchMove(evt) {\n        this._mouseMove(evt);\n        evt.preventDefault();\n        return false;\n    }\n}\nexports.MultiTouchSpace = MultiTouchSpace;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Space_1 = __webpack_require__(7);\nconst Form_1 = __webpack_require__(6);\nconst Bound_1 = __webpack_require__(5);\nconst Util_1 = __webpack_require__(1);\nconst Pt_1 = __webpack_require__(0);\n/**\n * A Space for DOM elements\n */\nclass DOMSpace extends Space_1.MultiTouchSpace {\n    /**\n    * Create a DOMSpace which represents a Space for DOM elements\n    * @param elem Specify an element by its \"id\" attribute as string, or by the element object itself. Use css to customize its appearance if needed.\n    * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a \"ready\" event will also be fired from the element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener(\"ready\")`\n    * @example `new DOMSpace( \"#myElementID\" )`\n    */\n    constructor(elem, callback) {\n        super();\n        this.id = \"domspace\";\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._css = {};\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pts\";\n        // check element or element id string\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            _selector = document.querySelector(elem);\n            _existed = true;\n            this.id = elem.substr(1);\n        }\n        // if selector is not defined, create a canvas\n        if (!_selector) {\n            this._container = DOMSpace.createElement(\"div\", \"pts_container\");\n            this._canvas = DOMSpace.createElement(\"div\", \"pts_element\");\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n        }\n        // no mutation observer, so we set a timeout for ready event\n        setTimeout(this._ready.bind(this, callback), 50);\n    }\n    /**\n    * Helper function to create a DOM element\n    * @param elem element tag name\n    * @param id element id attribute\n    * @param appendTo Optional, if specified, the created element will be appended to this element\n    */\n    static createElement(elem = \"div\", id, appendTo) {\n        let d = document.createElement(elem);\n        if (id)\n            d.setAttribute(\"id\", id);\n        if (appendTo && appendTo.appendChild)\n            appendTo.appendChild(d);\n        return d;\n    }\n    /**\n    * Handle callbacks after element is mounted in DOM\n    * @param callback\n    */\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this.refresh(false); // No need to clear and redraw for every frame in DOM\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    /**\n    * Set up various options for DOMSpace. The `opt` parameter is an object with the following fields. This is usually set during instantiation, eg `new DOMSpace(...).setup( { opt } )`\n    * @param opt an object with optional settings, as follows.\n    * @param opt.bgcolor a hex or rgba string to set initial background color of the canvas, or use `false` or \"transparent\" to set a transparent background. You may also change it later with `clear()`\n    * @param opt.resize a boolean to set whether `<canvas>` size should auto resize to match its container's size. You can also set it manually with `autoSize()`\n    * @example `space.setup({ bgcolor: \"#f00\", resize: true })`\n    */\n    setup(opt) {\n        if (opt.bgcolor) {\n            this._bgcolor = opt.bgcolor;\n        }\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        return this;\n    }\n    /**\n     * Not implemented. See SVGSpace and HTMLSpace for implementation\n     */\n    getForm() {\n        return null;\n    }\n    /**\n    * Set whether the canvas element should resize when its container is resized.\n    * @param auto a boolean value indicating if auto size is set\n    */\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            delete this._css['width'];\n            delete this._css['height'];\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    /**\n    * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).\n    * @param b a Bound object to resize to\n    * @param evt Optionally pass a resize event\n    */\n    resize(b, evt) {\n        this.bound = b;\n        this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        ;\n        return this;\n    }\n    /**\n    * Window resize handling\n    * @param evt\n    */\n    _resizeHandler(evt) {\n        let b = Bound_1.Bound.fromBoundingRect(this._container.getBoundingClientRect());\n        if (this._autoResize) {\n            this.styles({ width: \"100%\", height: \"100%\" }, true);\n        }\n        else {\n            this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        }\n        this.resize(b, evt);\n    }\n    /**\n    * Get this DOM element\n    */\n    get element() {\n        return this._canvas;\n    }\n    /**\n    * Get the parent DOM element that contains this DOM element\n    */\n    get parent() {\n        return this._container;\n    }\n    /**\n    * A property to indicate if the Space is ready\n    */\n    get ready() { return this._isReady; }\n    /**\n    * Clear the element's contents, and ptionally set a new backgrounc color. Overrides Space's `clear` function.\n    * @param bg Optionally specify a custom background color in hex or rgba string, or \"transparent\". If not defined, it will use its `bgcolor` property as background color to clear the canvas.\n    */\n    clear(bg) {\n        if (bg)\n            this.background = bg;\n        this._canvas.innerHTML = \"\";\n        return this;\n    }\n    /**\n    * Set a background color on the container element\n    @param bg background color as hex or rgba string\n    */\n    set background(bg) {\n        this._bgcolor = bg;\n        this._container.style.backgroundColor = this._bgcolor;\n    }\n    get background() { return this._bgcolor; }\n    /**\n    * Add or update a style definition, and optionally update that style in the Element\n    * @param key style name\n    * @param val style value\n    * @param update a boolean to update the element's style immediately if set to `true`. Default is `false`.\n    */\n    style(key, val, update = false) {\n        this._css[key] = val;\n        if (update)\n            this._canvas.style[key] = val;\n        return this;\n    }\n    /**\n    * Add of update a list of style definitions, and optionally update those styles in the Element\n    * @param styles a key-value objects of style definitions\n    * @param update a boolean to update the element's style immediately if set to `true`. Default is `false`.\n    * @return this\n    */\n    styles(styles, update = false) {\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k))\n                this.style(k, styles[k], update);\n        }\n        return this;\n    }\n    /**\n    * A static helper function to add or update Element attributes\n    * @param elem Element to update\n    * @param data an object with key-value pairs\n    * @returns this DOM element\n    */\n    static setAttr(elem, data) {\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                elem.setAttribute(k, data[k]);\n            }\n        }\n        return elem;\n    }\n    /**\n    * A static helper function to compose an inline style string from a object of styles\n    * @param elem Element to update\n    * @param data an object with key-value pairs\n    * @exmaple DOMSpace.getInlineStyles( {width: \"100px\", \"font-size\": \"10px\"} ); // returns \"width: 100px; font-size: 10px\"\n    */\n    static getInlineStyles(data) {\n        let str = \"\";\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                if (data[k])\n                    str += `${k}: ${data[k]}; `;\n            }\n        }\n        return str;\n    }\n}\nexports.DOMSpace = DOMSpace;\n/**\n * HTMLSpace. Note that this is currently experimental and may change in future.\n */\nclass HTMLSpace extends DOMSpace {\n    /**\n    * Get a new `HTMLForm` for drawing\n    * @see `HTMLForm`\n    */\n    getForm() {\n        return new HTMLForm(this);\n    }\n    /**\n     * A static function to add a DOM element inside a node. Usually you don't need to use this directly. See methods in `DOMForm` instead.\n     * @param parent the parent element, or `null` to use current `<svg>` as parent.\n     * @param name a string of element name,  such as `rect` or `circle`\n     * @param id id attribute of the new element\n     * @param autoClass add a class based on the id (from char 0 to index of \"-\"). Default is true.\n     */\n    static htmlElement(parent, name, id, autoClass = true) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElement(name);\n            elem.setAttribute(\"id\", id);\n            if (autoClass)\n                elem.setAttribute(\"class\", id.substring(0, id.indexOf(\"-\")));\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    /**\n    * Remove an item from this Space\n    * @param item a player item with an auto-assigned `animateID` property\n    */\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + HTMLForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    /**\n     * Remove all items from this Space\n     */\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexports.HTMLSpace = HTMLSpace;\n/**\n * Form for HTMLSpace. Note that this is currently experimental and may change in future.\n */\nclass HTMLForm extends Form_1.VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"background\": \"#f03\",\n                \"border-color\": \"#fff\",\n                \"color\": \"#000\",\n                \"border-width\": \"1px\",\n                \"border-radius\": \"0\",\n                \"border-style\": \"solid\",\n                \"position\": \"absolute\",\n                \"top\": 0,\n                \"left\": 0,\n                \"width\": 0,\n                \"height\": 0\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_dom_\" + (HTMLForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    /**\n     * Update a style in _ctx context or throw an Erorr if the style doesn't exist\n     * @param k style key\n     * @param v  style value\n     * @param unit Optional unit like 'px' to append to value\n     */\n    styleTo(k, v, unit = '') {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = `${v}${unit}`;\n    }\n    /**\n    * Set current fill style. Provide a valid color string or `false` to specify no fill color.\n    * @example `form.fill(\"#F90\")`, `form.fill(\"rgba(0,0,0,.5\")`, `form.fill(false)`\n    * @param c fill color\n    */\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n            if (!c)\n                this.styleTo(\"background\", \"transparent\");\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"background\", c);\n        }\n        return this;\n    }\n    /**\n    * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.\n    * @example `form.stroke(\"#F90\")`, `form.stroke(\"rgba(0,0,0,.5\")`, `form.stroke(false)`, `form.stroke(\"#000\", 0.5, 'round', 'square')`\n    * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))\n    * @param width Optional value (can be floating point) to set line width\n    * @param linejoin not implemented in HTMLForm\n    * @param linecap not implemented in HTMLForm\n    */\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n            if (!c)\n                this.styleTo(\"border-width\", 0);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"border-color\", c);\n            this.styleTo(\"border-width\", (width || 1) + \"px\");\n        }\n        return this;\n    }\n    /**\n    * Set current text color style. Provide a valid color string.\n    * @example `form.fill(\"#F90\")`, `form.fill(\"rgba(0,0,0,.5\")`, `form.fill(false)`\n    * @param c fill color\n    */\n    fillText(c) {\n        this.styleTo(\"color\", c);\n        return this;\n    }\n    /**\n     * Add custom class to the created element\n     * @param c custom class name or `false` to reset it\n     * @example `form.fill(\"#f00\").cls(\"myClass\").rects(r)` `form.cls(false).circles(c)`\n     */\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    /**\n    * Set the current font\n    * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties\n    * @param weight Optional font-weight string such as \"bold\"\n    * @param style Optional font-style string such as \"italic\"\n    * @param lineHeight Optional line-height number suchas 1.5\n    * @param family Optional font-family such as \"Helvetica, sans-serif\"\n    * @example `form.font( myFont )`, `form.font(14, \"bold\")`\n    */\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    /**\n    * Reset the context's common styles to this form's styles. This supports using multiple forms on the same canvas context.\n    */\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"background\": \"#f03\", \"border-color\": \"#fff\",\n            \"border-width\": \"1px\"\n        };\n        this._font = new Form_1.Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    /**\n     * Set this form's group scope by an ID, and optionally define the group's parent element. A group scope keeps track of elements by their generated IDs, and updates their properties as needed. See also `scope()`.\n     * @param group_id a string to use as prefix for the group's id. For example, group_id \"hello\" will create elements with id like \"hello-1\", \"hello-2\", etc\n     * @param group Optional DOM element to define this group's parent element\n     * @returns this form's context\n     */\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    /**\n     * Set the current group scope to an item added into space, in order to keep track of any point, circle, etc created within it. The item must have an `animateID` property, so that elements created within the item will have generated IDs like \"item-{animateID}-{count}\".\n     * @param item a \"player\" item that's added to space (see `space.add(...)`) and has an `animateID` property\n     * @returns this form's context\n     */\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(HTMLForm.scopeID(item), this.space.element);\n    }\n    /**\n     * Get next available id in the current group\n     * @returns an id string\n     */\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    /**\n     * A static function to generate an ID string based on a context object\n     * @param ctx a context object for an HTMLForm\n     */\n    static getID(ctx) {\n        return ctx.currentID || `p-${HTMLForm.domID++}`;\n    }\n    /**\n     * A static function to generate an ID string for a scope, based on a \"player\" item in the Space\n     * @param item a \"player\" item that's added to space (see `space.add(...)`) and has an `animateID` property\n     */\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    /**\n     * A static function to help adding style object to an element. This put all styles into `style` attribute instead of individual attributes, so that the styles can be parsed by Adobe Illustrator.\n     * @param elem A DOM element to add to\n     * @param styles an object of style properties\n     * @example `HTMLForm.style(elem, {fill: \"#f90\", stroke: false})`\n     * @returns DOM element\n     */\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"background: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"border: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('background') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('border-width') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return HTMLSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    /**\n   * A helper function to set top, left, width, height of DOM element\n   * @param x left position\n   * @param y top position\n   * @param w width\n   * @param h height\n   */\n    static rectStyle(ctx, pt, size) {\n        ctx.style[\"left\"] = pt[0] + \"px\";\n        ctx.style[\"top\"] = pt[1] + \"px\";\n        ctx.style[\"width\"] = size[0] + \"px\";\n        ctx.style[\"height\"] = size[1] + \"px\";\n        return ctx;\n    }\n    /**\n    * Draws a point\n    * @param ctx a context object of HTMLForm\n    * @param pt a Pt object or numeric array\n    * @param radius radius of the point. Default is 5.\n    * @param shape The shape of the point. Defaults to \"square\", but it can be \"circle\" or a custom shape function in your own implementation.\n    * @example `HTMLForm.point( p )`, `HTMLForm.point( p, 10, \"circle\" )`\n    */\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return HTMLForm.circle(ctx, pt, radius);\n        }\n        else {\n            return HTMLForm.square(ctx, pt, radius);\n        }\n    }\n    /**\n    * Draws a point\n    * @param p a Pt object\n    * @param radius radius of the point. Default is 5.\n    * @param shape The shape of the point. Defaults to \"square\", but it can be \"circle\" or a custom shape function in your own implementation.\n    * @example `form.point( p )`, `form.point( p, 10, \"circle\" )`\n    */\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        if (shape == \"circle\")\n            this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    /**\n    * A static function to draw a circle\n    * @param ctx a context object of HTMLForm\n    * @param pt center position of the circle\n    * @param radius radius of the circle\n    */\n    static circle(ctx, pt, radius = 10) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-circle ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt_1.Pt(pt).$subtract(radius), new Pt_1.Pt(radius * 2, radius * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n    * Draw a circle\n    * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]\n    * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)\n    */\n    circle(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    /**\n    * A static function to draw a square\n    * @param ctx a context object of HTMLForm\n    * @param pt center position of the square\n    * @param halfsize half size of the square\n    */\n    static square(ctx, pt, halfsize) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-square ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt_1.Pt(pt).$subtract(halfsize), new Pt_1.Pt(halfsize * 2, halfsize * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n     * Draw a square, given a center and its half-size\n     * @param pt center Pt\n     * @param halfsize half-size\n     */\n    square(pt, halfsize) {\n        this.nextID();\n        HTMLForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    /**\n    * A static function to draw a rectangle\n    * @param ctx a context object of HTMLForm\n    * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.\n    */\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-rect ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, pts[0], pts[1]);\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n    * Draw a rectangle\n    * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.\n    */\n    rect(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"0\");\n        HTMLForm.rect(this._ctx, pts);\n        return this;\n    }\n    /**\n    * A static function to draw text\n    * @param ctx a context object of HTMLForm\n    * @param `pt` a Point object to specify the anchor point\n    * @param `txt` a string of text to draw\n    * @param `maxWidth` specify a maximum width per line\n    */\n    static text(ctx, pt, txt) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, {\n            position: 'absolute',\n            class: `pts-form pts-text ${ctx.currentClass}`,\n            left: pt[0],\n            top: pt[1],\n        });\n        elem.textContent = txt;\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n    * Draw text on canvas\n    * @param `pt` a Pt or numeric array to specify the anchor point\n    * @param `txt` text\n    * @param `maxWidth` specify a maximum width per line\n    */\n    text(pt, txt) {\n        this.nextID();\n        HTMLForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    /**\n    * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.\n    * @param txt text\n    */\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n    /**\n     * Arc is not implemented in HTMLForm\n     */\n    arc(pt, radius, startAngle, endAngle, cc) {\n        Util_1.Util.warn(\"arc is not implemented in HTMLForm\");\n        return this;\n    }\n    /**\n     * Line is not implemented in HTMLForm\n     */\n    line(pts) {\n        Util_1.Util.warn(\"line is not implemented in HTMLForm\");\n        return this;\n    }\n    /**\n     * Polygon is not implemented in HTMLForm\n     * @param pts\n     */\n    polygon(pts) {\n        Util_1.Util.warn(\"polygon is not implemented in HTMLForm\");\n        return this;\n    }\n}\nHTMLForm.groupID = 0;\nHTMLForm.domID = 0;\nexports.HTMLForm = HTMLForm;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0.\n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pt_1 = __webpack_require__(0);\n/** Various functions to support typography */\nclass Typography {\n    /**\n     * Create a heuristic text width estimate function. It will be less accurate but faster.\n     * @param fn a reference function that can measure text width accurately\n     * @param samples a list of string samples. Default is [\"M\", \"n\", \".\"]\n     * @param distribution a list of the samples' probability distribution. Default is [0.06, 0.8, 0.14].\n     * @return a function that can estimate text width\n     */\n    static textWidthEstimator(fn, samples = [\"M\", \"n\", \".\"], distribution = [0.06, 0.8, 0.14]) {\n        let m = samples.map(fn);\n        let avg = new Pt_1.Pt(distribution).dot(m);\n        return (str) => str.length * avg;\n    }\n    /**\n     * Truncate text to fit width\n     * @param fn a function that can measure text width\n     * @param str text to truncate\n     * @param width width to fit\n     * @param tail text to indicate overflow such as \"...\". Default is empty \"\".\n     */\n    static truncate(fn, str, width, tail = \"\") {\n        let trim = Math.floor(str.length * Math.min(1, width / (fn(str) * 1.1)));\n        if (trim < str.length) {\n            trim = Math.max(0, trim - tail.length);\n            return [str.substr(0, trim) + tail, trim];\n        }\n        else {\n            return [str, str.length];\n        }\n    }\n    /**\n     * Get a function to scale font size proportionally to text box size changes.\n     * @param box Initial box as a Group\n     * @param ratio font-size change ratio. Default is 1.\n     * @returns a function where input parameter is a new box, and returns the new font size value\n     */\n    static fontSizeToBox(box, ratio = 1) {\n        let h = (box[1][1] - box[0][1]);\n        let f = ratio * h;\n        return function (b) {\n            let nh = (b[1][1] - b[0][1]) / h;\n            return f * nh;\n        };\n    }\n}\nexports.Typography = Typography;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Space_1 = __webpack_require__(7);\nconst Form_1 = __webpack_require__(6);\nconst Bound_1 = __webpack_require__(5);\nconst Pt_1 = __webpack_require__(0);\nconst Util_1 = __webpack_require__(1);\nconst Typography_1 = __webpack_require__(9);\nconst Op_1 = __webpack_require__(2);\n/**\n* CanvasSpace is an implementation of the abstract class Space. It represents a space for HTML Canvas.\n* Learn more about the concept of Space in [this guide](..guide/Space-0500.html)\n*/\nclass CanvasSpace extends Space_1.MultiTouchSpace {\n    /**\n    * Create a CanvasSpace which represents a HTML Canvas Space\n    * @param elem Specify an element by its \"id\" attribute as string, or by the element object itself. An element can be an existing `<canvas>`, or a `<div>` container in which a new `<canvas>` will be created. If left empty, a `<div id=\"pt_container\"><canvas id=\"pt\" /></div>` will be added to DOM. Use css to customize its appearance if needed.\n    * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a \"ready\" event will also be fired from the `<canvas>` element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener(\"ready\")`\n    * @example `new CanvasSpace( \"#myElementID\" )`\n    */\n    constructor(elem, callback) {\n        super();\n        this._pixelScale = 1;\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._offscreen = false;\n        this._initialResize = false;\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pt\";\n        // check element or element id string\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            ;\n            _selector = document.querySelector(elem);\n            _existed = true;\n            this.id = elem;\n        }\n        // if selector is not defined, create a canvas\n        if (!_selector) {\n            this._container = this._createElement(\"div\", this.id + \"_container\");\n            this._canvas = this._createElement(\"canvas\", this.id);\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n            // if selector is element but not canvas, create a canvas inside it\n        }\n        else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n            this._container = _selector;\n            this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n            this._container.appendChild(this._canvas);\n            this._initialResize = true;\n            // if selector is an existing canvas\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n            this._autoResize = false;\n        }\n        // if size is known then set it immediately\n        // if (_existed) {\n        // let b = this._container.getBoundingClientRect();\n        // this.resize( Bound.fromBoundingRect(b) );\n        // }\n        // no mutation observer, so we set a timeout for ready event\n        setTimeout(this._ready.bind(this, callback), 100);\n        // store canvas 2d rendering context\n        this._ctx = this._canvas.getContext('2d');\n    }\n    /**\n    * Helper function to create a DOM element\n    * @param elem element tag name\n    * @param id element id attribute\n    */\n    _createElement(elem = \"div\", id) {\n        let d = document.createElement(elem);\n        d.setAttribute(\"id\", id);\n        return d;\n    }\n    /**\n    * Handle callbacks after element is mounted in DOM\n    * @param callback\n    */\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this._initialResize = false; // unset\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    /**\n    * Set up various options for CanvasSpace. The `opt` parameter is an object with the following fields. This is usually set during instantiation, eg `new CanvasSpace(...).setup( { opt } )`\n    * @param opt an object with optional settings, as follows.\n    * @param opt.bgcolor a hex or rgba string to set initial background color of the canvas, or use `false` or \"transparent\" to set a transparent background. You may also change it later with `clear()`\n    * @param opt.resize a boolean to set whether `<canvas>` size should auto resize to match its container's size. You can also set it manually with `autoSize()`\n    * @param opt.retina a boolean to set if device pixel scaling should be used. This may make drawings on retina displays look sharper but may reduce performance slightly. Default is `true`.\n    * @param opt.offscreen a boolean to set if a duplicate canvas should be created for offscreen rendering. Default is `false`.\n    * @example `space.setup({ bgcolor: \"#f00\", retina: true, resize: true })`\n    */\n    setup(opt) {\n        if (opt.bgcolor)\n            this._bgcolor = opt.bgcolor;\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        if (opt.retina !== false) {\n            let r1 = window.devicePixelRatio || 1;\n            let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n            this._pixelScale = r1 / r2;\n        }\n        if (opt.offscreen) {\n            this._offscreen = true;\n            this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n            this._offCtx = this._offCanvas.getContext('2d');\n        }\n        else {\n            this._offscreen = false;\n        }\n        return this;\n    }\n    /**\n    * Set whether the canvas element should resize when its container is resized.\n    * @param auto a boolean value indicating if auto size is set\n    */\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    /**\n  * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).\n  * @param b a Bound object to resize to\n  * @param evt Optionally pass a resize event\n  */\n    resize(b, evt) {\n        this.bound = b;\n        this._canvas.width = this.bound.size.x * this._pixelScale;\n        this._canvas.height = this.bound.size.y * this._pixelScale;\n        this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n        this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n        if (this._offscreen) {\n            this._offCanvas.width = this.bound.size.x * this._pixelScale;\n            this._offCanvas.height = this.bound.size.y * this._pixelScale;\n            // this._offCanvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n            // this._offCanvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n        }\n        if (this._pixelScale != 1) {\n            this._ctx.scale(this._pixelScale, this._pixelScale);\n            this._ctx.translate(0.5, 0.5);\n            if (this._offscreen) {\n                this._offCtx.scale(this._pixelScale, this._pixelScale);\n                this._offCtx.translate(0.5, 0.5);\n            }\n        }\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        ;\n        this.render(this._ctx);\n        // if it's a valid resize event and space is not playing, repaint the canvas once\n        if (evt && !this.isPlaying)\n            this.playOnce(0);\n        return this;\n    }\n    /**\n    * Window resize handling\n    * @param evt\n    */\n    _resizeHandler(evt) {\n        let b = (this._autoResize || this._initialResize) ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n        if (b) {\n            let box = Bound_1.Bound.fromBoundingRect(b);\n            // Need to compute offset from window scroll. See outerBound calculation in Space's _mouseAction \n            box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n            this.resize(box, evt);\n        }\n    }\n    /**\n    * Set a background color for this canvas. Alternatively, you may use `clear()` function.\n    @param bg background color as hex or rgba string\n    */\n    set background(bg) { this._bgcolor = bg; }\n    get background() { return this._bgcolor; }\n    /**\n    * `pixelScale` property returns a number that let you determine if the screen is \"retina\" (when value >= 2)\n    */\n    get pixelScale() {\n        return this._pixelScale;\n    }\n    /**\n    * Check if an offscreen canvas is created\n    */\n    get hasOffscreen() {\n        return this._offscreen;\n    }\n    /**\n    * Get the rendering context of offscreen canvas (if created via `setup()`)\n    */\n    get offscreenCtx() { return this._offCtx; }\n    /**\n    * Get the offscreen canvas element\n    */\n    get offscreenCanvas() { return this._offCanvas; }\n    /**\n    * Get a new `CanvasForm` for drawing\n    * @see `CanvasForm`\n    */\n    getForm() { return new CanvasForm(this); }\n    /**\n    * Get the html canvas element\n    */\n    get element() {\n        return this._canvas;\n    }\n    /**\n    * Get the parent element that contains the canvas element\n    */\n    get parent() {\n        return this._container;\n    }\n    /**\n     * A property to indicate if the Space is ready\n     */\n    get ready() {\n        return this._isReady;\n    }\n    /**\n    * Get the rendering context of canvas\n    */\n    get ctx() { return this._ctx; }\n    /**\n    * Clear the canvas with its background color. Overrides Space's `clear` function.\n    * @param bg Optionally specify a custom background color in hex or rgba string, or \"transparent\". If not defined, it will use its `bgcolor` property as background color to clear the canvas.\n    */\n    clear(bg) {\n        if (bg)\n            this._bgcolor = bg;\n        let lastColor = this._ctx.fillStyle;\n        if (this._bgcolor && this._bgcolor != \"transparent\") {\n            this._ctx.fillStyle = this._bgcolor;\n            this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        else {\n            this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        this._ctx.fillStyle = lastColor;\n        return this;\n    }\n    /**\n    * Similiar to `clear()` but clear the offscreen canvas instead\n    * @param bg Optionally specify a custom background color in hex or rgba string, or \"transparent\". If not defined, it will use its `bgcolor` property as background color to clear the canvas.\n    */\n    clearOffscreen(bg) {\n        if (this._offscreen) {\n            if (bg) {\n                this._offCtx.fillStyle = bg;\n                this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n            }\n            else {\n                this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n            }\n        }\n        return this;\n    }\n    /**\n    * Main animation function. Call `Space.playItems`.\n    * @param time current time\n    */\n    playItems(time) {\n        if (this._isReady) {\n            this._ctx.save();\n            if (this._offscreen)\n                this._offCtx.save();\n            super.playItems(time);\n            this._ctx.restore();\n            if (this._offscreen)\n                this._offCtx.restore();\n            this.render(this._ctx);\n        }\n    }\n}\nexports.CanvasSpace = CanvasSpace;\n/**\n* CanvasForm is an implementation of abstract class VisualForm. It provide methods to express Pts on CanvasSpace.\n* You may extend CanvasForm to implement your own expressions for CanvasSpace.\n*/\nclass CanvasForm extends Form_1.VisualForm {\n    /**\n    * Create a new CanvasForm. You may also use `space.getForm()` to get the default form.\n    * @param space an instance of CanvasSpace\n    */\n    constructor(space) {\n        super();\n        /**\n        * store common styles so that they can be restored to canvas context when using multiple forms. See `reset()`.\n        */\n        this._style = {\n            fillStyle: \"#f03\", strokeStyle: \"#fff\",\n            lineWidth: 1, lineJoin: \"bevel\", lineCap: \"butt\",\n        };\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx = this._space.ctx;\n                this._ctx.fillStyle = this._style.fillStyle;\n                this._ctx.strokeStyle = this._style.strokeStyle;\n                this._ctx.lineJoin = \"bevel\";\n                this._ctx.font = this._font.value;\n                this._ready = true;\n            } });\n    }\n    /**\n    * get the CanvasSpace instance that this form is associated with\n    */\n    get space() { return this._space; }\n    /**\n    * Toggle whether to draw on offscreen canvas (if offscreen is set in CanvasSpace)\n    * @param off if `true`, draw on offscreen canvas instead of the visible canvas. Default is `true`\n    * @param clear optionally provide a valid color string to fill a bg color. see CanvasSpace's `clearOffscreen` function.\n    */\n    useOffscreen(off = true, clear = false) {\n        if (clear)\n            this._space.clearOffscreen((typeof clear == \"string\") ? clear : null);\n        this._ctx = (this._space.hasOffscreen && off) ? this._space.offscreenCtx : this._space.ctx;\n        return this;\n    }\n    /**\n    * Render the offscreen canvas's content on the visible canvas\n    * @param offset Optional offset on the top-left position when drawing on the visible canvas\n    */\n    renderOffscreen(offset = [0, 0]) {\n        if (this._space.hasOffscreen) {\n            this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n        }\n    }\n    /**\n    * Set current fill style. Provide a valid color string or `false` to specify no fill color.\n    * @example `form.fill(\"#F90\")`, `form.fill(\"rgba(0,0,0,.5\")`, `form.fill(false)`\n    * @param c fill color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle))\n    */\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.filled = c;\n        }\n        else {\n            this.filled = true;\n            this._style.fillStyle = c;\n            this._ctx.fillStyle = c;\n        }\n        return this;\n    }\n    /**\n    * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.\n    * @example `form.stroke(\"#F90\")`, `form.stroke(\"rgba(0,0,0,.5\")`, `form.stroke(false)`, `form.stroke(\"#000\", 0.5, 'round', 'square')`\n    * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))\n    * @param width Optional value (can be floating point) to set line width\n    * @param linejoin Optional string to set line joint style. Can be \"miter\", \"bevel\", or \"round\".\n    * @param linecap Optional string to set line cap style. Can be \"butt\", \"round\", or \"square\".\n    */\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.stroked = c;\n        }\n        else {\n            this.stroked = true;\n            this._style.strokeStyle = c;\n            this._ctx.strokeStyle = c;\n            if (width) {\n                this._ctx.lineWidth = width;\n                this._style.lineWidth = width;\n            }\n            if (linejoin) {\n                this._ctx.lineJoin = linejoin;\n                this._style.lineJoin = linejoin;\n            }\n            if (linecap) {\n                this._ctx.lineCap = linecap;\n                this._style.lineCap = linecap;\n            }\n        }\n        return this;\n    }\n    /**\n    * Set the current font\n    * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties\n    * @param weight Optional font-weight string such as \"bold\"\n    * @param style Optional font-style string such as \"italic\"\n    * @param lineHeight Optional line-height number suchas 1.5\n    * @param family Optional font-family such as \"Helvetica, sans-serif\"\n    * @example `form.font( myFont )`, `form.font(14, \"bold\")`\n    */\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        // If using estimate, reapply it when font changes.\n        if (this._estimateTextWidth)\n            this.fontWidthEstimate(true);\n        return this;\n    }\n    /**\n     * Set whether to use ctx.measureText or a faster but less accurate heuristic function.\n     * @param estimate `true` to use heuristic function, or `false` to use ctx.measureText\n     */\n    fontWidthEstimate(estimate = true) {\n        this._estimateTextWidth = (estimate) ? Typography_1.Typography.textWidthEstimator(((c) => this._ctx.measureText(c).width)) : undefined;\n        return this;\n    }\n    /**\n     * Get the width of this text. It will return an actual measurement or an estimate based on `fontWidthEstimate` setting. Default is an actual measurement using canvas context's measureText.\n     * @param c a string of text contents\n     */\n    getTextWidth(c) {\n        return (!this._estimateTextWidth) ? this._ctx.measureText(c).width : this._estimateTextWidth(c);\n    }\n    /**\n     * Truncate text to fit width\n     * @param str text to truncate\n     * @param width width to fit\n     * @param tail text to indicate overflow such as \"...\". Default is empty \"\".\n     */\n    _textTruncate(str, width, tail = \"\") {\n        return Typography_1.Typography.truncate(this.getTextWidth.bind(this), str, width, tail);\n    }\n    /**\n     * Align text within a rectangle box\n     * @param box a Group that defines a rectangular box\n     * @param vertical a string that specifies the vertical alignment in the box: \"top\", \"bottom\", \"middle\", \"start\", \"end\"\n     * @param offset Optional offset from the edge (like padding)\n     * @param center Optional center position\n     */\n    _textAlign(box, vertical, offset, center) {\n        if (!center)\n            center = Op_1.Rectangle.center(box);\n        var px = box[0][0];\n        if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n            px = box[1][0];\n        }\n        else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n            px = center[0];\n        }\n        var py = center[1];\n        if (vertical == \"top\" || vertical == \"start\") {\n            py = box[0][1];\n        }\n        else if (vertical == \"end\" || vertical == \"bottom\") {\n            py = box[1][1];\n        }\n        return (offset) ? new Pt_1.Pt(px + offset[0], py + offset[1]) : new Pt_1.Pt(px, py);\n    }\n    /**\n    * Reset the rendering context's common styles to this form's styles. This supports using multiple forms on the same canvas context.\n    */\n    reset() {\n        for (let k in this._style) {\n            if (this._style.hasOwnProperty(k)) {\n                this._ctx[k] = this._style[k];\n            }\n        }\n        this._font = new Form_1.Font();\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    _paint() {\n        if (this._filled)\n            this._ctx.fill();\n        if (this._stroked)\n            this._ctx.stroke();\n    }\n    /**\n    * Draws a point\n    * @param p a Pt object\n    * @param radius radius of the point. Default is 5.\n    * @param shape The shape of the point. Defaults to \"square\", but it can be \"circle\" or a custom shape function in your own implementation.\n    * @example `form.point( p )`, `form.point( p, 10, \"circle\" )`\n    */\n    point(p, radius = 5, shape = \"square\") {\n        if (!p)\n            return;\n        if (!CanvasForm[shape])\n            throw new Error(`${shape} is not a static function of CanvasForm`);\n        CanvasForm[shape](this._ctx, p, radius);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw a circle\n    * @param ctx canvas rendering context\n    * @param pt center position of the circle\n    * @param radius radius of the circle\n    */\n    static circle(ctx, pt, radius = 10) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, 0, Util_1.Const.two_pi, false);\n        ctx.closePath();\n    }\n    /**\n    * Draw a circle\n    * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]\n    * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)\n    */\n    circle(pts) {\n        CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw an arc.\n    * @param ctx canvas rendering context\n    * @param pt center position\n    * @param radius radius of the arc circle\n    * @param startAngle start angle of the arc\n    * @param endAngle end angle of the arc\n    * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.\n    */\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n    }\n    /**\n    * Draw an arc.\n    * @param pt center position\n    * @param radius radius of the arc circle\n    * @param startAngle start angle of the arc\n    * @param endAngle end angle of the arc\n    * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.\n    */\n    arc(pt, radius, startAngle, endAngle, cc) {\n        CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw a square\n    * @param ctx canvas rendering context\n    * @param pt center position of the square\n    * @param halfsize half size of the square\n    */\n    static square(ctx, pt, halfsize) {\n        if (!pt)\n            return;\n        let x1 = pt[0] - halfsize;\n        let y1 = pt[1] - halfsize;\n        let x2 = pt[0] + halfsize;\n        let y2 = pt[1] + halfsize;\n        // faster than using `rect`\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1, y2);\n        ctx.lineTo(x2, y2);\n        ctx.lineTo(x2, y1);\n        ctx.closePath();\n    }\n    /**\n     * Draw a square, given a center and its half-size\n     * @param pt center Pt\n     * @param halfsize half-size\n     */\n    square(pt, halfsize) {\n        CanvasForm.square(this._ctx, pt, halfsize);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw a line\n    * @param ctx canvas rendering context\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    static line(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n    }\n    /**\n    * Draw a line or polyline\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    line(pts) {\n        CanvasForm.line(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw polygon\n    * @param ctx canvas rendering context\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    static polygon(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n        ctx.closePath();\n    }\n    /**\n    * Draw a polygon\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    polygon(pts) {\n        CanvasForm.polygon(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw a rectangle\n    * @param ctx canvas rendering context\n    * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.\n    */\n    static rect(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        ctx.lineTo(pts[0][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[0][1]);\n        ctx.closePath();\n    }\n    /**\n    * Draw a rectangle\n    * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.\n    */\n    rect(pts) {\n        CanvasForm.rect(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    /**\n    * A static function to draw text\n    * @param ctx canvas rendering context\n    * @param `pt` a Point object to specify the anchor point\n    * @param `txt` a string of text to draw\n    * @param `maxWidth` specify a maximum width per line\n    */\n    static text(ctx, pt, txt, maxWidth) {\n        if (!pt)\n            return;\n        ctx.fillText(txt, pt[0], pt[1], maxWidth);\n    }\n    /**\n    * Draw text on canvas\n    * @param `pt` a Pt or numeric array to specify the anchor point\n    * @param `txt` text\n    * @param `maxWidth` specify a maximum width per line\n    */\n    text(pt, txt, maxWidth) {\n        CanvasForm.text(this._ctx, pt, txt, maxWidth);\n        return this;\n    }\n    /**\n     * Fit a single-line text in a rectangular box\n     * @param box a rectangle box defined by a Group\n     * @param txt string of text\n     * @param tail text to indicate overflow such as \"...\". Default is empty \"\".\n     * @param verticalAlign \"top\", \"middle\", or \"bottom\" to specify vertical alignment inside the box\n     * @param overrideBaseline If `true`, use the corresponding baseline as verticalAlign. If `false`, use the current canvas context's textBaseline setting. Default is `true`.\n     */\n    textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n        if (overrideBaseline)\n            this._ctx.textBaseline = verticalAlign;\n        let size = Op_1.Rectangle.size(box);\n        let t = this._textTruncate(txt, size[0], tail);\n        this.text(this._textAlign(box, verticalAlign), t[0]);\n        return this;\n    }\n    /**\n     * Fit multi-line text in a rectangular box. Note that this will also set canvas context's textBaseline to \"top\".\n     * @param box a rectangle box defined by a Group\n     * @param txt string of text\n     * @param lineHeight line height as a ratio of font size. Default is 1.2.\n     * @param verticalAlign \"top\", \"middle\", or \"bottom\" to specify vertical alignment inside the box\n     * @param crop a boolean to specify whether to crop text when overflowing\n     */\n    paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n        let size = Op_1.Rectangle.size(box);\n        this._ctx.textBaseline = \"top\"; // override textBaseline\n        let lstep = this._font.size * lineHeight;\n        // find next lines recursively\n        let nextLine = (sub, buffer = [], cc = 0) => {\n            if (!sub)\n                return buffer;\n            if (crop && cc * lstep > size[1] - lstep * 2)\n                return buffer;\n            if (cc > 10000)\n                throw new Error(\"max recursion reached (10000)\");\n            let t = this._textTruncate(sub, size[0], \"\");\n            // new line\n            let newln = t[0].indexOf(\"\\n\");\n            if (newln >= 0) {\n                buffer.push(t[0].substr(0, newln));\n                return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n            }\n            // word wrap\n            let dt = t[0].lastIndexOf(\" \") + 1;\n            if (dt <= 0 || t[1] === sub.length)\n                dt = undefined;\n            let line = t[0].substr(0, dt);\n            buffer.push(line);\n            return (t[1] <= 0 || t[1] === sub.length) ? buffer : nextLine(sub.substr((dt || t[1])), buffer, cc + 1);\n        };\n        let lines = nextLine(txt); // go through all lines\n        let lsize = lines.length * lstep; // total height\n        let lbox = box;\n        if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n            let lpad = (size[1] - lsize) / 2;\n            if (crop)\n                lpad = Math.max(0, lpad);\n            lbox = new Pt_1.Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n        }\n        else if (verticalAlign == \"bottom\") {\n            lbox = new Pt_1.Group(box[0].$add(0, size[1] - lsize), box[1]);\n        }\n        else {\n            lbox = new Pt_1.Group(box[0], box[0].$add(size[0], lsize));\n        }\n        let center = Op_1.Rectangle.center(lbox);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n        }\n        return this;\n    }\n    /**\n     * Set text alignment and baseline (eg, vertical-align)\n     * @param alignment Canvas' textAlign option: \"left\", \"right\", \"center\", \"start\", or \"end\"\n     * @param baseline Canvas' textBaseline option: \"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\". For convenience, you can also use \"center\" (same as \"middle\"), and \"baseline\" (same as \"alphabetic\")\n     */\n    alignText(alignment = \"left\", baseline = \"alphabetic\") {\n        if (baseline == \"center\")\n            baseline = \"middle\";\n        if (baseline == \"baseline\")\n            baseline = \"alphabetic\";\n        this._ctx.textAlign = alignment;\n        this._ctx.textBaseline = baseline;\n        return this;\n    }\n    /**\n    * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.\n    * @param txt text\n    */\n    log(txt) {\n        let w = this._ctx.measureText(txt).width + 20;\n        this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n        this.fill(\"#fff\").text([10, 14], txt);\n        return this;\n    }\n}\nexports.CanvasForm = CanvasForm;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pt_1 = __webpack_require__(0);\nconst Util_1 = __webpack_require__(1);\nconst Num_1 = __webpack_require__(3);\n/**\n * Color is a subclass of Pt. You can think of a color as a point in a color space. The Color class provides support for many color spaces.\n */\nclass Color extends Pt_1.Pt {\n    /**\n     * Create a Color. Same as creating a Pt.\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties\n     */\n    constructor(...args) {\n        super(...args);\n        this._mode = \"rgb\";\n        this._isNorm = false;\n    }\n    /**\n     * Create a Color object with defaults to 4 dimensions\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties\n     */\n    static from(...args) {\n        let p = [1, 1, 1, 1];\n        let c = Util_1.Util.getArgs(args);\n        for (let i = 0, len = p.length; i < len; i++) {\n            if (i < c.length)\n                p[i] = c[i];\n        }\n        return new Color(p);\n    }\n    /**\n     * Convert a rgb hex string like #FF0000 or #F00 to a Color object\n     * @param hex a hex string, with optional '#' prefix\n     */\n    static fromHex(hex) {\n        if (hex[0] == \"#\")\n            hex = hex.substr(1); // remove '#' if needed\n        if (hex.length <= 3) {\n            let fn = (i) => hex[i] || \"F\";\n            hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n        }\n        let alpha = 1;\n        if (hex.length === 8) {\n            alpha = hex.substr(6) && 0xFF / 255;\n            hex = hex.substring(0, 6);\n        }\n        let hexVal = parseInt(hex, 16);\n        return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n    }\n    /**\n     * Create RGB Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static rgb(...args) { return Color.from(...args).toMode(\"rgb\"); }\n    /**\n     * Create HSL Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static hsl(...args) { return Color.from(...args).toMode(\"hsl\"); }\n    /**\n     * Create HSB Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static hsb(...args) { return Color.from(...args).toMode(\"hsb\"); }\n    /**\n     * Create LAB Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static lab(...args) { return Color.from(...args).toMode(\"lab\"); }\n    /**\n     * Create LCH Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static lch(...args) { return Color.from(...args).toMode(\"lch\"); }\n    /**\n     * Create LUV Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static luv(...args) { return Color.from(...args).toMode(\"luv\"); }\n    /**\n     * Create XYZ Color\n     * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.\n     */\n    static xyz(...args) { return Color.from(...args).toMode(\"xyz\"); }\n    /**\n     * Get a Color object whose values are the maximum of its mode\n     * @param mode a mode string such as \"rgb\" or \"lab\"\n     * @example Color.maxValue(\"rgb\") will return a rgb Color object with values (255,255,255)\n     */\n    static maxValues(mode) { return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]); }\n    /**\n     * Get a hex string such as \"#FF0000\". Same as `toString(\"hex\")`\n     */\n    get hex() { return this.toString(\"hex\"); }\n    /**\n     * Get a rgb string such as \"rgb(255,0,0)\". Same as `toString(\"rgb\")`\n     */\n    get rgb() { return this.toString(\"rgb\"); }\n    /**\n     * Get a rgba string such as \"rgb(255,0,0,0.5)\". Same as `toString(\"rgba\")`\n     */\n    get rgba() { return this.toString(\"rgba\"); }\n    /**\n     * Clone this Color\n     */\n    clone() {\n        let c = new Color(this);\n        c.toMode(this._mode);\n        return c;\n    }\n    /**\n     * Convert this color from current color space to another color space\n     * @param mode a ColorType string: \"rgb\" \"hsl\" \"hsb\" \"lab\" \"lch\" \"luv\" \"xyz\";\n     * @param convert if `true`, convert this Color to the new color space specified in `mode`. Default is `false`, which only sets the color mode without converting color values.\n     */\n    toMode(mode, convert = false) {\n        if (convert) {\n            let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n            if (Color[fname]) {\n                this.to(Color[fname](this, this._isNorm, this._isNorm));\n            }\n            else {\n                throw new Error(\"Cannot convert color with \" + fname);\n            }\n        }\n        this._mode = mode;\n        return this;\n    }\n    /**\n     * Get this Color's mode\n     */\n    get mode() { return this._mode; }\n    // rgb\n    get r() { return this[0]; }\n    set r(n) { this[0] = n; }\n    get g() { return this[1]; }\n    set g(n) { this[1] = n; }\n    get b() { return this[1]; }\n    set b(n) { this[2] = n; }\n    // hsl, hsb\n    get h() { return (this._mode == \"lch\") ? this[2] : this[0]; }\n    set h(n) {\n        let i = (this._mode == \"lch\") ? 2 : 0;\n        this[i] = n;\n    }\n    get s() { return this[1]; }\n    set s(n) { this[1] = n; }\n    get l() { return (this._mode == \"hsl\") ? this[2] : this[0]; }\n    set l(n) {\n        let i = (this._mode == \"hsl\") ? 2 : 0;\n        this[i] = n;\n    }\n    // lab, lch, luv\n    get a() { return this[1]; }\n    set a(n) { this[1] = n; }\n    get c() { return this[1]; }\n    set c(n) { this[1] = n; }\n    get u() { return this[1]; }\n    set u(n) { this[1] = n; }\n    get v() { return this[1]; }\n    set v(n) { this[2] = n; }\n    /**\n     * Get alpha value\n     */\n    get alpha() { return (this.length > 3) ? this[3] : 1; }\n    /**\n     * Normalize the color values to between 0 to 1, or revert it back to the min/max values in current color mode\n     * @param toNorm a boolean value specifying whether to normalize (`true`) or revert (`false`)\n     */\n    normalize(toNorm = true) {\n        if (this._isNorm == toNorm)\n            return this;\n        let ranges = Color.ranges[this._mode];\n        for (let i = 0; i < 3; i++) {\n            this[i] = (!toNorm)\n                ? Num_1.Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1])\n                : Num_1.Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n        }\n        this._isNorm = toNorm;\n        return this;\n    }\n    /**\n     * Like `normalize()` but returns as a new Color\n     * @param toNorm a boolean value specifying whether to normalize (`true`) or revert (`false`)\n     * @returns new Color\n     */\n    $normalize(toNorm = true) { return this.clone().normalize(toNorm); }\n    /**\n     * Convert this Color to a string. It can be used to get a hex or rgb string for use in rendering\n     * @param format \"hex\", \"rgb\", \"rgba\", or \"mode\" which means using current color mode label. Default is \"mode\".\n     */\n    toString(format = \"mode\") {\n        if (format == \"hex\") {\n            let _hex = (n) => {\n                let s = Math.floor(n).toString(16);\n                return (s.length < 2) ? '0' + s : s;\n            };\n            return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n        }\n        else if (format == \"rgba\") {\n            return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha}`;\n        }\n        else if (format == \"rgb\") {\n            return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])}`;\n        }\n        else {\n            return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n        }\n    }\n    /**\n     * Convert RGB to HSL\n     * @param rgb a RGB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new HSL Color\n     */\n    static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let h = (max + min) / 2;\n        let s = h;\n        let l = h;\n        if (max == min) {\n            h = 0;\n            s = 0; // achromatic\n        }\n        else {\n            let d = max - min;\n            s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);\n            h = 0;\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsl(((normalizedOutput) ? h / 60 : h * 60), s, l, rgb.alpha);\n    }\n    /**\n     * Convert HSL to RGB\n     * @param hsl a HSL Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new RGB Color\n     */\n    static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, l] = hsl;\n        if (!normalizedInput)\n            h = h / 360;\n        if (s == 0)\n            return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n        let q = (l <= 0.5) ? l * (1 + s) : l + s - (l * s);\n        let p = 2 * l - q;\n        let convert = (t) => {\n            t = (t < 0) ? t + 1 : (t > 1) ? t - 1 : t;\n            if (t * 6 < 1) {\n                return p + (q - p) * t * 6;\n            }\n            else if (t * 2 < 1) {\n                return q;\n            }\n            else if (t * 3 < 2) {\n                return p + (q - p) * ((2 / 3) - t) * 6;\n            }\n            else {\n                return p;\n            }\n        };\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * convert((h + 1 / 3)), sc * convert(h), sc * convert((h - 1 / 3)), hsl.alpha);\n    }\n    /**\n     * Convert RGB to HSB\n     * @param rgb a RGB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new HSB Color\n     */\n    static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let d = max - min;\n        let h = 0;\n        let s = (max === 0) ? 0 : d / max;\n        let v = max;\n        if (max != min) {\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsb(((normalizedOutput) ? h / 60 : h * 60), s, v, rgb.alpha);\n    }\n    /**\n     * Convert HSB to RGB\n     * @param hsb a HSB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new RGB Color\n     */\n    static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, v] = hsb;\n        if (!normalizedInput)\n            h = h / 360;\n        let i = Math.floor(h * 6);\n        let f = h * 6 - i;\n        let p = v * (1 - s);\n        let q = v * (1 - f * s);\n        let t = v * (1 - (1 - f) * s);\n        let pick = [\n            [v, t, p], [q, v, p], [p, v, t],\n            [p, q, v], [t, p, v], [v, p, q]\n        ];\n        let c = pick[i % 6];\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n    }\n    /**\n   * Convert RGB to LAB\n   * @param rgb a RGB Color\n   * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n   * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n   * @returns a new LAB Color\n   */\n    static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    /**\n     * Convert LAB to RGB\n     * @param lab a LAB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new RGB Color\n     */\n    static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n    }\n    /**\n     * Convert RGB to LCH\n     * @param rgb a RGB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new LCH Color\n     */\n    static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n    }\n    /**\n     * Convert LCH to RGB\n     * @param lch a LCH Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new RGB Color\n     */\n    static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n    }\n    /**\n     * Convert RGB to LUV\n     * @param rgb a RGB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new LUV Color\n     */\n    static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    /**\n     * Convert LUV to RGB\n     * @param rgb a RGB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new RGB Color\n     */\n    static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? luv.$normalize(false) : luv;\n        return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n    }\n    /**\n     * Convert RGB to XYZ\n     * @param rgb a RGB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new XYZ Color\n     */\n    static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (!normalizedInput) ? rgb.$normalize() : rgb.clone();\n        for (let i = 0; i < 3; i++) {\n            c[i] = (c[i] > 0.04045) ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n            if (!normalizedOutput)\n                c[i] = c[i] * 100;\n        }\n        let cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    /**\n     * Convert XYZ to RGB\n     * @param xyz a XYZ Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new RGB Color\n     */\n    static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (!normalizedInput) ? xyz.$normalize() : xyz;\n        let rgb = [\n            x * 3.2404542 + y * -1.5371385 + z * -0.4985314,\n            x * -0.9692660 + y * 1.8760108 + z * 0.0415560,\n            x * 0.0556434 + y * -0.2040259 + z * 1.0572252\n        ];\n        // convert xyz to rgb. Note that not all colors are visible in rgb, so here we bound rgb between 0 to 1\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = (rgb[i] < 0) ? 0 : (rgb[i] > 0.0031308) ? (1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055) : (12.92 * rgb[i]);\n            rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n            if (!normalizedOutput)\n                rgb[i] = Math.round(rgb[i] * 255);\n        }\n        let cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    /**\n     * Convert XYZ to LAB\n     * @param xyz a XYZ Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new LAB Color\n     */\n    static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? xyz.$normalize(false) : xyz.clone();\n        // adjust for D65  \n        c.divide(Color.D65);\n        let fn = (n) => (n > 0.008856) ? Math.pow(n, 1 / 3) : (7.787 * n) + 16 / 116;\n        let cy = fn(c[1]);\n        let cc = Color.lab((116 * cy) - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    /**\n     * Convert LAB to XYZ\n     * @param lab a LAB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new XYZ Color\n     */\n    static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let y = (c[0] + 16) / 116;\n        let x = (c[1] / 500) + y;\n        let z = y - c[2] / 200;\n        let fn = (n) => {\n            let nnn = n * n * n;\n            return (nnn > 0.008856) ? nnn : (n - 16 / 116) / 7.787;\n        };\n        let d = Color.D65;\n        // adjusted\n        let cc = Color.xyz(\n        // Math.max(0, Math.min( 100, d[0] * fn(x) )),\n        // Math.max(0, Math.min( 100, d[1] * fn(y) )),\n        // Math.max(0, Math.min( 100, d[2] * fn(z) )),\n        Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    /**\n     * Convert XYZ to LUV\n     * @param xyz a XYZ Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new LUV Color\n     */\n    static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (normalizedInput) ? xyz.$normalize(false) : xyz;\n        let u = (4 * x) / (x + (15 * y) + (3 * z));\n        let v = (9 * y) / (x + (15 * y) + (3 * z));\n        y = y / 100;\n        y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y + 16 / 116);\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let L = (116 * y) - 16;\n        return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n    }\n    /**\n     * Convert LUV to XYZ\n     * @param luv a LUV Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new XYZ Color\n     */\n    static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n        let [l, u, v] = (normalizedInput) ? luv.$normalize(false) : luv;\n        let y = (l + 16) / 116;\n        let cubeY = y * y * y;\n        y = (cubeY > 0.008856) ? cubeY : (y - 16 / 116) / 7.787;\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        u = u / (13 * l) + refU;\n        v = v / (13 * l) + refV;\n        y = y * 100;\n        let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n        let z = (9 * y - (15 * v * y) - (v * x)) / (3 * v);\n        return Color.xyz(x, y, z, luv.alpha);\n    }\n    /**\n     * Convert LAB to LCH\n     * @param lab a LAB Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new LCH Color\n     */\n    static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let h = Num_1.Geom.toDegree(Num_1.Geom.boundRadian(Math.atan2(c[2], c[1]))); // 0 to 360 degrees\n        return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n    }\n    /**\n     * Convert LCH to LAB\n     * @param lch a LCH Color\n     * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.\n     * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.\n     * @returns a new LAB Color\n     */\n    static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        let rad = Num_1.Geom.toRadian(c[2]);\n        return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n    }\n}\n// XYZ property for Standard Observer 2deg, Daylight/sRGB illuminant D65\nColor.D65 = new Pt_1.Pt(95.047, 100, 108.883, 1);\n/**\n * Value range for each color space\n */\nColor.ranges = {\n    rgb: new Pt_1.Group(new Pt_1.Pt(0, 255), new Pt_1.Pt(0, 255), new Pt_1.Pt(0, 255)),\n    hsl: new Pt_1.Group(new Pt_1.Pt(0, 360), new Pt_1.Pt(0, 1), new Pt_1.Pt(0, 1)),\n    hsb: new Pt_1.Group(new Pt_1.Pt(0, 360), new Pt_1.Pt(0, 1), new Pt_1.Pt(0, 1)),\n    lab: new Pt_1.Group(new Pt_1.Pt(0, 100), new Pt_1.Pt(-128, 127), new Pt_1.Pt(-128, 127)),\n    lch: new Pt_1.Group(new Pt_1.Pt(0, 100), new Pt_1.Pt(0, 100), new Pt_1.Pt(0, 360)),\n    luv: new Pt_1.Group(new Pt_1.Pt(0, 100), new Pt_1.Pt(-134, 220), new Pt_1.Pt(-140, 122)),\n    xyz: new Pt_1.Group(new Pt_1.Pt(0, 100), new Pt_1.Pt(0, 100), new Pt_1.Pt(0, 100))\n};\nexports.Color = Color;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pt_1 = __webpack_require__(0);\nconst Op_1 = __webpack_require__(2);\nconst Util_1 = __webpack_require__(1);\nconst Num_1 = __webpack_require__(3);\nconst LinearAlgebra_1 = __webpack_require__(4);\n/**\n * The `Create` class provides various convenient functions to create structures or shapes.\n */\nclass Create {\n    /**\n     * Create a set of random points inside a bounday\n     * @param bound the rectangular boundary\n     * @param count number of random points to create\n     * @param dimensions number of dimensions in each point\n     */\n    static distributeRandom(bound, count, dimensions = 2) {\n        let pts = new Pt_1.Group();\n        for (let i = 0; i < count; i++) {\n            let p = [bound.x + Math.random() * bound.width];\n            if (dimensions > 1)\n                p.push(bound.y + Math.random() * bound.height);\n            if (dimensions > 2)\n                p.push(bound.z + Math.random() * bound.depth);\n            pts.push(new Pt_1.Pt(p));\n        }\n        return pts;\n    }\n    /**\n     * Create a set of points that distribute evenly on a line\n     * @param line a Group representing a line\n     * @param count number of points to create\n     */\n    static distributeLinear(line, count) {\n        let ln = Op_1.Line.subpoints(line, count - 2);\n        ln.unshift(line[0]);\n        ln.push(line[line.length - 1]);\n        return ln;\n    }\n    /**\n     * Create an evenly distributed set of points (like a grid of points) inside a boundary.\n     * @param bound the rectangular boundary\n     * @param columns number of columns\n     * @param rows number of rows\n     * @param orientation a Pt or number array to specify where the point should be inside a cell. Default is [0.5, 0.5] which places the point in the middle.\n     * @returns a Group of Pts\n     */\n    static gridPts(bound, columns, rows, orientation = [0.5, 0.5]) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).$divide(columns, rows);\n        let offset = unit.$multiply(orientation);\n        let g = new Pt_1.Group();\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(bound.topLeft.$add(unit.$multiply(c, r)).add(offset));\n            }\n        }\n        return g;\n    }\n    /**\n     * Create a grid inside a boundary\n     * @param bound the rectangular boundary\n     * @param columns number of columns\n     * @param rows number of rows\n     * @returns an array of Groups, where each group represents a rectangular cell\n     */\n    static gridCells(bound, columns, rows) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).divide(columns, rows); // subtract 1 to fill whole border of rectangles\n        let g = [];\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(new Pt_1.Group(bound.topLeft.$add(unit.$multiply(c, r)), bound.topLeft.$add(unit.$multiply(c, r).add(unit))));\n            }\n        }\n        return g;\n    }\n    /**\n     * Create a set of Pts around a circular path\n     * @param center circle center\n     * @param radius circle radius\n     * @param count number of Pts to create\n     */\n    static radialPts(center, radius, count) {\n        let g = new Pt_1.Group();\n        let a = Util_1.Const.two_pi / count;\n        for (let i = 0; i < count; i++) {\n            g.push(new Pt_1.Pt(center).toAngle(a * i - Util_1.Const.half_pi, radius, true));\n        }\n        return g;\n    }\n    /**\n     * Given a group of Pts, return a new group of `Noise` Pts.\n     * @param pts a Group or an array of Pts\n     * @param dx small increment value in x dimension\n     * @param dy small increment value in y dimension\n     * @param rows Optional row count to generate 2D noise\n     * @param columns Optional column count to generate 2D noise\n     */\n    static noisePts(pts, dx = 0.01, dy = 0.01, rows = 0, columns = 0) {\n        let seed = Math.random();\n        let g = new Pt_1.Group();\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let np = new Noise(pts[i]);\n            let r = (rows && rows > 0) ? Math.floor(i / rows) : i;\n            let c = (columns && columns > 0) ? i % columns : i;\n            np.initNoise(dx * c, dy * r);\n            np.seed(seed);\n            g.push(np);\n        }\n        return g;\n    }\n    /**\n     * Create a Delaunay Group. Use the `.delaunay()` and `.voronoi()` functions in the returned group to generate tessellations.\n     * @param pts a Group or an array of Pts\n     * @returns an instance of the Delaunay class\n     */\n    static delaunay(pts) {\n        return Delaunay.from(pts);\n    }\n}\nexports.Create = Create;\n/**\n * Perlin noise gradient indices\n */\nconst grad3 = [\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\n    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]\n];\n/**\n * Perlin noise permutation table\n */\nconst permTable = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 9, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n];\n/**\n * A class to generate Perlin noise. Currently it implements a basic 2D noise. More to follow.\n * Based on https://gist.github.com/banksean/304522\n */\nclass Noise extends Pt_1.Pt {\n    /**\n     * Create a Noise Pt that's capable of generating noise\n     * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties\n     */\n    constructor(...args) {\n        super(...args);\n        this.perm = [];\n        this._n = new Pt_1.Pt(0.01, 0.01);\n        // For easier index wrapping, double the permutation table length\n        this.perm = permTable.concat(permTable);\n    }\n    /**\n     * Set the initial noise values\n     * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties\n     * @example `noise.initNoise( 0.01, 0.1 )`\n     */\n    initNoise(...args) {\n        this._n = new Pt_1.Pt(...args);\n    }\n    /**\n     * Add a small increment to the noise values\n     * @param x step in x dimension\n     * @param y step in y dimension\n     */\n    step(x = 0, y = 0) {\n        this._n.add(x, y);\n    }\n    /**\n     * Specify a seed for this Noise\n     * @param s seed value\n     */\n    seed(s) {\n        if (s > 0 && s < 1)\n            s *= 65536;\n        s = Math.floor(s);\n        if (s < 256)\n            s |= s << 8;\n        for (let i = 0; i < 255; i++) {\n            let v = (i & 1) ? permTable[i] ^ (s & 255) : permTable[i] ^ ((s >> 8) & 255);\n            this.perm[i] = this.perm[i + 256] = v;\n        }\n    }\n    /**\n     * Generate a 2D Perlin noise value\n     */\n    noise2D() {\n        let i = Math.floor(this._n[0]) % 255;\n        let j = Math.floor(this._n[1]) % 255;\n        let x = (this._n[0] % 255) - i;\n        let y = (this._n[1] % 255) - j;\n        let n00 = LinearAlgebra_1.Vec.dot(grad3[(i + this.perm[j]) % 12], [x, y, 0]);\n        let n01 = LinearAlgebra_1.Vec.dot(grad3[(i + this.perm[j + 1]) % 12], [x, y - 1, 0]);\n        let n10 = LinearAlgebra_1.Vec.dot(grad3[(i + 1 + this.perm[j]) % 12], [x - 1, y, 0]);\n        let n11 = LinearAlgebra_1.Vec.dot(grad3[(i + 1 + this.perm[j + 1]) % 12], [x - 1, y - 1, 0]);\n        let _fade = (f) => f * f * f * (f * (f * 6 - 15) + 10);\n        let tx = _fade(x);\n        return Num_1.Num.lerp(Num_1.Num.lerp(n00, n10, tx), Num_1.Num.lerp(n01, n11, tx), _fade(y));\n    }\n}\nexports.Noise = Noise;\n/**\n * Delaunay is a Group of Pts that can generate Delaunay and Voronoi tessellations. The triangulation algorithm is ported from [Pt](https://github.com/williamngan/pt)\n * This implementation is based on [Paul Bourke's algorithm](http://paulbourke.net/papers/triangulate/)\n * with reference to its [javascript implementation by ironwallaby](https://github.com/ironwallaby/delaunay)\n */\nclass Delaunay extends Pt_1.Group {\n    constructor() {\n        super(...arguments);\n        this._mesh = [];\n    }\n    /**\n     * Generate Delaunay triangles. This function also caches the mesh that is used to generate Voronoi tessellation in `voronoi()`.\n     * @param triangleOnly if true, returns an array of triangles in Groups, otherwise return the whole DelaunayShape\n     * @returns an array of Groups or an array of DelaunayShapes `{i, j, k, triangle, circle}` which records the indices of the vertices, and the calculated triangles and circumcircles\n     */\n    delaunay(triangleOnly = true) {\n        if (this.length < 3)\n            return [];\n        this._mesh = [];\n        let n = this.length;\n        // sort the points and store the sorted index\n        let indices = [];\n        for (let i = 0; i < n; i++)\n            indices[i] = i;\n        indices.sort((i, j) => this[j][0] - this[i][0]);\n        // duplicate the points list and add super triangle's points to it\n        let pts = this.slice();\n        let st = this._superTriangle();\n        pts = pts.concat(st);\n        // arrays to store edge buffer and opened triangles\n        let opened = [this._circum(n, n + 1, n + 2, st)];\n        let closed = [];\n        let tris = [];\n        // Go through each point using the sorted indices\n        for (let i = 0, len = indices.length; i < len; i++) {\n            let c = indices[i];\n            let edges = [];\n            let j = opened.length;\n            if (!this._mesh[c])\n                this._mesh[c] = {};\n            // Go through each opened triangles\n            while (j--) {\n                let circum = opened[j];\n                let radius = circum.circle[1][0];\n                let d = pts[c].$subtract(circum.circle[0]);\n                // if point is to the right of circumcircle, add it to closed list and don't check again\n                if (d[0] > 0 && d[0] * d[0] > radius * radius) {\n                    closed.push(circum);\n                    tris.push(circum.triangle);\n                    opened.splice(j, 1);\n                    continue;\n                }\n                // if it's outside the circumcircle, skip\n                if (d[0] * d[0] + d[1] * d[1] - radius * radius > Util_1.Const.epsilon) {\n                    continue;\n                }\n                // otherwise it's inside the circumcircle, so we add to edge buffer and remove it from the opened list\n                edges.push(circum.i, circum.j, circum.j, circum.k, circum.k, circum.i);\n                opened.splice(j, 1);\n            }\n            // dedup edges\n            Delaunay._dedupe(edges);\n            // Go through the edge buffer and create a triangle for each edge\n            j = edges.length;\n            while (j > 1) {\n                opened.push(this._circum(edges[--j], edges[--j], c, false, pts));\n            }\n        }\n        for (let i = 0, len = opened.length; i < len; i++) {\n            let o = opened[i];\n            if (o.i < n && o.j < n && o.k < n) {\n                closed.push(o);\n                tris.push(o.triangle);\n                this._cache(o);\n            }\n        }\n        return (triangleOnly) ? tris : closed;\n    }\n    /**\n     * Generate Voronoi cells. `delaunay()` must be called before calling this function.\n     * @returns an array of Groups, each of which represents a Voronoi cell\n     */\n    voronoi() {\n        let vs = [];\n        let n = this._mesh;\n        for (let i = 0, len = n.length; i < len; i++) {\n            vs.push(this.neighborPts(i, true));\n        }\n        return vs;\n    }\n    /**\n     * Get the cached mesh. The mesh is an array of objects, each of which representing the enclosing triangles around a Pt in this Delaunay group\n     * @return an array of objects that store a series of DelaunayShapes\n     */\n    mesh() {\n        return this._mesh;\n    }\n    /**\n     * Given an index of a Pt in this Delaunay Group, returns its neighboring Pts in the network\n     * @param i index of a Pt\n     * @param sort if true, sort the neighbors so that their edges will form a polygon\n     * @returns an array of Pts\n     */\n    neighborPts(i, sort = false) {\n        let cs = new Pt_1.Group();\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k].circle[0]);\n        }\n        return (sort) ? Num_1.Geom.sortEdges(cs) : cs;\n    }\n    /**\n     * Given an index of a Pt in this Delaunay Group, returns its neighboring DelaunayShapes\n     * @param i index of a Pt\n     * @returns an array of DelaunayShapes `{i, j, k, triangle, circle}`\n     */\n    neighbors(i) {\n        let cs = [];\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k]);\n        }\n        return cs;\n    }\n    /**\n     * Record a DelaunayShape in the mesh\n     * @param o DelaunayShape instance\n     */\n    _cache(o) {\n        this._mesh[o.i][`${Math.min(o.j, o.k)}-${Math.max(o.j, o.k)}`] = o;\n        this._mesh[o.j][`${Math.min(o.i, o.k)}-${Math.max(o.i, o.k)}`] = o;\n        this._mesh[o.k][`${Math.min(o.i, o.j)}-${Math.max(o.i, o.j)}`] = o;\n    }\n    /**\n     * Get the initial \"super triangle\" that contains all the points in this set\n     * @returns a Group representing a triangle\n     */\n    _superTriangle() {\n        let minPt = this[0];\n        let maxPt = this[0];\n        for (let i = 1, len = this.length; i < len; i++) {\n            minPt = minPt.$min(this[i]);\n            maxPt = maxPt.$max(this[i]);\n        }\n        let d = maxPt.$subtract(minPt);\n        let mid = minPt.$add(maxPt).divide(2);\n        let dmax = Math.max(d[0], d[1]);\n        return new Pt_1.Group(mid.$subtract(20 * dmax, dmax), mid.$add(0, 20 * dmax), mid.$add(20 * dmax, -dmax));\n    }\n    /**\n     * Get a triangle from 3 points in a list of points\n     * @param i index 1\n     * @param j index 2\n     * @param k index 3\n     * @param pts a Group of Pts\n     */\n    _triangle(i, j, k, pts = this) {\n        return new Pt_1.Group(pts[i], pts[j], pts[k]);\n    }\n    /**\n     * Get a circumcircle and triangle from 3 points in a list of points\n     * @param i index 1\n     * @param j index 2\n     * @param k index 3\n     * @param tri a Group representing a triangle, or `false` to create it from indices\n     * @param pts a Group of Pts\n     */\n    _circum(i, j, k, tri, pts = this) {\n        let t = tri || this._triangle(i, j, k, pts);\n        return {\n            i: i,\n            j: j,\n            k: k,\n            triangle: t,\n            circle: Op_1.Triangle.circumcircle(t)\n        };\n    }\n    /**\n     * Dedupe the edges array\n     * @param edges\n     */\n    static _dedupe(edges) {\n        let j = edges.length;\n        while (j > 1) {\n            let b = edges[--j];\n            let a = edges[--j];\n            let i = j;\n            while (i > 1) {\n                let n = edges[--i];\n                let m = edges[--i];\n                if ((a == m && b == n) || (a == n && b == m)) {\n                    edges.splice(j, 2);\n                    edges.splice(i, 2);\n                    break;\n                }\n            }\n        }\n        return edges;\n    }\n}\nexports.Delaunay = Delaunay;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0. \n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Form_1 = __webpack_require__(6);\nconst Num_1 = __webpack_require__(3);\nconst Util_1 = __webpack_require__(1);\nconst Pt_1 = __webpack_require__(0);\nconst Op_1 = __webpack_require__(2);\nconst Dom_1 = __webpack_require__(8);\n/**\n * A Space for SVG elements\n */\nclass SVGSpace extends Dom_1.DOMSpace {\n    /**\n    * Create a SVGSpace which represents a Space for SVG elements\n    * @param elem Specify an element by its \"id\" attribute as string, or by the element object itself. An element can be an existing `<svg>`, or a `<div>` container in which a new `<svg>` will be created. If left empty, a `<div id=\"pt_container\"><svg id=\"pt\" /></div>` will be added to DOM. Use css to customize its appearance if needed.\n    * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a \"ready\" event will also be fired from the `<svg>` element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener(\"ready\")`\n    * @example `new SVGSpace( \"#myElementID\" )`\n    */\n    constructor(elem, callback) {\n        super(elem, callback);\n        this.id = \"svgspace\";\n        this._bgcolor = \"#999\";\n        if (this._canvas.nodeName.toLowerCase() != \"svg\") {\n            let s = SVGSpace.svgElement(this._canvas, \"svg\", `${this.id}_svg`);\n            this._container = this._canvas;\n            this._canvas = s;\n        }\n    }\n    /**\n    * Get a new `SVGForm` for drawing\n    * @see `SVGForm`\n    */\n    getForm() { return new SVGForm(this); }\n    /**\n    * Get the html element\n    */\n    get element() {\n        return this._canvas;\n    }\n    /**\n    * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).\n    * @param b a Bound object to resize to\n    * @param evt Optionally pass a resize event\n    */\n    resize(b, evt) {\n        super.resize(b, evt);\n        SVGSpace.setAttr(this.element, {\n            \"viewBox\": `0 0 ${this.bound.width} ${this.bound.height}`,\n            \"width\": `${this.bound.width}`,\n            \"height\": `${this.bound.height}`,\n            \"xmlns\": \"http://www.w3.org/2000/svg\",\n            \"version\": \"1.1\"\n        });\n        return this;\n    }\n    /**\n     * A static function to add a svg element inside a node. Usually you don't need to use this directly. See methods in `SVGForm` instead.\n     * @param parent the parent element, or `null` to use current `<svg>` as parent.\n     * @param name a string of element name,  such as `rect` or `circle`\n     * @param id id attribute of the new element\n     */\n    static svgElement(parent, name, id) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n            elem.setAttribute(\"id\", id);\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    /**\n    * Remove an item from this Space\n    * @param item a player item with an auto-assigned `animateID` property\n    */\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + SVGForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    /**\n     * Remove all items from this Space\n     */\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexports.SVGSpace = SVGSpace;\n/**\n* SVGForm is an implementation of abstract class VisualForm. It provide methods to express Pts on SVGSpace.\n* You may extend SVGForm to implement your own expressions for SVGSpace.\n*/\nclass SVGForm extends Form_1.VisualForm {\n    /**\n    * Create a new SVGForm. You may also use `space.getForm()` to get the default form.\n    * @param space an instance of SVGSpace\n    */\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"fill\": \"#f03\",\n                \"stroke\": \"#fff\",\n                \"stroke-width\": 1,\n                \"stroke-linejoin\": \"bevel\",\n                \"stroke-linecap\": \"sqaure\"\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_svg_\" + (SVGForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    /**\n    * get the SVGSpace instance that this form is associated with\n    */\n    get space() { return this._space; }\n    /**\n     * Update a style in _ctx context or throw an Erorr if the style doesn't exist\n     * @param k style key\n     * @param v  style value\n     */\n    styleTo(k, v) {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = v;\n    }\n    /**\n      * Set current fill style. Provide a valid color string or `false` to specify no fill color.\n      * @example `form.fill(\"#F90\")`, `form.fill(\"rgba(0,0,0,.5\")`, `form.fill(false)`\n      * @param c fill color\n      */\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"fill\", c);\n        }\n        return this;\n    }\n    /**\n      * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.\n      * @example `form.stroke(\"#F90\")`, `form.stroke(\"rgba(0,0,0,.5\")`, `form.stroke(false)`, `form.stroke(\"#000\", 0.5, 'round', 'square')`\n      * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))\n      * @param width Optional value (can be floating point) to set line width\n      * @param linejoin Optional string to set line joint style. Can be \"miter\", \"bevel\", or \"round\".\n      * @param linecap Optional string to set line cap style. Can be \"butt\", \"round\", or \"square\".\n      */\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"stroke\", c);\n            if (width)\n                this.styleTo(\"stroke-width\", width);\n            if (linejoin)\n                this.styleTo(\"stroke-linejoin\", linejoin);\n            if (linecap)\n                this.styleTo(\"stroke-linecap\", linecap);\n        }\n        return this;\n    }\n    /**\n     * Add custom class to the created element\n     * @param c custom class name or `false` to reset it\n     * @example `form.fill(\"#f00\").cls(\"myClass\").rects(r)` `form.cls(false).circles(c)`\n     */\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    /**\n    * Set the current font\n    * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties\n    * @param weight Optional font-weight string such as \"bold\"\n    * @param style Optional font-style string such as \"italic\"\n    * @param lineHeight Optional line-height number suchas 1.5\n    * @param family Optional font-family such as \"Helvetica, sans-serif\"\n    * @example `form.font( myFont )`, `form.font(14, \"bold\")`\n    */\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    /**\n    * Reset the context's common styles to this form's styles. This supports using multiple forms on the same canvas context.\n    */\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"fill\": \"#f03\", \"stroke\": \"#fff\",\n            \"stroke-width\": 1,\n            \"stroke-linejoin\": \"bevel\",\n            \"stroke-linecap\": \"sqaure\"\n        };\n        this._font = new Form_1.Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    /**\n     * Set this form's group scope by an ID, and optionally define the group's parent element. A group scope keeps track of elements by their generated IDs, and updates their properties as needed. See also `scope()`.\n     * @param group_id a string to use as prefix for the group's id. For example, group_id \"hello\" will create elements with id like \"hello-1\", \"hello-2\", etc\n     * @param group Optional DOM or SVG element to define this group's parent element\n     * @returns this form's context\n     */\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    /**\n     * Set the current group scope to an item added into space, in order to keep track of any point, circle, etc created within it. The item must have an `animateID` property, so that elements created within the item will have generated IDs like \"item-{animateID}-{count}\".\n     * @param item a \"player\" item that's added to space (see `space.add(...)`) and has an `animateID` property\n     * @returns this form's context\n     */\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(SVGForm.scopeID(item), this.space.element);\n    }\n    /**\n     * Get next available id in the current group\n     * @returns an id string\n     */\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    /**\n     * A static function to generate an ID string based on a context object\n     * @param ctx a context object for an SVGForm\n     */\n    static getID(ctx) {\n        return ctx.currentID || `p-${SVGForm.domID++}`;\n    }\n    /**\n     * A static function to generate an ID string for a scope, based on a \"player\" item in the Space\n     * @param item a \"player\" item that's added to space (see `space.add(...)`) and has an `animateID` property\n     */\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    /**\n     * A static function to help adding style object to an element. This put all styles into `style` attribute instead of individual attributes, so that the styles can be parsed by Adobe Illustrator.\n     * @param elem A DOM element to add to\n     * @param styles an object of style properties\n     * @example `SVGForm.style(elem, {fill: \"#f90\", stroke: false})`\n     * @returns this DOM element\n     */\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"fill: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"stroke: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('fill') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('stroke') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return Dom_1.DOMSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    /**\n      * Draws a point\n      * @param ctx a context object of SVGForm\n      * @param pt a Pt object or numeric array\n      * @param radius radius of the point. Default is 5.\n      * @param shape The shape of the point. Defaults to \"square\", but it can be \"circle\" or a custom shape function in your own implementation.\n      * @example `SVGForm.point( p )`, `SVGForm.point( p, 10, \"circle\" )`\n      */\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return SVGForm.circle(ctx, pt, radius);\n        }\n        else {\n            return SVGForm.square(ctx, pt, radius);\n        }\n    }\n    /**\n      * Draws a point\n      * @param p a Pt object\n      * @param radius radius of the point. Default is 5.\n      * @param shape The shape of the point. Defaults to \"square\", but it can be \"circle\" or a custom shape function in your own implementation.\n      * @example `form.point( p )`, `form.point( p, 10, \"circle\" )`\n      */\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        SVGForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    /**\n      * A static function to draw a circle\n      * @param ctx a context object of SVGForm\n      * @param pt center position of the circle\n      * @param radius radius of the circle\n      */\n    static circle(ctx, pt, radius = 10) {\n        let elem = SVGSpace.svgElement(ctx.group, \"circle\", SVGForm.getID(ctx));\n        Dom_1.DOMSpace.setAttr(elem, {\n            cx: pt[0],\n            cy: pt[1],\n            r: radius,\n            'class': `pts-svgform pts-circle ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n      * Draw a circle\n      * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]\n      * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)\n      */\n    circle(pts) {\n        this.nextID();\n        SVGForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    /**\n      * A static function to draw an arc.\n      * @param ctx a context object of SVGForm\n      * @param pt center position\n      * @param radius radius of the arc circle\n      * @param startAngle start angle of the arc\n      * @param endAngle end angle of the arc\n      * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.\n      */\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        let elem = SVGSpace.svgElement(ctx.group, \"path\", SVGForm.getID(ctx));\n        const start = new Pt_1.Pt(pt).toAngle(startAngle, radius, true);\n        const end = new Pt_1.Pt(pt).toAngle(endAngle, radius, true);\n        const diff = Num_1.Geom.boundAngle(endAngle) - Num_1.Geom.boundAngle(startAngle);\n        let largeArc = (diff > Util_1.Const.pi) ? true : false;\n        if (cc)\n            largeArc = !largeArc;\n        const sweep = (cc) ? \"0\" : \"1\";\n        const d = `M ${start[0]} ${start[1]} A ${radius} ${radius} 0 ${largeArc ? \"1\" : \"0\"} ${sweep} ${end[0]} ${end[1]}`;\n        Dom_1.DOMSpace.setAttr(elem, {\n            d: d,\n            'class': `pts-svgform pts-arc ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n      * Draw an arc.\n      * @param pt center position\n      * @param radius radius of the arc circle\n      * @param startAngle start angle of the arc\n      * @param endAngle end angle of the arc\n      * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.\n      */\n    arc(pt, radius, startAngle, endAngle, cc) {\n        this.nextID();\n        SVGForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        return this;\n    }\n    /**\n      * A static function to draw a square\n      * @param ctx a context object of SVGForm\n      * @param pt center position of the square\n      * @param halfsize half size of the square\n      */\n    static square(ctx, pt, halfsize) {\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        Dom_1.DOMSpace.setAttr(elem, {\n            x: pt[0] - halfsize,\n            y: pt[1] - halfsize,\n            width: halfsize * 2,\n            height: halfsize * 2,\n            'class': `pts-svgform pts-square ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n     * Draw a square, given a center and its half-size\n     * @param pt center Pt\n     * @param halfsize half-size\n     */\n    square(pt, halfsize) {\n        this.nextID();\n        SVGForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    /**\n    * A static function to draw a line\n    * @param ctx a context object of SVGForm\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    static line(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        if (pts.length > 2)\n            return SVGForm._poly(ctx, pts, false);\n        let elem = SVGSpace.svgElement(ctx.group, \"line\", SVGForm.getID(ctx));\n        Dom_1.DOMSpace.setAttr(elem, {\n            x1: pts[0][0],\n            y1: pts[0][1],\n            x2: pts[1][0],\n            y2: pts[1][1],\n            'class': `pts-svgform pts-line ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n    * Draw a line or polyline\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    line(pts) {\n        this.nextID();\n        SVGForm.line(this._ctx, pts);\n        return this;\n    }\n    /**\n     * A static helper function to draw polyline or polygon\n     * @param ctx a context object of SVGForm\n     * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n     * @param closePath a boolean to specify if the polygon path should be closed\n     */\n    static _poly(ctx, pts, closePath = true) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, ((closePath) ? \"polygon\" : \"polyline\"), SVGForm.getID(ctx));\n        let points = pts.reduce((a, p) => a + `${p[0]},${p[1]} `, \"\");\n        Dom_1.DOMSpace.setAttr(elem, {\n            points: points,\n            'class': `pts-svgform pts-polygon ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n      * A static function to draw polygon\n      * @param ctx a context object of SVGForm\n      * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n      */\n    static polygon(ctx, pts) {\n        return SVGForm._poly(ctx, pts, true);\n    }\n    /**\n    * Draw a polygon\n    * @param pts a Group of multiple Pts, or an array of multiple numeric arrays\n    */\n    polygon(pts) {\n        this.nextID();\n        SVGForm.polygon(this._ctx, pts);\n        return this;\n    }\n    /**\n    * A static function to draw a rectangle\n    * @param ctx a context object of SVGForm\n    * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.\n    */\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        let bound = Pt_1.Group.fromArray(pts).boundingBox();\n        let size = Op_1.Rectangle.size(bound);\n        Dom_1.DOMSpace.setAttr(elem, {\n            x: bound[0][0],\n            y: bound[0][1],\n            width: size[0],\n            height: size[1],\n            'class': `pts-svgform pts-rect ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n      * Draw a rectangle\n      * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.\n      */\n    rect(pts) {\n        this.nextID();\n        SVGForm.rect(this._ctx, pts);\n        return this;\n    }\n    /**\n      * A static function to draw text\n      * @param ctx a context object of SVGForm\n      * @param `pt` a Point object to specify the anchor point\n      * @param `txt` a string of text to draw\n      * @param `maxWidth` specify a maximum width per line\n      */\n    static text(ctx, pt, txt) {\n        let elem = SVGSpace.svgElement(ctx.group, \"text\", SVGForm.getID(ctx));\n        Dom_1.DOMSpace.setAttr(elem, {\n            \"pointer-events\": \"none\",\n            x: pt[0],\n            y: pt[1],\n            dx: 0, dy: 0,\n            'class': `pts-svgform pts-text ${ctx.currentClass}`,\n        });\n        elem.textContent = txt;\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    /**\n      * Draw text on canvas\n      * @param `pt` a Pt or numeric array to specify the anchor point\n      * @param `txt` text\n      * @param `maxWidth` specify a maximum width per line\n      */\n    text(pt, txt) {\n        this.nextID();\n        SVGForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    /**\n      * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.\n      * @param txt text\n      */\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n}\nSVGForm.groupID = 0;\nSVGForm.domID = 0;\nexports.SVGForm = SVGForm;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Source code licensed under Apache License 2.0.\n// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Op_1 = __webpack_require__(2);\n/**\n * An enumeration of different UI types\n */\nvar UIShape;\n(function (UIShape) {\n    UIShape[UIShape[\"Rectangle\"] = 0] = \"Rectangle\";\n    UIShape[UIShape[\"Circle\"] = 1] = \"Circle\";\n    UIShape[UIShape[\"Polygon\"] = 2] = \"Polygon\";\n    UIShape[UIShape[\"Polyline\"] = 3] = \"Polyline\";\n    UIShape[UIShape[\"Line\"] = 4] = \"Line\";\n})(UIShape = exports.UIShape || (exports.UIShape = {}));\nexports.UIPointerActions = {\n    up: \"up\", down: \"down\", move: \"move\", drag: \"drag\", drop: \"drop\", over: \"over\", out: \"out\"\n};\nclass UI {\n    /**\n     * Wrap an UI insider a group\n     */\n    constructor(group, shape, states, id) {\n        this.group = group;\n        this.shape = shape;\n        this._id = id;\n        this._states = states;\n        this._actions = {};\n    }\n    /**\n     * Get and set uique id\n     */\n    get id() { return this._id; }\n    set id(d) { this._id = d; }\n    /**\n     * Get a state\n     * @param key state's name\n     */\n    state(key) {\n        return this._states[key] || false;\n    }\n    /**\n     * Add an event handler\n     * @param key event key\n     * @param fn handler function\n     */\n    on(key, fn) {\n        this._actions[key] = fn;\n        return this;\n    }\n    /**\n     * Remove an event handler\n     * @param key even key\n     * @param fn\n     */\n    off(key) {\n        delete this._actions[key];\n        return this;\n    }\n    /**\n     * Listen for interactions and trigger action handlers\n     * @param key action key\n     * @param p point to check\n     */\n    listen(key, p) {\n        if (this._actions[key] !== undefined) {\n            if (this._trigger(p)) {\n                this._actions[key](p, this, key);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Take a custom render function to render this UI\n     * @param fn render function\n     */\n    render(fn) {\n        fn(this.group, this._states);\n    }\n    /**\n     * Check intersection using a specific function based on UIShape\n     * @param p a point to check\n     */\n    _trigger(p) {\n        let fn = null;\n        if (this.shape === UIShape.Rectangle) {\n            fn = Op_1.Rectangle.withinBound;\n        }\n        else if (this.shape === UIShape.Circle) {\n            fn = Op_1.Circle.withinBound;\n        }\n        else if (this.shape === UIShape.Polygon) {\n            fn = Op_1.Rectangle.withinBound;\n        }\n        else {\n            return false;\n        }\n        return fn(this.group, p);\n    }\n}\nexports.UI = UI;\n/**\n * A simple UI button that can track clicks and hovers\n */\nclass UIButton extends UI {\n    constructor(group, shape, states, id) {\n        super(group, shape, states, id);\n        this._clicks = 0;\n    }\n    /**\n     * Get the total number of clicks on this UIButton\n     */\n    get clicks() { return this._clicks; }\n    /**\n     * Add a click handler\n     * @param fn a function to handle clicks\n     */\n    onClick(fn) {\n        this._clicks++;\n        this.on(exports.UIPointerActions.up, fn);\n    }\n    /**\n     * Add hover handler\n     * @param over a function to handle when pointer enters hover\n     * @param out a function to handle when pointer exits hover\n     */\n    onHover(over, out) {\n        this.on(exports.UIPointerActions.over, over);\n        this.on(exports.UIPointerActions.out, out);\n    }\n}\nexports.UIButton = UIButton;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _Bound = __webpack_require__(5);\nconst _Canvas = __webpack_require__(10);\nconst _Create = __webpack_require__(12);\nconst _Form = __webpack_require__(6);\nconst _LinearAlgebra = __webpack_require__(4);\nconst _Num = __webpack_require__(3);\nconst _Op = __webpack_require__(2);\nconst _Pt = __webpack_require__(0);\nconst _Space = __webpack_require__(7);\nconst _Color = __webpack_require__(11);\nconst _Util = __webpack_require__(1);\nconst _Dom = __webpack_require__(8);\nconst _Svg = __webpack_require__(13);\nconst _Typography = __webpack_require__(9);\n// A function to switch scope for Pts library. eg, Pts.scope( Pts, window );\nlet namespace = (sc) => {\n    let lib = module.exports;\n    for (let k in lib) {\n        if (k != \"namespace\") {\n            sc[k] = lib[k];\n        }\n    }\n};\nmodule.exports = Object.assign({ namespace }, _Bound, _Canvas, _Create, _Form, _LinearAlgebra, _Op, _Num, _Pt, _Space, _Util, _Color, _Dom, _Svg, _Typography);\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=pts.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/pts.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}