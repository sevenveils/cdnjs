{"version":3,"file":"flicking.min.js","sources":["../src/browser.js","../src/consts.js","../src/utils.js","../src/config.js","../src/eventHandler.js","../src/Flicking.js"],"sourcesContent":["/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable no-new-func, no-nested-ternary */\nconst win = typeof window !== \"undefined\" &&\n\twindow.Math === Math ? window : (\n\t\ttypeof self !== \"undefined\" && (\n\t\t\tself.Math === Math ? self : Function(\"return this\")()\n\t\t)\n\t);\n/* eslint-enable no-new-func, no-nested-ternary */\n\nconst document = win.document;\n\nexport {\n\twin as window,\n\tdocument\n};\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {window as global, document as doc} from \"./browser\";\n\n// define custom events name\nconst EVENTS = {\n\tbeforeFlickStart: \"beforeFlickStart\",\n\tbeforeRestore: \"beforeRestore\",\n\tflick: \"flick\",\n\tflickEnd: \"flickEnd\",\n\trestore: \"restore\"\n};\n\n// check for the transform property\nconst TRANSFORM = {\n\tname: \"transform\"\n};\n\nTRANSFORM.support = (() => {\n\tconst style = doc.documentElement.style;\n\n\treturn TRANSFORM.name in style || (TRANSFORM.name = \"webkitTransform\") in style;\n})();\n\n// check for will-change support\nconst SUPPORT_WILLCHANGE = global.CSS && global.CSS.supports &&\n\tglobal.CSS.supports(\"will-change\", \"transform\");\n\n// check for Android 2.x\nconst IS_ANDROID2 = /Android 2\\./.test(navigator.userAgent);\n\n// data-height attribute's name for adaptiveHeight option\nconst DATA_HEIGHT = \"data-height\";\n\nexport {\n\tEVENTS,\n\tTRANSFORM,\n\tSUPPORT_WILLCHANGE,\n\tIS_ANDROID2,\n\tDATA_HEIGHT\n};\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {window, document} from \"./browser\";\n\nconst utils = {\n\t/**\n\t * Select or create element\n\t * @param {String|HTMLElement} param\n\t *  when string given is as HTML tag, then create element\n\t *  otherwise it returns selected elements\n\t * @returns {HTMLElement}\n\t */\n\t$(param) {\n\t\tlet el = null;\n\n\t\tif (typeof param === \"string\") {\n\t\t\t// check if string is HTML tag format\n\t\t\tconst match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n\t\t\t// creating element\n\t\t\tif (match) {\n\t\t\t\tel = document.createElement(match[1]);\n\n\t\t\t\t// attributes\n\t\t\t\tmatch.length === 3 &&\n\t\t\t\t\tmatch[2].split(\" \").forEach(v => {\n\t\t\t\t\t\tconst attr = v.split(\"=\");\n\n\t\t\t\t\t\tel.setAttribute(attr[0], attr[1].trim().replace(/(^[\"']|[\"']$)/g, \"\"));\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel = document.querySelectorAll(param);\n\n\t\t\t\tif (!el.length) {\n\t\t\t\t\tel = null;\n\t\t\t\t} else if (el.length === 1) {\n\t\t\t\t\tel = el[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (param.nodeName && param.nodeType === 1) {\n\t\t\tel = param;\n\t\t}\n\n\t\treturn el;\n\t},\n\n\t/**\n\t * Converts to array\n\t * @param {HTMLCollection|HTMLElement} el\n\t * @returns {Array}\n\t */\n\ttoArray(el) {\n\t\treturn [].slice.call(el);\n\t},\n\n\t/**\n\t * Check if is array\n\t * @param arr\n\t * @returns {Boolean}\n\t */\n\tisArray(arr) {\n\t\treturn arr && arr.constructor === Array;\n\t},\n\n\t/**\n\t * Check if is object\n\t * @param {Object} obj\n\t * @returns {Boolean}\n\t */\n\tisObject(obj) {\n\t\treturn obj && !obj.nodeType && typeof obj === \"object\" && !this.isArray(obj);\n\t},\n\n\t/**\n\t * Merge object returning new object\n\t * @param {Object} target\n\t * @param {Object} objectN\n\t * @returns {Object} merged target object\n\t * @example\n\t *  var target = { a: 1 };\n\t *  utils.extend(target, { b: 2, c: 3 });\n\t *  target;  // { a: 1, b: 2, c: 3 };\n\t */\n\textend(target, ...objectN) {\n\t\tif (!objectN.length || (objectN.length === 1 && !objectN[0])) {\n\t\t\treturn target;\n\t\t}\n\n\t\tconst source = objectN.shift();\n\n\t\tif (this.isObject(target) && this.isObject(source)) {\n\t\t\tObject.keys(source).forEach(key => {\n\t\t\t\tconst value = source[key];\n\n\t\t\t\tif (this.isObject(value)) {\n\t\t\t\t\t!target[key] && (target[key] = {});\n\n\t\t\t\t\ttarget[key] = this.extend(target[key], value);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = this.isArray(value) ?\n\t\t\t\t\t\tvalue.concat() : value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this.extend(target, ...objectN);\n\t},\n\n\t/**\n\t * Get or set the style value or apply\n\t * @param {HTMLElement|Array} el\n\t * @param {String|Object} style\n\t *  String: return style property value\n\t *  Object: set style value\n\t * @param {Boolean} getAsNumber Get the value as number\n\t * @returns {String|HTMLElement}\n\t */\n\tcss(el, style, getAsNumber) {\n\t\tif (typeof(style) === \"string\") {\n\t\t\tlet value = el.style[style];\n\n\t\t\tif (!value || value === \"auto\" || (/\\d/.test(value) && !/\\d(px)?$/.test(value))) {\n\t\t\t\tvalue = window.getComputedStyle(el)[style];\n\t\t\t}\n\n\t\t\treturn getAsNumber ? this.getNumValue(value) : value;\n\t\t} else {\n\t\t\tconst applyStyle = (target, source) =>\n\t\t\t\tObject.keys(source).forEach(v => {\n\t\t\t\t\ttarget[v] = source[v];\n\t\t\t\t});\n\n\t\t\tthis.isArray(el) ?\n\t\t\t\tel.forEach(v => applyStyle(v.style, style)) :\n\t\t\t\tapplyStyle(el.style, style);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\t/**\n\t * classList\n\t * @param {HTMLElement} el target DOM element\n\t * @param {String} className class name string to be handled\n\t * @param {Boolean} add Add or remove class - true: Add, false: Remove\n\t * @return {Boolean} if add param is missing, then return existence of class name\n\t */\n\tclassList(el, className, add) {\n\t\tconst isAddParam = typeof add === \"boolean\";\n\t\tlet res;\n\n\t\tif (el.classList) {\n\t\t\tres = el.classList[\n\t\t\t\t(isAddParam && (add ? \"add\" : \"remove\")) || \"contains\"\n\t\t\t](className);\n\t\t} else {\n\t\t\tres = el.className;\n\n\t\t\tif (isAddParam) {\n\t\t\t\tif (add && res.indexOf(className) === -1) {\n\t\t\t\t\tres = el.className = (`${res} ${className}`).replace(/\\s{2,}/g, \" \");\n\t\t\t\t} else if (!add) {\n\t\t\t\t\tres = el.className = res.replace(className, \"\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = new RegExp(`\\\\b${className}\\\\b`).test(res);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t},\n\n\t/**\n\t * Check and parse value to number\n\t * @param {Number|String} val\n\t * @param {Number} defVal\n\t * @return {Number}\n\t */\n\tgetNumValue(val, defVal) {\n\t\tlet num = val;\n\n\t\treturn isNaN(num = parseFloat(num)) ? defVal : num;\n\t},\n\n\t/**\n\t * Return unit formatted value\n\t * @param {Number|String} val\n\t * @return {String} val Value formatted with unit\n\t */\n\tgetUnitValue(val) {\n\t\tconst rx = /(?:[a-z]{2,}|%)$/;\n\n\t\treturn (parseFloat(val) || 0) + (String(val).match(rx) || \"px\");\n\t},\n\n\t/**\n\t * Get element's outer value\n\t * @param {HTMLElement} el\n\t * @param {String} type - [outerWidth|outerHeight]\n\t * @returns {Number} outer's value\n\t */\n\tgetOuter(el, type) {\n\t\tlet paddingMargin = 0;\n\n\t\t(type === \"outerWidth\" ?\n\t\t\t[\"Left\", \"Right\"] :\n\t\t\t[\"Top\", \"Bottom\"]\n\t\t).forEach(dir => {\n\t\t\t[\"padding\", \"margin\"].forEach(v => {\n\t\t\t\tpaddingMargin += this.css(el, `${v}${dir}`, true);\n\t\t\t});\n\t\t});\n\n\t\treturn this.css(el, type.replace(\"outer\", \"\").toLocaleLowerCase(), true) + paddingMargin;\n\t},\n\n\t/**\n\t * Get element's outerWidth value with margin\n\t * @param {HTMLElement} el\n\t * @returns {Number}\n\t */\n\touterWidth(el) {\n\t\treturn this.getOuter(el, \"outerWidth\");\n\t},\n\n\t/**\n\t * Get element's outerHeight value with margin\n\t * @param {HTMLElement} el\n\t * @returns {Number}\n\t */\n\touterHeight(el) {\n\t\treturn this.getOuter(el, \"outerHeight\");\n\t},\n\n\t/**\n\t * Returns the syntax of the translate style which is applied to CSS transition properties.\n\t *\n\t * @ko CSS 트랜지션 속성에 적용할 translate 스타일 구문을 반환한다\n\t * @method eg#translate\n\t * @param {String} x Distance to move along the X axis <ko>x축을 따라 이동할 거리</ko>\n\t * @param {String} y Distance to move along the Y axis <ko>y축을 따라 이동할 거리</ko>\n\t * @param {Boolean} [isHA] Force hardware acceleration <ko>하드웨어 가속 사용 여부</ko>\n\t * @return {String} Syntax of the translate style <ko>translate 스타일 구문</ko>\n\t */\n\ttranslate(x, y, isHA) {\n\t\treturn isHA || false ?\n\t\t\t`translate3d(${x},${y},0)` : `translate(${x},${y})`;\n\t},\n\n\t// 1. user press one position on screen.\n\t// 2. user moves to the other position on screen.\n\t// 3. when user releases fingers on screen, 'click' event is fired at previous position.\n\thasClickBug() {\n\t\tconst ua = window.navigator.userAgent;\n\t\tconst result = /iPhone|iPad/.test(ua);\n\n\t\tthis.hasClickBug = () => result;\n\t\treturn result;\n\t}\n};\n\nclass MixinBuilder {\n\tconstructor(superclass) {\n\t\tthis.superclass = superclass || class {};\n\t}\n\n\twith(...mixins) {\n\t\treturn mixins.reduce((c, m) => m(c), this.superclass);\n\t}\n}\n\nconst Mixin = superclass => new MixinBuilder(superclass);\n\nexport {utils, Mixin};\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n// internal config values\nconst CONFIG = {\n\tpanel: {\n\t\t$list: null,        // panel list\n\t\tindex: 0,\t\t\t// dom index used among process\n\t\tno: 0,\t\t\t\t// panel no used among process\n\t\tcurrIndex: 0,       // current physical dom index\n\t\tcurrNo: 0,          // current logical panel number\n\t\tsize: 0,\t\t\t// panel size\n\t\tcount: 0,\t\t\t// total physical panel count\n\t\torigCount: 0,\t\t// total count of given original panels\n\t\tchanged: false,\t\t// if panel changed\n\t\tanimating: false,\t// current animating status boolean\n\t\tminCount: 3         // minimum panel count\n\t},\n\ttouch: {\n\t\tholdPos: 0,         // hold x,y coordinate\n\t\tdestPos: 0,\t        // destination x,y coordinate\n\t\tdistance: 0,\t\t// touch distance pixel of start to end touch\n\t\tdirection: null,\t// touch direction\n\t\tlastPos: 0,\t\t\t// to determine move on holding\n\t\tholding: false,\n\t\tisTrusted: false    // if event was instantiated by user's action explicitly\n\t},\n\tcustomEvent: {          // for custom events value\n\t\tflick: true,\n\t\trestore: false,\n\t\trestoreCall: false\n\t},\n\tdirData: [],\t\t\t// direction constant value according horizontal or vertical\n\tindexToMove: 0,\n\t$dummyAnchor: null      // For buggy link highlighting on Android 2.x\n};\n\n\n// default options\nconst OPTIONS = {\n\thwAccelerable: true,    // set for hw acceleration (see https://gist.github.com/netil/c1d1b67e1c1926364c0709f110a09b44 for old devices support)\n\tprefix: \"eg-flick\",     // prefix value of class name\n\tdeceleration: 0.0006,   // deceleration value\n\thorizontal: true,       // move direction (true == horizontal, false == vertical)\n\tcircular: false,        // circular mode. In this mode at least 3 panels are required.\n\tpreviewPadding: null,   // preview padding value in left(up) to right(down) order. In this mode at least 5 panels are required.\n\tbounce: null,           // bounce value in left(up) to right(down) order. Works only in non-circular mode.\n\tthreshold: 40,          // the distance pixel threshold value for change panel\n\tduration: 100,          // duration ms for animation\n\tpanelEffect: x => 1 - Math.pow(1 - x, 3),  // easing function for panel change animation\n\tdefaultIndex: 0,        // initial panel index to be shown\n\tinputType: [            // input type\n\t\t\"touch\", \"mouse\"\n\t],\n\tthresholdAngle: 45,     // the threshold value that determines whether user action is horizontal or vertical (0~90)\n\tadaptiveHeight: false,  // Set container's height be adaptive according panel's height\n\tzIndex: 2000,           // z-index value for container element\n\tuseTranslate: true      // use of translate on panel moves\n};\n\nexport {\n\tCONFIG,\n\tOPTIONS\n};\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport {EVENTS} from \"./consts\";\n\nexport default superclass => class extends superclass {\n\t/**\n\t * 'hold' event handler\n\t * @private\n\t */\n\t_holdHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\t\tconst holdPos = e.pos.flick;\n\n\t\ttouch.holdPos = holdPos;\n\t\ttouch.holding = true;\n\t\ttouch.isTrusted = true;\n\t\tconf.panel.changed = false;\n\n\t\tthis._adjustContainerCss(\"start\", holdPos);\n\t}\n\n\t/**\n\t * 'change' event handler\n\t * @private\n\t */\n\t_changeHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\t\tconst pos = e.pos.flick;\n\t\tconst holdPos = touch.holdPos;\n\t\tlet direction;\n\t\tlet eventRes = null;\n\t\tlet movedPx;\n\n\t\tthis._setPointerEvents(e);  // for \"click\" bug\n\n\t\t/**\n\t\t * An event that occurs whenever the panel's coordinate value changes. It occurs in the following cases.<br><br>1. When the user is inputing the move.<br>2. When moving to the destination panel after you have finished inputing the move in step 1.<br>3. When the current panel is moving to its original position after the movement is finished in step 1.<br>4. Moving to the destination panel by calling the `moveTo()`, `prev()`, `next()`  method. (Do not prevent the default behavior of the [beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart} event.)\n\t\t * @ko 패널의 좌표값이 변할 때마다 발생하는 이벤트. 아래의 경우에 발생한다.<br><br>1. 사용자가 이동(move) 액션 입력중일 때.<br>2. 1번에서 이동(move) 액션 입력이 끝나고 목적 패널로 이동중일 때.<br>3. 1번에서 이동(move) 액션 입력이 끝나고 현재 패널의 원래 위치로 이동중일 때.<br>4. `moveTo()`, `prev()`, `next()`, 메서드를 호출하여 목적 패널로 이동중일 때. ([beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart}이벤트의 기본동작을 막지 않아야 한다.)<br>5. `restore()` 메서드를 호출하여 현재 패널이 원래 위치로 이동중일 때. ([beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart}이벤트의 기본동작 방지 전제.)\n\t\t * @name eg.Flicking#flick\n\t\t * @event\n\t\t * @property {String} eventType The name of the event<ko>이벤트 명</ko>\n\t\t * @property {Boolean} isTrusted true when the event was generated by a user action(`\"mouse\"` or `\"touch\"`) otherwise false<ko>사용자 액션(`\"mouse\"` 또는 `\"touch\"`)에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`</ko>\n\t\t * @property {Number} no Index number of the current panel element. See the [getIndex()]{@link eg.Flicking#getIndex} method.<ko>현재 패널 요소의 인덱스 번호. [getIndex()]{@link eg.Flicking#getIndex}메서드 참조.</ko>\n\t\t * @property {Number} direction of the panel movement. If `horizontal=true` is {@link eg.Flicking.DIRECTION_LEFT} or {@link eg.Flicking.DIRECTION_RIGHT}. If `horizontal=false` is {@link eg.Flicking.DIRECTION_UP} or {@link eg.Flicking.DIRECTION_DOWN}.<ko>패널 이동 방향. `horizontal=true` 이면 {@link eg.Flicking.DIRECTION_LEFT} 혹은 {@link eg.Flicking.DIRECTION_RIGHT}. `horizontal=false` 이면 {@link eg.Flicking.DIRECTION_UP} 혹은 {@link eg.Flicking.DIRECTION_DOWN}.</ko>\n\t\t * @property {Number} pos current coordinate <ko>현재 좌표.</ko>\n\t\t * @property {Boolean} holding Whether the user is inputing through the input device. (Whether it is 'mousedown' for a mouse device or 'touchmove' for a touch device.)<ko>사용자가 입력 장치를 통해 입력중인지 여부. (마우스 장치라면 'mousedown' 여부, 터치 장치라면 'touchmove' 여부)</ko>\n\t\t * @property {Number} distance Distance value from the touch starting point. If the `direction` property value is {@link eg.Flicking.DIRECTION_LEFT} or {@link eg.Flicking.DIRECTION_UP}, it returns a positive number. {@link eg.Flicking.DIRECTION_RIGHT} or {@link eg.Flicking.DIRECTION_DOWN} returns a negative value.<ko>터치 시작점으로부터 이동한 거리 값. `direction`속성값이 {@link eg.Flicking.DIRECTION_LEFT} 혹은 {@link eg.Flicking.DIRECTION_UP}이면 양수를, {@link eg.Flicking.DIRECTION_RIGHT} 혹은 {@link eg.Flicking.DIRECTION_DOWN}이면 음수를 반환한다.</ko>\n\t\t * @see eg.Flicking#event:beforeRestore\n\t\t * @see eg.Flicking#restore\n\t\t * @see eg.Flicking#event:beforeFlickStart\n\t\t * @see eg.Flicking#event:flickEnd\n\t\t * @see eg.Flicking#moveTo\n\t\t * @see eg.Flicking#prev\n\t\t * @see eg.Flicking#next\n\t\t * @example\n\t\t\t * The order of event occurrence.\n\t\t\t * 이벤트 발생 순서\n\t\t\t * ```javascript\n\t\t\t * // When moving to the destination panel.\n\t\t\t * // 목적 패널로 이동할 때.\n\t\t\t * beforeFlickStart (once) > flick (many times) > flickEnd (once)\n\t\t\t *\n\t\t\t * // When the restore operation.\n\t\t\t * // 복원 동작일 때.\n\t\t\t * beforeRestore (once) > flick (many times) > restore (once)\n\t\t\t * ```\n\t\t */\n\t\tif (e.inputEvent) {\n\t\t\tdirection = e.inputEvent.direction;\n\n\t\t\t// Adjust direction in case of diagonal touch move\n\t\t\tmovedPx = e.inputEvent[this.options.horizontal ? \"deltaX\" : \"deltaY\"];\n\n\t\t\tif (!~conf.dirData.indexOf(direction)) {\n\t\t\t\tdirection = conf.dirData[+(Math.abs(touch.lastPos) <= movedPx)];\n\t\t\t}\n\n\t\t\ttouch.lastPos = movedPx;\n\t\t} else {\n\t\t\ttouch.lastPos = null;\n\t\t}\n\n\t\tconf.customEvent.flick && (eventRes =\n\t\t\tthis._triggerEvent(EVENTS.flick, {\n\t\t\t\tpos,\n\t\t\t\tholding: e.holding,\n\t\t\t\tdirection: direction || touch.direction,\n\t\t\t\tdistance: touch.isTrusted ? pos - holdPos : null\n\t\t\t})\n\t\t);\n\n\t\t(eventRes || eventRes === null) && this._setTranslate([-pos, 0]);\n\t}\n\n\t/**\n\t * 'release' event handler\n\t * @private\n\t */\n\t_releaseHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\t\tconst holdPos = touch.holdPos;\n\t\tconst panelSize = conf.panel.size;\n\t\tconst customEvent = conf.customEvent;\n\t\tconst isPlusMove = touch.holdPos < e.depaPos.flick;\n\n\t\ttouch.distance = e.depaPos.flick - holdPos;\n\t\ttouch.direction = conf.dirData[+!(isPlusMove)];\n\t\ttouch.destPos = holdPos + (isPlusMove ? panelSize : -panelSize);\n\n\t\tconst distance = touch.distance;\n\t\tlet duration = this.options.duration;\n\t\tlet moveTo = holdPos;\n\n\t\tif (this._isMovable()) {\n\t\t\t!customEvent.restoreCall && (customEvent.restore = false);\n\t\t\tmoveTo = touch.destPos;\n\t\t} else if (Math.abs(distance) > 0) {\n\t\t\tthis._triggerBeforeRestore(e);\n\t\t} else {\n\t\t\tduration = 0;\n\t\t}\n\n\t\t// trigger animation\n\t\te.setTo({flick: moveTo}, duration);\n\n\t\tdistance === 0 && this._adjustContainerCss(\"end\");\n\t\ttouch.holding = false;\n\n\t\tthis._setPointerEvents();  // for \"click\" bug\n\t}\n\n\t/**\n\t * 'animationStart' event handler\n\t * @private\n\t */\n\t_animationStartHandler(e) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst customEvent = conf.customEvent;\n\t\tconst isFromInput = e.inputEvent || conf.touch.lastPos;\n\n\t\t// when animation was started by input action\n\t\tif (!customEvent.restoreCall && isFromInput &&\n\t\t\tthis._setPhaseValue(\"start\", {\n\t\t\t\tdepaPos: e.depaPos.flick,\n\t\t\t\tdestPos: e.destPos.flick\n\t\t\t}) === false) {\n\t\t\te.stop();\n\t\t}\n\n\t\tif (isFromInput) {\n\t\t\te.duration = this.options.duration;\n\n\t\t\te.destPos.flick =\n\t\t\t\tpanel.size * (\n\t\t\t\t\tpanel.index + conf.indexToMove\n\t\t\t\t);\n\t\t}\n\n\t\tpanel.animating = true;\n\t}\n\n\t/**\n\t * 'animationEnd' event handler\n\t * @private\n\t */\n\t_animationEndHandler() {\n\t\tconst conf = this._conf;\n\n\t\tconf.panel.animating = false;\n\n\t\tthis._setPhaseValue(\"end\");\n\t\tthis._triggerRestore();\n\n\t\t// reset isTrusted\n\t\tconf.touch.isTrusted = false;\n\t}\n};\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component from \"@egjs/component\";\nimport Axes, {PanInput} from \"@egjs/axes\";\nimport {utils, Mixin} from \"./utils\";\nimport {\n\tEVENTS,\n\tTRANSFORM,\n\tSUPPORT_WILLCHANGE,\n\tIS_ANDROID2,\n\tDATA_HEIGHT\n} from \"./consts\";\nimport {CONFIG, OPTIONS} from \"./config\";\nimport {document} from \"./browser\";\nimport eventHandler from \"./eventHandler\";\n\n/**\n * Create an instance of the eg.Flicking class. Create a flicking UI that sweeps a side-by-side panel with mouse move or touch move input and moves to the next or previous panel.\n * @ko eg.Flicking 클래스의 인스턴스를 생성한다. 나란히 배치한 패널을 마우스 이동(move) 혹은 터치 이동(move) 입력을 받아 쓸어 넘겨 다음 패널이나 이전 패널로 이동하는 UI를 만든다.\n * @alias eg.Flicking\n * @extends eg.Component\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n * @see If you want to try a different easing function, use the jQuery easing plugin ({@link http://gsgd.co.uk/sandbox/jquery/easing}) or the jQuery UI easing library ({@link https://jqueryui.com/easing}). <ko>다른 easing 함수를 사용하려면 jQuery easing 플러그인({@link http://gsgd.co.uk/sandbox/jquery/easing})이나, jQuery UI easing 라이브러리({@link https://jqueryui.com/easing})를 사용한다</ko>\n * @throws {Error} An Error occur when given base element doesn't exist or it hasn't proper DOM structure to be initialized. <ko>주어진 기본 요소가 존재하지 않거나 초기화 할 적절한 DOM 구조가없는 경우 오류가 발생한다.</ko>\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.3+ (except 3.x)\"}\n * @example\n * A common example.\n * 일반적인 예.\n * ```html\n * <div id=\"flick\">\n * \t<div><p>panel 0</p></div>\n * \t<div><p>panel 1</p></div>\n * \t<div><p>panel 2</p></div>\n * </div>\n * ```\n * ```javascript\n * // Examples to omit and omit optional options.\n * // 생략가능한 옵션은 생략하고 생성하는 예.\n * new eg.Flicking(\"#flick\");\n *\n * // An example of specifying and generating values for all optional parameters.\n * // 모든 옵션의 값을 지정하고 생성하는 예.\n * new eg.Flicking(\"#flick\", {\n * \thwAccelerable: true,\n * \tprefix: \"eg-flick\",\n * \tdeceleration: 0.0006,\n * \thorizontal: true,\n * \tcircular: false,\n * \tpreviewPadding: [10, \"15%\"], // also as \"10px\", 15 or \"15%\" can be applied.\n * \tbounce: [10, 10],\n * \tthreshold: 40,\n * \tduration: 100,\n * \tpanelEffect: x => 1 - Math.pow(1 - x, 3),\n * \tdefaultIndex: 0,\n * \tinputType: [\"touch\", \"mouse\"],\n * \tthresholdAngle: 45,\n * \tadaptiveHeight: false\n * });\n * ```\n * @example\n * Example of constructor element parameter value specification.\n * 생성자 element 파라미터 값 지정 예.\n * ```javascript\n * // An example of assigning HTMLElement to an element parameter.\n * // element 파라미터에 HTMLElement를 지정하는 예.\n * new eg.Flicking(document.getElementById(\"flick\"));\n *\n * // An example of assigning a jQuery object to an element parameter.\n * // element 파라미터에 jQuery객체를 지정하는 예.\n * new eg.Flicking($(\"#flick\")[0]);\n *\n * // An example of assigning a css selector string to an element parameter.\n * // element 파라미터에 css 선택자 문자열을 지정하는 예.\n * new eg.Flicking(\"#flick\");\n * ```\n * @example\n * Panel element definition location example.\n * 패널 요소 정의 위치 예.\n * ```html\n * <!--An example of defining a panel element as a child of a base element.-->\n * <!--패널 요소를 기준 요소의 자식으로 정의한 예.-->\n * <div id=\"flick\">\n * \t<div><p>panel 0</p></div>\n * \t<div><p>panel 1</p></div>\n * \t<div><p>panel 2</p></div>\n * </div>\n *\n * <!--An example of defining a panel element as a child of a container element.-->\n * <!--패널 요소를 컨테이너 요소의 자식으로 정의한 예.-->\n * <div id=\"flick2\">\n * \t<div class=\"eg-flick-container\">\n * \t\t<div><p>panel 0</p></div>\n * \t\t<div><p>panel 1</p></div>\n * \t\t<div><p>panel 2</p></div>\n * \t<div>\n * </div>\n * ```\n * @example\n * An example where only one panel is defined and created with a circular.\n * 패널을 하나만 정의하고 순환으로 생성하는 예.\n * ```html\n * <div id=\"flick\">\n * \t<div><p>panel 0</p></div>\n * </div>\n * ```\n * ```javascript\n * // If the number of defined panels is less than the minimum number required for the circulation operation, the necessary number of panel elements are generated.\n * // 정의된 패널의 수가 순환동작에 필요한 최소 개수보다 적으면 필요한 수만큼의 패널 요소가 생성된다.\n * new eg.Flicking(\"#flick\", {\n * \tcircular: true\n * })\n * ```\n * @example\n * For error occurrence example. There is no panel element.\n * 오류 발생 예. 패널 요소가 하나도 없는 경우.\n * ```html\n * <div id=\"flick\"></div>\n * ```\n * ```javascript\n * try{\n * \tnew eg.Flicking(\"#flick\");\n * } catch(e) {\n * \t// An error occurs because there are no child elements in the reference element.\n *\t// 기준 요소안에 자식 요소가 하나도 없으므로 에러가 발생한다.\n * }\n * ```\n */\nexport default class Flicking extends Mixin(Component).with(eventHandler) {\n\t/**\n\t * Constructor\n\t * @param {HTMLElement|String} element A base element for the eg.Flicking module. When specifying a value as a `String` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `String`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n\t * @param {Object} [options] The option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n\t * @param {Boolean} [options.hwAccelerable=true] Force hardware compositing.<ko>하드웨어 가속 사용 여부.</ko>\n\t * @param {String} [options.prefix=\"eg-flick\"] A prefix for class names of the panel elements.<ko>패널 요소의 클래스 이름 접두사.</ko>\n\t * @param {Number} [options.deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time.<ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n\t * @param {Boolean} [options.horizontal=true] Direction of the panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true 가로방향, false 세로방향)</ko>\n\t * @param {Boolean} [options.circular=false] Whether to let the first panel flick right to the end panel (let the left panel flick from the end panel to move to the first panel). (The term 'circulation')<ko>첫 패널에서 우 액션 입력하여 끝 패널로 이동하게 할지와 끝 패널에서 우 액션 입력하여 첫 패널로 이동할하게 할지 여부. (통칭 '순환')</ko>\n\t * @param {Number|String|Array} [options.previewPadding=[0,0]] The preview size value(if no unit is given, defaults to `px`) for the previous or next panel.<br>- If the direction is set to \"horizontal\", the preview section will be displayed on the left and right of the panel.<br>- If the direction is set to \"vertical\", it will be displayed on the top and bottom of the panel.<ko>이전 패널과 다음 패널을 미리 보는 영역의 크기 값(단위가 지정되지 않는 경우, `px`로 지정).<br>패널 이동 방향이 가로 방향이면 패널 좌우에, 세로 방향이면 패널 상하에 미리 보는 영역이 나타난다.</ko>\n\t * @param {Number|Array} [options.bounce=[10,10]] The size value(unit: pixel) of the bounce area. If `circular=false`, the panel can be moved by this value when inputting a right gesture in the first panel or inputting a left gesture in the end panel. When the input is completed while moving, it returns to its original position.<ko>바운스 영역의 크기값(단위: 픽셀). `circular=false`인 경우, 첫 패널에서 우 액션 입력시, 끝 패널에서 좌 액션 입력시 이 값 만큼만 패널이 이동할 수 있고 이동한 상태에서 입력을 마치면 원래 자리로 돌아온다.</ko>\n\t * @param {Number} [options.threshold=40] Movement threshold to destination panel(unit: pixel). A panel element must be dragged beyond the threshold to move to the destination panel.<ko>목적 패널로의 이동 임계값 (단위: 픽셀). 패널 요소를 임계값 이상으로 끌어다 놓아야만이 목적 패널로 이동한다.</ko>\n\t * @param {Number} [options.duration=100] Duration of the panel movement. (unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n\t * @param {Function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] The easing function to apply to a panel moving animation. The default function is easeOutCubic.<ko>패널 이동 애니메이션에 적용할 `easing`함수. 기본값은 `easeOutCubic`이다.</ko>\n\t * @param {Number} [options.defaultIndex=0] The panel index number to specify when initializing the module. A zero-based integer.<ko>모듈 초기화시 지정할 패널 인덱스 번호. 0부터 시작하는 정수.</ko>\n\t * @param {Array} [options.inputType=[\"touch,\"mouse\"]] Types of input devices. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput Reference})<br>- \"touch\": A touch input device.<br>- \"mouse\": A mouse.<ko>입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.PanInput.html|eg.Axes.PanInput 참고})<br>- \"touch\": 터치 입력 장치.<br>- \"mouse\": 마우스.</ko>\n\t * @param {Number} [options.thresholdAngle=45] The threshold value that determines whether user input is horizontal or vertical. (0 ~ 90)<ko>사용자의 입력이 가로 방향인지 세로 방향인지 판단하는 기준 각도 (0 ~ 90)</ko>\n\t * @param {Boolean} [options.adaptiveHeight=false] Whether the height of the container element reflects the height value of the panel after completing the movement.<br>(Note: on Android 4.1.x stock browser, has rendering bug which not correctly render height value on panel with single node. To avoid just append another empty node at the end.)<ko>목적 패널로 이동한 후 그 패널의 높이값을 컨테이너 요소의 높이값에 반영할지 여부.<br>(참고: Android 4.1.x 스톡 브라우저에서 단일 노드로 구성된 패널의 높이값 변경이 제대로 렌더링 되지 않는 버그가 있음. 비어있는 노드를 추가하면 해결이 가능하다.)</ko>\n\t * @param {Number} [options.zIndex=2000] z-index value for container element<ko>컨테이너 요소의 z-index 값</ko>\n\t * @param {Boolean} [options.useTranslate=true] Use css translate method on panel moves. When set to 'false', it'll use top/left instead.<ko>패널 이동시 CSS translate 사용 여부. 'false'로 설정 시, top/left 속성을 사용</ko>\n\t*/\n\tconstructor(element, options, _prefix) {\n\t\tsuper();\n\n\t\tthis.$wrapper = utils.$(element);\n\t\tthis.plugins = [];\n\n\t\tconst $children = this.$wrapper && this.$wrapper.children;\n\n\t\tif (!this.$wrapper || !$children || !$children.length) {\n\t\t\t// eslint-disable validateLineBreaks, maximumLineLength\n\t\t\tthrow new Error(\"Given base element doesn't exist or it hasn't proper DOM structure to be initialized.\");\n\n\t\t\t// eslint-enable validateLineBreaks, maximumLineLength\n\t\t}\n\n\t\tthis._setOptions(options);\n\t\tthis._setConfig($children, _prefix);\n\n\t\t!utils.hasClickBug() && (this._setPointerEvents = () => {});\n\n\t\tthis._build();\n\t\tthis._bindEvents(true);\n\n\t\tthis._applyPanelsCss();\n\t\tthis._arrangePanels();\n\n\t\tthis.options.hwAccelerable && SUPPORT_WILLCHANGE && this._setHint();\n\t\tthis.options.adaptiveHeight && this._setAdaptiveHeight();\n\n\t\tthis._adjustContainerCss(\"end\");\n\t}\n\n\t/**\n\t * Set options values\n\t * @private\n\t * @param {Object} options\n\t */\n\t_setOptions(options) {\n\t\t// default value of previewPadding and bounce\n\t\tconst arrVal = {\n\t\t\tpreviewPadding: [0, 0],\n\t\t\tbounce: [10, 10]\n\t\t};\n\n\t\tthis.options = utils.extend(utils.extend({}, OPTIONS), arrVal, options);\n\n\t\tfor (const key in arrVal) {\n\t\t\tlet val = this.options[key];\n\n\t\t\tif (/(number|string)/.test(typeof val)) {\n\t\t\t\tval = [val, val];\n\t\t\t} else if (!utils.isArray(val)) {\n\t\t\t\tval = arrVal[key];\n\t\t\t}\n\n\t\t\tthis.options[key] = val;\n\t\t}\n\n\t\t// block use of translate for Android2 environment\n\t\tif (IS_ANDROID2) {\n\t\t\tthis.options.useTranslate = false;\n\t\t}\n\t}\n\n\t/**\n\t * Set config values\n\t * @private\n\t * @param {HTMLCollection} $children wrappers' children elements\n\t * @param {String} _prefix event prefix\n\t * @return {HTMLElement}\n\t */\n\t_setConfig($children, _prefix) {\n\t\tconst options = this.options;\n\t\tconst padding = options.previewPadding;\n\t\tlet $nodes = $children;\n\n\t\tif (utils.classList($nodes[0], `${options.prefix}-container`)) {\n\t\t\t$nodes = $nodes[0];\n\t\t\tthis.$container = $nodes;\n\t\t\t$nodes = $nodes.children;\n\t\t}\n\n\t\t// convert to array\n\t\t$nodes = utils.toArray($nodes);\n\n\t\t// config value\n\t\tconst conf = this._conf = utils.extend(utils.extend({}, CONFIG), {\n\t\t\tpanel: {\n\t\t\t\t$list: $nodes,\n\t\t\t\tminCount: padding[0] + padding[1] > 0 ? 5 : 3  // minimum panel count\n\t\t\t},\n\t\t\t// remember original class and inline style in case of restoration on destroy()\n\t\t\torigPanelStyle: {\n\t\t\t\twrapper: {\n\t\t\t\t\tclassName: this.$wrapper.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: this.$wrapper.getAttribute(\"style\") || null\n\t\t\t\t},\n\t\t\t\tcontainer: {\n\t\t\t\t\tclassName: (this.$container && this.$container.getAttribute(\"class\")) || null,\n\t\t\t\t\tstyle: (this.$container && this.$container.getAttribute(\"style\")) || null\n\t\t\t\t},\n\t\t\t\tlist: $nodes.map(v => ({\n\t\t\t\t\tclassName: v.getAttribute(\"class\") || null,\n\t\t\t\t\tstyle: v.getAttribute(\"style\") || null\n\t\t\t\t}))\n\t\t\t},\n\t\t\tuseLayerHack: options.hwAccelerable && !SUPPORT_WILLCHANGE,\n\t\t\teventPrefix: _prefix || \"\"\n\t\t});\n\n\t\t[[\"LEFT\", \"RIGHT\"], [\"UP\", \"DOWN\"]][+!options.horizontal]\n\t\t\t.forEach(v => conf.dirData.push(Axes[`DIRECTION_${v}`]));\n\t}\n\n\t/**\n\t * Build and set panel nodes to make flicking structure\n\t * @private\n\t */\n\t_build() {\n\t\tconst panel = this._conf.panel;\n\t\tconst options = this.options;\n\t\tconst $children = panel.$list;\n\t\tconst padding = options.previewPadding.concat();\n\t\tconst prefix = options.prefix;\n\t\tconst horizontal = options.horizontal;\n\t\tlet panelCount = panel.count = panel.origCount = $children.length;\n\t\tconst bounce = options.bounce;\n\n\t\tthis._setPadding(padding, true);\n\t\tconst sizeValue = this._getDataByDirection([panel.size, \"100%\"]);\n\n\t\t// container element style\n\t\tconst cssValue = {\n\t\t\tposition: \"relative\",\n\t\t\tzIndex: options.zIndex || 2000,\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\"\n\t\t};\n\n\t\thorizontal && (cssValue.top = \"0px\");\n\n\t\tif (this.$container) {\n\t\t\tutils.css(this.$container, cssValue);\n\t\t} else {\n\t\t\tconst $parent = $children[0].parentNode;\n\t\t\tconst $container = document.createElement(\"div\");\n\n\t\t\t$container.className = `${prefix}-container`;\n\t\t\tutils.css($container, cssValue);\n\n\t\t\t$children.forEach(v => $container.appendChild(v));\n\n\t\t\t$parent.appendChild($container);\n\t\t\tthis.$container = $container;\n\t\t}\n\n\t\t// panels' css values\n\t\t$children.forEach(v => {\n\t\t\tutils.classList(v, `${prefix}-panel`, true);\n\n\t\t\tutils.css(v, {\n\t\t\t\tposition: \"absolute\",\n\t\t\t\twidth: utils.getUnitValue(sizeValue[0]),\n\t\t\t\theight: utils.getUnitValue(sizeValue[1]),\n\t\t\t\tboxSizing: \"border-box\",\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t});\n\t\t});\n\n\t\tif (this._addClonePanels()) {\n\t\t\tpanelCount = panel.count = (\n\t\t\t\tpanel.$list = utils.toArray(this.$container.children)\n\t\t\t).length;\n\t\t}\n\n\t\t// create Axes instance\n\t\tthis._axesInst = new Axes({\n\t\t\tflick: {\n\t\t\t\trange: [0, panel.size * (panelCount - 1)],\n\t\t\t\tbounce\n\t\t\t}\n\t\t}, {\n\t\t\teasing: options.panelEffect,\n\t\t\tdeceleration: options.deceleration,\n\t\t\tinterruptable: false\n\t\t});\n\n\t\tthis._setDefaultPanel(options.defaultIndex);\n\t}\n\n\t/**\n\t * Set preview padding value\n\t * @private\n\t * @param {Array} padding\n\t * @param {Boolean} build\n\t */\n\t_setPadding(padding, build) {\n\t\tconst $wrapper = this.$wrapper;\n\t\tconst horizontal = this.options.horizontal;\n\t\tconst panel = this._conf.panel;\n\t\tconst paddingSum = padding.reduce((a, c) => parseFloat(a) + parseFloat(c));\n\t\tconst cssValue = {};\n\n\t\tif (paddingSum || !build) {\n\t\t\thorizontal && padding.reverse();\n\n\t\t\tcssValue.padding = `${horizontal ? \"0 \" : \"\"}${\n\t\t\t\t// add 'px' unit if not present\n\t\t\t\tpadding.map(v => (isNaN(v) ? v : `${v}px`))\n\t\t\t\t\t.join(\" 0 \")\n\t\t\t}`;\n\t\t}\n\n\t\tif (build) {\n\t\t\tcssValue.overflow = \"hidden\";\n\t\t\tcssValue.boxSizing = \"border-box\";\n\t\t}\n\n\t\tObject.keys(cssValue).length && utils.css($wrapper, cssValue);\n\n\t\tconst paddingType = horizontal ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"];\n\t\tconst wrapperSize = Math.max(\n\t\t\t$wrapper[`offset${horizontal ? \"Width\" : \"Height\"}`],\n\t\t\tutils.css($wrapper, horizontal ? \"width\" : \"height\", true)\n\t\t);\n\n\t\tpanel.size = wrapperSize - (\n\t\t\tutils.css($wrapper, `padding${paddingType[0]}`, true) +\n\t\t\tutils.css($wrapper, `padding${paddingType[1]}`, true)\n\t\t);\n\t}\n\n\t/**\n\t * To fulfill minimum panel count cloning original node when circular or previewPadding option are set\n\t * @private\n\t * @return {Boolean} true : added clone node, false : not added\n\t */\n\t_addClonePanels() {\n\t\tconst panel = this._conf.panel;\n\t\tconst panelCount = panel.origCount;\n\t\tconst cloneCount = panel.minCount - panelCount;\n\t\tconst list = panel.$list;\n\t\tlet cloneNodes;\n\n\t\t// if panels are given less than required when circular option is set, then clone node to apply circular mode\n\t\tif (this.options.circular && panelCount < panel.minCount) {\n\t\t\tcloneNodes = list.map(v => v.cloneNode(true));\n\n\t\t\twhile (cloneNodes.length < cloneCount) {\n\t\t\t\tcloneNodes = cloneNodes.concat(\n\t\t\t\t\tlist.map(v => v.cloneNode(true))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcloneNodes.forEach(v => this.$container.appendChild(v));\n\n\t\t\treturn !!cloneNodes.length;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Move panel's position within array\n\t * @private\n\t * @param {Number} count element counts to move\n\t * @param {Boolean} append where the list to be appended(moved) (true: to the end, false: to the beginning)\n\t */\n\t_movePanelPosition(count, append) {\n\t\tconst panel = this._conf.panel;\n\t\tconst list = panel.$list;\n\t\tconst listToMove = list.splice(append ? 0 : panel.count - count, count);\n\n\t\tpanel.$list = append ?\n\t\t\tlist.concat(listToMove) :\n\t\t\tlistToMove.concat(list);\n\t}\n\n\t/**\n\t * Set default panel to show\n\t * @private\n\t * @param {Number} index\n\t */\n\t_setDefaultPanel(index) {\n\t\tconst panel = this._conf.panel;\n\t\tconst lastIndex = panel.count - 1;\n\t\tlet coords;\n\t\tlet baseIndex;\n\n\t\tif (this.options.circular) {\n\t\t\t// if default index is given, then move correspond panel to the first position\n\t\t\tif (index > 0 && index <= lastIndex) {\n\t\t\t\tthis._movePanelPosition(index, true);\n\t\t\t}\n\n\t\t\t// set first panel's position according physical node length\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\t\t\tthis._movePanelPosition(baseIndex, false);\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tno: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\t\t\t// if defaultIndex option is given, then move to that index panel\n\t\t} else if (index > 0 && index <= lastIndex) {\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex,\n\t\t\t\tno: index,\n\t\t\t\tcurrIndex: index,\n\t\t\t\tcurrNo: index\n\t\t\t});\n\n\t\t\tcoords = [-(panel.size * index), 0];\n\n\t\t\tthis._setTranslate(coords);\n\t\t\tthis._setAxes(\"setTo\", Math.abs(coords[0]), 0);\n\t\t}\n\t}\n\n\t/**\n\t * Arrange panels' position\n\t * @private\n\t * @param {Boolean} sort Need to sort panel's position\n\t * @param {Number} indexToMove Number to move from current position (negative: left, positive: right)\n\t */\n\t_arrangePanels(sort, indexToMove) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst touch = conf.touch;\n\t\tconst dirData = conf.dirData;\n\t\tlet baseIndex;\n\n\t\tif (this.options.circular) {\n\t\t\t// when arranging panels, set flag to not trigger flick custom event\n\t\t\tconf.customEvent.flick = false;\n\n\t\t\t// move elements according direction\n\t\t\tif (sort) {\n\t\t\t\tindexToMove && (touch.direction = dirData[+!(indexToMove > 0)]);\n\t\t\t\tthis._arrangePanelPosition(touch.direction, indexToMove);\n\t\t\t}\n\n\t\t\t// set index for base element's position\n\t\t\tbaseIndex = this._getBasePositionIndex();\n\n\t\t\tthis._setPanelNo({\n\t\t\t\tindex: baseIndex,\n\t\t\t\tcurrIndex: baseIndex\n\t\t\t});\n\n\t\t\t// arrange Axes' coord position\n\t\t\tconf.customEvent.flick = !!this._setAxes(\"setTo\", panel.size * panel.index, 0);\n\t\t}\n\n\t\tthis._applyPanelsPos();\n\t}\n\n\t/**\n\t * Set each panel's position in DOM\n\t * @private\n\t */\n\t_applyPanelsPos() {\n\t\tthis._conf.panel.$list.forEach(this._applyPanelsCss.bind(this));\n\t}\n\n\t/**\n\t * Set CSS style values to move elements\n\t *\n\t * Initialize setting up checking if browser support transform css property.\n\t * If browser doesn't support transform, then use left/top properties instead.\n\t * @private\n\t * @param {HTMLElement} $el\n\t * @param {Array} coordsValue\n\t */\n\t_setMoveStyle($el, coordsValue) {\n\t\tconst transform = TRANSFORM;\n\t\tconst useLayerHack = this._conf.useLayerHack;\n\n\t\tthis._setMoveStyle = transform.support ?\n\t\t\t($element, coords) => {\n\t\t\t\tutils.css($element, {\n\t\t\t\t\t[transform.name]: utils.translate(coords[0], coords[1], useLayerHack)\n\t\t\t\t});\n\t\t\t} : ($element, coords) => {\n\t\t\t\tutils.css($element, {left: coords[0], top: coords[1]});\n\t\t\t};\n\n\t\tthis._setMoveStyle($el, coordsValue);\n\t}\n\n\t/**\n\t * Callback function for applying CSS values to each panels\n\t * Need to be initialized before use, to set up for Android 2.x browsers or others.\n\t * @private\n\t */\n\t_applyPanelsCss() {\n\t\tconst conf = this._conf;\n\t\tconst dummyAnchorClassName = \"__dummy_anchor\";\n\t\tconst useTranslate = this.options.useTranslate;\n\n\t\tif (!useTranslate) {\n\t\t\tif (IS_ANDROID2) {\n\t\t\t\tconf.$dummyAnchor = utils.$(`.${dummyAnchorClassName}`);\n\n\t\t\t\t!conf.$dummyAnchor && this.$wrapper.appendChild(\n\t\t\t\t\tconf.$dummyAnchor = utils.$(`<a href=\"javascript:void(0)\" class=\"${dummyAnchorClassName}\" style=\"position:absolute;height:0px;width:0px\">`)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis._applyPanelsCss = function(v, i) {\n\t\t\t\tconst coords = this._getDataByDirection(\n\t\t\t\t\t[`${this._conf.panel.size * i}px`, 0]\n\t\t\t\t);\n\n\t\t\t\tutils.css(v, {\n\t\t\t\t\tleft: coords[0],\n\t\t\t\t\ttop: coords[1]\n\t\t\t\t});\n\t\t\t};\n\t\t} else {\n\t\t\tthis._applyPanelsCss = function(v, i) {\n\t\t\t\tconst coords = this._getDataByDirection([\n\t\t\t\t\tTRANSFORM.support ?\n\t\t\t\t\t\t`${100 * i}%` :\n\t\t\t\t\t\t`${this._conf.panel.size * i}px`, 0\n\t\t\t\t]);\n\n\t\t\t\tthis._setMoveStyle(v, coords);\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Adjust container's css value to handle Android 2.x link highlighting bug\n\t * @private\n\t * @param {String} phase\n\t *    start - set left/top value to 0\n\t *    end - set translate value to 0\n\t * @param {Array} toValue coordinate value\n\t */\n\t_adjustContainerCss(phase, toValue) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst options = this.options;\n\t\tconst useTranslate = options.useTranslate;\n\t\tconst horizontal = options.horizontal;\n\t\tconst paddingTop = options.previewPadding[0];\n\t\tlet container = this.$container;\n\t\tlet to = toValue;\n\t\tlet value;\n\n\t\tif (!useTranslate) {\n\t\t\tif (!to) {\n\t\t\t\tto = -panel.size * panel.index;\n\t\t\t}\n\n\t\t\tif (phase === \"start\") {\n\t\t\t\tcontainer = container.style;\n\t\t\t\tvalue = parseFloat(container[horizontal ? \"left\" : \"top\"]);\n\n\t\t\t\tif (horizontal) {\n\t\t\t\t\tvalue && (container.left = \"0px\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue !== paddingTop && (container.top = \"0px\");\n\t\t\t\t}\n\n\t\t\t\tthis._setTranslate([-to, 0]);\n\t\t\t} else if (phase === \"end\") {\n\t\t\t\tto = this._getCoordsValue([to, 0]);\n\n\t\t\t\tutils.css(container, {\n\t\t\t\t\tleft: to.x,\n\t\t\t\t\ttop: to.y,\n\t\t\t\t\t[TRANSFORM.name]: utils.translate(0, 0, conf.useLayerHack)\n\t\t\t\t});\n\n\t\t\t\tconf.$dummyAnchor && conf.$dummyAnchor.focus();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set Axes coord value\n\t * @private\n\t * @param {String} method\n\t * @param {Number} flick destination value\n\t * @param {Number} duration\n\t * @return {eg.Axes} Axes instance\n\t */\n\t_setAxes(method, flick, duration) {\n\t\treturn this._axesInst[method]({flick}, duration);\n\t}\n\n\t/**\n\t * Set hint for browser to decide efficient way of doing transform changes(or animation)\n\t * https://dev.opera.com/articles/css-will-change-property/\n\t * @private\n\t */\n\t_setHint() {\n\t\tconst style = {willChange: \"transform\"};\n\n\t\tutils.css(this.$container, style);\n\t\tutils.css(this._conf.panel.$list, style);\n\t}\n\n\t/**\n\t * Get data according options.horizontal value\n\t * @private\n\t * @param {Array} value primary data to handle\n\t * @return {Array}\n\t */\n\t_getDataByDirection(value) {\n\t\tconst data = value.concat();\n\n\t\t!this.options.horizontal && data.reverse();\n\t\treturn data;\n\t}\n\n\t/**\n\t * Move nodes\n\t * @private\n\t * @param {Boolean} direction\n\t * @param {Number} indexToMove\n\t */\n\t_arrangePanelPosition(direction, indexToMove) {\n\t\tconst next = direction === this._conf.dirData[0];\n\n\t\tthis._movePanelPosition(Math.abs(indexToMove || 1), next);\n\t}\n\n\t/**\n\t * Get the base position index of the panel\n\t * @private\n\t */\n\t_getBasePositionIndex() {\n\t\treturn Math.floor(this._conf.panel.count / 2 - 0.1);\n\t}\n\n\t/**\n\t * Bind events\n\t * @private\n\t * @param {Boolean} bind\n\t */\n\t_bindEvents(bind) {\n\t\tconst options = this.options;\n\t\tconst $wrapper = this.$wrapper;\n\t\tconst axesInst = this._axesInst;\n\n\t\tif (bind) {\n\t\t\tthis._panInput = new PanInput($wrapper, {\n\t\t\t\tinputType: options.inputType,\n\t\t\t\tthresholdAngle: options.thresholdAngle,\n\t\t\t\tscale: this._getDataByDirection([-1, 0])\n\t\t\t});\n\n\t\t\taxesInst.on({\n\t\t\t\thold: this._holdHandler.bind(this),\n\t\t\t\tchange: this._changeHandler.bind(this),\n\t\t\t\trelease: this._releaseHandler.bind(this),\n\t\t\t\tanimationStart: this._animationStartHandler.bind(this),\n\t\t\t\tanimationEnd: this._animationEndHandler.bind(this)\n\t\t\t}).connect(this._getDataByDirection([\"flick\", \"\"]), this._panInput);\n\t\t} else {\n\t\t\tthis.disableInput();\n\t\t\taxesInst.off();\n\t\t}\n\t}\n\n\t/**\n\t * Set container's height value according to children's height\n\t * @private\n\t * @param {Number} direction\n\t */\n\t_setAdaptiveHeight(direction) {\n\t\tconst conf = this._conf;\n\t\tconst indexToMove = conf.indexToMove;\n\t\tlet $children;\n\t\tlet height;\n\n\t\tconst $panel = indexToMove === 0 ?\n\n\t\t\t// panel moved by 1\n\t\t\tthis[`get${\n\t\t\t\t(direction === Axes.DIRECTION_LEFT && \"Next\") ||\n\t\t\t\t(direction === Axes.DIRECTION_RIGHT && \"Prev\") || \"\"\n\t\t\t}Element`]() :\n\n\t\t\t// panel moved by .moveTo()\n\t\t\tconf.panel.$list[\n\t\t\t\tconf.panel.currIndex + indexToMove\n\t\t\t];\n\n\t\tconst $first = $panel.querySelector(\":first-child\");\n\n\t\tif ($first) {\n\t\t\theight = $first.getAttribute(DATA_HEIGHT);\n\n\t\t\tif (!height) {\n\t\t\t\t$children = $panel.children;\n\n\t\t\t\theight = utils.outerHeight(\n\t\t\t\t\t$children.length > 1 ? ($panel.style.height = \"auto\", $panel) : $first\n\t\t\t\t);\n\n\t\t\t\theight > 0 && $first.setAttribute(DATA_HEIGHT, height);\n\t\t\t}\n\n\t\t\theight > 0 && (this.$wrapper.style.height = `${height}px`);\n\t\t}\n\t}\n\n\t/**\n\t * Trigger beforeRestore event\n\t * @private\n\t * @param {Object} e event object\n\t */\n\t_triggerBeforeRestore(e) {\n\t\tconst conf = this._conf;\n\t\tconst touch = conf.touch;\n\n\t\t// reverse direction value when restore\n\t\ttouch.direction = +conf.dirData.join(\"\").replace(touch.direction, \"\");\n\n\t\t/**\n\t\t * This event occurs before the current panel starts to return to its original position. Followes [flick]{@link eg.Flicking#event:flick} and [restore]{@link eg.Flicking#event:restore} events. The conditions of occurrence are as follows.<br><br>1. The user has finished input but does not exceed the panel movement threshold.<br>2. Call the [restore()]{@link eg.Flicking#restore} method. (Prevent the default behavior of the [beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart} event.)\n\t\t * @ko 현재 패널이 원래 위치로 되돌아가기 시작전에 발생하는 이벤트이다. 뒤이어 [flick]{@link eg.Flicking#event:flick}과 [restore]{@link eg.Flicking#event:restore}이벤트가 발생한다. 발생조건은 아래와 같다.<br><br>1. 사용자 입력이 끝났는데 패널 이동 임계점을 넘지 않은 경우.<br>2. [restore()]{@link eg.Flicking#restore} 메서드 호출.([beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart} 이벤트의 기본동작 방지 전제)\n\t\t * @name eg.Flicking#beforeRestore\n\t\t * @event\n\t\t * @property {String} eventType The name of the event <ko>이벤트 명</ko>\n\t\t * @property {Boolean} isTrusted `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n\t\t * @property {Number} no Index number of the current panel element. See the [getIndex()]{@link eg.Flicking#getIndex} method.<ko>현재 패널 요소의 인덱스 번호. [getIndex()]{@link eg.Flicking#getIndex}메서드 참조.</ko>\n\t\t * @property {Number} direction of the panel movement. If `horizontal=true` is {@link eg.Flicking.DIRECTION_LEFT} or {@link eg.Flicking.DIRECTION_RIGHT}. If `horizontal=false` is {@link eg.Flicking.DIRECTION_UP} or {@link eg.Flicking.DIRECTION_DOWN}.<ko>패널 이동 방향. `horizontal=true` 이면 {@link eg.Flicking.DIRECTION_LEFT} 혹은 {@link eg.Flicking.DIRECTION_RIGHT}. `horizontal=false` 이면 {@link eg.Flicking.DIRECTION_UP} 혹은 {@link eg.Flicking.DIRECTION_DOWN}.</ko>\n\t\t * @property {Number} depaPos Starting coordinate. <ko>출발점 좌표.</ko>\n\t\t * @property {Number} destPos Destination coordinate. <ko>도착점 좌표.</ko>\n\t\t * @see eg.Flicking#event:flick\n\t\t * @see eg.Flicking#event:restore\n\t\t * @see eg.Flicking#restore\n\t\t * @example\n\t\t * // The order of event occurrence.\n\t\t * // 이벤트 발생 순서\n\t\t * beforeRestore (once) > flick (many times) > restore (once)\n\t\t */\n\t\tconf.customEvent.restore = this._triggerEvent(EVENTS.beforeRestore, {\n\t\t\tdepaPos: e.depaPos.flick,\n\t\t\tdestPos: e.destPos.flick\n\t\t});\n\n\t\tif (!conf.customEvent.restore) {\n\t\t\t\"stop\" in e && e.stop();\n\t\t\tconf.panel.animating = false;\n\t\t}\n\t}\n\n\t/**\n\t * Trigger restore event\n\t * @private\n\t */\n\t_triggerRestore() {\n\t\tconst customEvent = this._conf.customEvent;\n\n\t\t/**\n\t\t * The event that occurs after completing the move by [restore()]{@link eg.Flicking#restore} method.\n\t\t * @ko [restore()]{@link eg.Flicking#restore} 메서드에 의해 패널이 원래 위치로 이동을 완료한 다음 발생하는 이벤트.\n\t\t * @name eg.Flicking#restore\n\t\t * @event\n\t\t * @property {String} eventType The name of the event <ko>이벤트 명</ko>\n\t\t * @property {Boolean} isTrusted `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n\t\t * @property {Number} no Index number of the current panel element. See the [getIndex()]{@link eg.Flicking#getIndex} method.<ko>현재 패널 요소의 인덱스 번호. [getIndex()]{@link eg.Flicking#getIndex}메서드 참조.</ko>\n\t\t * @property {Number} direction of the panel movement. If `horizontal=true` is {@link eg.Flicking.DIRECTION_LEFT} or {@link eg.Flicking.DIRECTION_RIGHT}. If `horizontal=false` is {@link eg.Flicking.DIRECTION_UP} or {@link eg.Flicking.DIRECTION_DOWN}.<ko>패널 이동 방향. `horizontal=true` 이면 {@link eg.Flicking.DIRECTION_LEFT} 혹은 {@link eg.Flicking.DIRECTION_RIGHT}. `horizontal=false` 이면 {@link eg.Flicking.DIRECTION_UP} 혹은 {@link eg.Flicking.DIRECTION_DOWN}.</ko>\n\t\t * @see eg.Flicking#event:beforeRestore\n\t\t * @see eg.Flicking#event:flick\n\t\t * @see eg.Flicking#restore\n\t\t * @example\n\t\t * // The order of event occurrence.\n\t\t * // 이벤트 발생 순서\n\t\t * beforeRestore (once) > flick (many times) > restore (once)\n\t\t */\n\t\tcustomEvent.restore && this._triggerEvent(EVENTS.restore);\n\t\tcustomEvent.restore = customEvent.restoreCall = false;\n\t}\n\n\t/**\n\t * Set value when panel changes\n\t * @private\n\t * @param {String} phase - [start|end]\n\t * @param {Object} pos\n\t */\n\t_setPhaseValue(phase, pos) {\n\t\tconst conf = this._conf;\n\t\tconst options = this.options;\n\t\tconst panel = conf.panel;\n\t\tconst useTranslate = options.useTranslate;\n\n\t\tif (phase === \"start\" && (panel.changed = this._isMovable())) {\n\t\t\t/**\n\t\t\t * An event that occurs before a user action or [moveTo()]{@link eg.Flicking#moveTo}, [prev()]{@link eg.Flicking#prev}, [next()]{@link eg.Flicking#next} method initiates a move to the destination panel. If you do not prevent the default behavior, then many [flick]{@link eg.Flicking#event:flick} events and one [flickEnd]{@link eg.Flicking#event:flickEnd} event will occur.\n\t\t\t * @ko 사용자 액션 혹은 [moveTo()]{@link eg.Flicking#moveTo}, [prev()]{@link eg.Flicking#prev}, [next()]{@link eg.Flicking#next} 메서드에 의해 목적 패널로의 이동 시작전 발생하는 이벤트. 기본동작을 막지 않는다면 뒤이어 다수의 [flick]{@link eg.Flicking#event:flick}이벤트와 그 뒤 한 번의 [flickEnd]{@link eg.Flicking#event:flickEnd}이벤트가 발생한다.\n\t\t\t * @name eg.Flicking#beforeFlickStart\n\t\t\t * @event\n\t\t\t * @property {String} eventType The name of the event <ko>이벤트 명</ko>\n\t\t\t * @property {Boolean} isTrusted `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`</ko>\n\t\t\t * @property {Number} no Index number of the current panel element. See the [getIndex()]{@link eg.Flicking#getIndex} method.<ko>현재 패널 요소의 인덱스 번호. [getIndex()]{@link eg.Flicking#getIndex}메서드 참조.</ko>\n\t\t\t * @property {Number} direction of the panel movement. If `horizontal=true` is {@link eg.Flicking.DIRECTION_LEFT} or {@link eg.Flicking.DIRECTION_RIGHT}. If `horizontal=false` is {@link eg.Flicking.DIRECTION_UP} or {@link eg.Flicking.DIRECTION_DOWN}.<ko>패널 이동 방향. `horizontal=true` 이면 {@link eg.Flicking.DIRECTION_LEFT} 혹은 {@link eg.Flicking.DIRECTION_RIGHT}. `horizontal=false` 이면 {@link eg.Flicking.DIRECTION_UP} 혹은 {@link eg.Flicking.DIRECTION_DOWN}.</ko>\n\t\t\t * @property {Number} depaPos Starting coordinate. <ko>출발점 좌표.</ko>\n\t\t\t * @property {Number} destPos Destination coordinate. <ko>도착점 좌표.</ko>\n\t\t\t * @property {Function} stop Cancels the default action. (Default action: Move to destination panel.) The panel element stays at the position of the call to `stop()`. To return to the original position, you must call the [restore()]{@link eg.Flicking#restore} method.<ko>기본동작을 취소한다. (기본동작: 목적 패널로의 이동.) 패널 요소가 `stop()`호출시점의 위치에 머물러 있는다. 원래 자리로 되돌리려면 [restore()]{@link eg.Flicking#restore} 메서드를 호출해야 한다.</ko>\n\t\t\t * @see eg.Flicking#event:flick\n\t\t\t * @see eg.Flicking#event:flickEnd\n\t\t\t * @see eg.Flicking#moveTo\n\t\t\t * @see eg.Flicking#prev\n\t\t\t * @see eg.Flicking#next\n\t\t\t * @example\n\t\t\t * // The order of event occurrence.\n\t\t\t * // 이벤트 발생 순서\n\t\t\t * beforeFlickStart (once) > flick (many times) > flickEnd (once)\n\t\t\t * @example\n\t\t\t * // An example to prevent the default behavior.\n\t\t\t * // 기본동작을 막는 예.\n\t\t\t * new eg.Flicking(\"#flick\").on(\"beforeFlickStart\", e => {\n\t\t\t * \te.stop();\n\t\t\t * });\n\t\t\t */\n\t\t\tif (!this._triggerEvent(EVENTS.beforeFlickStart, pos)) {\n\t\t\t\tpanel.changed = panel.animating = false;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\toptions.adaptiveHeight && this._setAdaptiveHeight(conf.touch.direction);\n\t\t\t}\n\n\t\t\tconf.indexToMove === 0 && this._setPanelNo();\n\t\t} else if (phase === \"end\") {\n\t\t\tif (options.circular && panel.changed) {\n\t\t\t\tthis._arrangePanels(true, conf.indexToMove);\n\t\t\t}\n\n\t\t\tuseTranslate && this._setTranslate([-panel.size * panel.index, 0]);\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\n\t\t\t/**\n\t\t\t * The event that occurs after completing the move to the destination panel. It occurs in the following cases.<br><br>- After completing the movement to the destination panel by user's move input.<br>- `moveTo()`, `prev()`, `next()` method call. (It does not occur if you have disabled the default behavior of the [beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart} event.)\n\t\t\t * @ko 목적 패널로의 이동을 완료한 다음 발생하는 이벤트. 아래의 경우에 발생한다.<br><br>- 사용자의 이동(move) 액션 입력에 의한 목적 패널로의 이동완료 후.<br>- `moveTo()`, `prev()`, `next()` 메서드 호출.([beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart}이벤트의 기본동작을 막았다면 발생하지 않는다.)\n\t\t\t * @name eg.Flicking#flickEnd\n\t\t\t * @event\n\t\t\t * @property {String} eventType The name of the event.<ko>이벤트 명</ko>\n\t\t\t * @property {Boolean} isTrusted `true` when the event was generated by a user action(\"mouse\" or \"touch\") otherwise `false`.<ko>사용자 액션(\"mouse\" 또는 \"touch\")에 의해 이벤트가 생성된 경우 `true`. 그 외는 `false`.</ko>\n\t\t\t * @property {Number} no Index number of the current panel element. See the [getIndex()]{@link eg.Flicking#getIndex} method.<ko>현재 패널 요소의 인덱스 번호. [getIndex()]{@link eg.Flicking#getIndex}메서드 참조.</ko>\n\t\t\t * @property {Number} direction of the panel movement. If `horizontal=true` is {@link eg.Flicking.DIRECTION_LEFT} or {@link eg.Flicking.DIRECTION_RIGHT}. If `horizontal=false` is {@link eg.Flicking.DIRECTION_UP} or {@link eg.Flicking.DIRECTION_DOWN}.<ko>패널 이동 방향. `horizontal=true` 이면 {@link eg.Flicking.DIRECTION_LEFT} 혹은 {@link eg.Flicking.DIRECTION_RIGHT}. `horizontal=false` 이면 {@link eg.Flicking.DIRECTION_UP} 혹은 {@link eg.Flicking.DIRECTION_DOWN}.</ko>\n\t\t\t * @see eg.Flicking#event:beforeFlickStart\n\t\t\t * @see eg.Flicking#event:flick\n\t\t\t * @see eg.Flicking#moveTo\n\t\t\t * @see eg.Flicking#prev\n\t\t\t * @see eg.Flicking#next\n\t\t\t * @example\n\t\t\t * // The order of event occurrence.\n\t\t\t * // 이벤트 발생 순서\n\t\t\t * beforeFlickStart (once) > flick (many times) > flickEnd (once)\n\t\t\t */\n\t\t\tpanel.changed && this._triggerEvent(EVENTS.flickEnd);\n\t\t}\n\n\t\tthis._adjustContainerCss(phase);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get positive or negative according direction\n\t * @private\n\t */\n\t_getNumByDirection() {\n\t\tconst conf = this._conf;\n\n\t\treturn conf.touch.direction === conf.dirData[0] ? 1 : -1;\n\t}\n\n\t/**\n\t * Revert panel number\n\t * @private\n\t */\n\t_revertPanelNo() {\n\t\tconst panel = this._conf.panel;\n\t\tconst num = this._getNumByDirection();\n\n\t\tconst index = panel.currIndex >= 0 ? panel.currIndex : panel.index - num;\n\t\tconst no = panel.currNo >= 0 ? panel.currNo : panel.no - num;\n\n\t\tthis._setPanelNo({\n\t\t\tindex,\n\t\t\tno\n\t\t});\n\t}\n\n\t/**\n\t * Set the panel number\n\t * @private\n\t * @param {Object} obj number object\n\t */\n\t_setPanelNo(obj) {\n\t\tconst panel = this._conf.panel;\n\t\tconst count = panel.origCount - 1;\n\t\tconst num = this._getNumByDirection();\n\n\t\tif (utils.isObject(obj)) {\n\t\t\tfor (const key in obj) {\n\t\t\t\tpanel[key] = obj[key];\n\t\t\t}\n\t\t} else {\n\t\t\t// remember current value\n\t\t\tpanel.currIndex = panel.index;\n\t\t\tpanel.currNo = panel.no;\n\n\t\t\tpanel.index += num;\n\t\t\tpanel.no += num;\n\t\t}\n\n\t\tif (panel.no > count) {\n\t\t\tpanel.no = 0;\n\t\t} else if (panel.no < 0) {\n\t\t\tpanel.no = count;\n\t\t}\n\t}\n\n\t/**\n\t * Set pointerEvents css property on container element due to the iOS click bug\n\t * @private\n\t * @param {Event} e\n\t */\n\t_setPointerEvents(e) {\n\t\tconst $container = this.$container;\n\t\tconst pointer = utils.css($container, \"pointerEvents\");\n\t\tlet pointerEvents;\n\n\t\tif (e && e.holding &&\n\t\t\te.inputEvent && e.inputEvent.preventSystemEvent &&\n\t\t\tpointer !== \"none\"\n\t\t) {\n\t\t\tpointerEvents = \"none\";\n\t\t} else if (!e && pointer !== \"auto\") {\n\t\t\tpointerEvents = \"auto\";\n\t\t}\n\n\t\tpointerEvents && utils.css($container, {pointerEvents});\n\t}\n\n\t/**\n\t * Get coordinate value with unit\n\t * @private\n\t * @param coordsValue {Array} x,y numeric value\n\t * @return {Object} x,y coordinate value with unit\n\t */\n\t_getCoordsValue(coordsValue) {\n\t\t// the param comes as [ val, 0 ], whatever the direction. So reorder the value depend the direction.\n\t\tconst coords = this._getDataByDirection(coordsValue);\n\n\t\treturn {\n\t\t\tx: utils.getUnitValue(coords[0]),\n\t\t\ty: utils.getUnitValue(coords[1])\n\t\t};\n\t}\n\n\t/**\n\t * Set translate property value\n\t * @private\n\t * @param {Array} coordsValue coordinate x,y value\n\t */\n\t_setTranslate(coordsValue) {\n\t\tconst coords = this._getCoordsValue(coordsValue);\n\n\t\tthis._setMoveStyle(this.$container, [coords.x, coords.y]);\n\t}\n\n\t/**\n\t * Check if panel passed through threshold pixel\n\t * @private\n\t */\n\t_isMovable() {\n\t\tconst options = this.options;\n\t\tconst axesInst = this._axesInst;\n\t\tconst isMovable = Math.abs(this._conf.touch.distance) >= options.threshold;\n\t\tlet max;\n\t\tlet currPos;\n\n\t\tif (!options.circular && isMovable) {\n\t\t\tmax = axesInst.axis.flick.range[1];\n\t\t\tcurrPos = axesInst.get().flick;\n\n\t\t\t// if current position out of range\n\t\t\tif (currPos < 0 || currPos > max) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn isMovable;\n\t}\n\n\t/**\n\t * Trigger custom events\n\t * @private\n\t * @param {String} name - event name\n\t * @param {Object} param - additional event value\n\t * @return {Boolean}\n\t */\n\t_triggerEvent(name, param) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\n\t\t// pass changed panel no only on 'flickEnd' event\n\t\tif (name === EVENTS.flickEnd) {\n\t\t\tpanel.currNo = panel.no;\n\t\t\tpanel.currIndex = panel.index;\n\t\t}\n\n\t\treturn this.trigger(conf.eventPrefix + name, utils.extend({\n\t\t\teventType: name,\n\t\t\tno: panel.currNo,\n\t\t\tdirection: conf.touch.direction,\n\t\t\tisTrusted: conf.touch.isTrusted\n\t\t}, param));\n\t}\n\n\t/**\n\t * Get next/prev panel element/index.\n\t * @private\n\t * @param {Boolean} direction\n\t * @param {Boolean} element - true:to get element, false:to get index\n\t * @param {Number} physical - true : physical, false : logical (@deprecated since 2.2.0)\n\t * @return {HTMLElement|Number}\n\t */\n\t_getElement(direction, element, physical) {\n\t\tconst panel = this._conf.panel;\n\t\tconst circular = this.options.circular;\n\t\tconst pos = panel.currIndex;\n\t\tconst next = direction === this._conf.dirData[0];\n\t\tlet result = null;\n\t\tlet total;\n\t\tlet index;\n\n\t\tif (physical) {\n\t\t\ttotal = panel.count;\n\t\t\tindex = pos;\n\t\t} else {\n\t\t\ttotal = panel.origCount;\n\t\t\tindex = panel.currNo;\n\t\t}\n\n\t\tconst currentIndex = index;\n\n\t\tif (next) {\n\t\t\tif (index < total - 1) {\n\t\t\t\tindex++;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (index > 0) {\n\t\t\t\tindex--;\n\t\t\t} else if (circular) {\n\t\t\t\tindex = total - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (currentIndex !== index) {\n\t\t\tresult = element ? panel.$list[next ? pos + 1 : pos - 1] : index;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Set value to force move panels when duration is 0\n\t * @private\n\t * @param {Boolean} next\n\t */\n\t_setValueToMove(next) {\n\t\tconst conf = this._conf;\n\n\t\tconf.touch.distance = this.options.threshold + 1;\n\t\tconf.touch.direction = conf.dirData[+!next];\n\t}\n\n\t/**\n\t * Returns the index number of the current panel element.\n\t * @ko 현재 패널 요소의 인덱스 번호를 반환한다.\n\t * @method eg.Flicking#getIndex\n\t * @param {Boolean} [physical=false] @deprecated since 2.2.0<br><br>Types of index numbers.<br>- true (Physical): Math.floor({Total number of panels} / 2 - 0.1) value. (Increase by 1 for every two panels.) If the circular option is false, it equals physical=false.<br>- false (Logical): The value of how the content(innerHTML) of the current panel element is in the defined order of the panel elements.<ko>@deprecated since 2.2.0<br><br>인덱스 번호의 종류.<br>- true (물리적): `Math.floor({패널 총 개수} / 2 - 0.1)` 값. (패널이 2개 늘어날 때마다 1씩 증가) `circular`옵션이 `false`이면 `physical=false`와 동일한 값.<br>- false (논리적): 현재 패널 요소의 컨텐트(innerHTML)가 '패널 요소들의 정의된 순서'에서 몇 번째인지에 대한 값.</ko>\n\t * @return {Number} Index number of the current panel element. A zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n\t * @see eg.Flicking#getPrevIndex\n\t * @see eg.Flicking#getNextIndex\n\t * @example\n\t * ```html\n\t * <div id=\"flick\">\n\t * \t<div><p>panel 0</p></div>\n\t * \t<div><p>panel 1</p></div>\n\t * \t<div><p>panel 2</p></div>\n\t * \t<div><p>panel 3</p></div>\n\t * </div>\n\t * ```\n\t * ```javascript\n\t * // circular off and left flicking.\n\t * // 순환을 끄고 좌 플리킹.\n\t * new eg.Flicking(\"#flick\").on(\"flickEnd\", {currentTarget} => {\n\t * \tconsole.log(currentTarget.getIndex()); // 1 > 2 > 3\n\t * \tconsole.log(currentTarget.getIndex(true)); // 1 > 2 > 3\n\t * };\n\t *\n\t * // circular on and left flicking.\n\t * // 순환을 켜고 좌 플리킹.\n\t * new eg.Flicking(\"#flick\", {circular: true}).on(\"flickEnd\", {currentTarget} => {\n\t * \tconsole.log(currentTarget.getIndex()); // 1 > 2 > 3 > 0 > 1 > 2 > 3 > 0 ...\n\t * \tconsole.log(currentTarget.getIndex(true)); // 1 > 1 > 1 > 1 > 1 > 1 > 1 > 1 ...\n\t * };\n\t * ```\n\t * @example\n\t * ```html\n\t * <!--Define only two panels.-->\n\t * <!--패널을 두 개만 정의한다.-->\n\t * <div id=\"flick2\">\n\t * \t<div><p>panel 0</p></div>\n\t * \t<div><p>panel 1</p></div>\n\t * </div>\n\t * ```\n\t * ```javascript\n\t * // (In the case of circulation) If the number of defined panel elements is less than the minimum number required, the number of panels is created.\n\t * // Therefore, it is described as 'the number of panel definitions of the contents of the panel.'\n\t * // (순환인 경우) 정의된 패널 요소의 개수가 필요 최소개수보다 적으면 그 수만큼의 패널을 생성한다.\n\t * // 그렇기 때문에 '패널이 담고 있는 컨텐트의 패널 정의 순성상의 번호'라고 설명한다.\n\t * const flick = new eg.Flicking(\"flick2\", {\n\t * \tcircular: true\n\t * });\n\t *\n\t * // The content of the current panel is the first in the panel definition order.\n\t * // 현재 패널이 담고 있는 컨텐트는 패널 정의 순서상 첫 번째이다.\n\t * flick.getIndex(); // 0\n\t *\n\t * // The content of the next panel is the second in the panel definition order.\n\t * // 다음 패널이 담고 있는 컨텐트는 패널 정의 순서상 두 번째이다.\n\t * flick.getNextIndex(); // 1\n\t *\n\t * // The content of the previous panel is the second in the panel definition order.\n\t * // 이전 패널이 담고 있는 컨텐트는 패널 정의 순서상 두 번째이다.\n\t * flick.getPrevIndex(); // 1\n\t * ```\n\t */\n\tgetIndex(physical) {\n\t\treturn this._conf.panel[physical ? \"currIndex\" : \"currNo\"];\n\t}\n\n\t/**\n\t * Returns the reference of the current panel element.\n\t * @ko 현재 패널 요소의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getElement\n\t * @return {HTMLElement} Current panel element.<ko>현재 패널 요소.</ko>\n\t * @see eg.Flicking#getPrevElement\n\t * @see eg.Flicking#getNextElement\n\t */\n\tgetElement() {\n\t\tconst panel = this._conf.panel;\n\n\t\treturn panel.$list[panel.currIndex];\n\t}\n\n\t/**\n\t * Returns the reference of the next panel element.\n\t * @ko 다음 패널 요소의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getNextElement\n\t * @return {HTMLElement|null} Next panel element or `null` if it does not exist.<ko>다음 패널 요소. 패널이 없으면 `null`을 반환한다.</ko>\n\t * @see eg.Flicking#getElement\n\t * @see eg.Flicking#getPrevElement\n\t */\n\tgetNextElement() {\n\t\treturn this._getElement(this._conf.dirData[0], true);\n\t}\n\n\t/**\n\t * Returns the index number of the next panel element.\n\t * @ko 다음 패널 요소의 인덱스 번호를 반환한다.\n\t * @method eg.Flicking#getNextIndex\n\t * @param {Boolean} [physical=false] @deprecated since 2.2.0<br><br>Types of index numbers<br>- true (Physical): Plus one of [getIndex()]{@link eg.Flicking#getIndex} return value.<br>- false (Logical): The value of how the content(innerHTML) of the next panel element is in the defined order of the panel elements.<ko>@deprecated since 2.2.0<br><br>인덱스 번호의 종류.<br>- true (물리적): [getIndex()]{@link eg.Flicking#getIndex} 반환값에 1을 더한 값.<br>- false (논리적): 다음 패널 요소의 컨텐트(innerHTML)가 '패널 요소들의 정의된 순서'에서 몇 번째인지에 대한 값.</ko>\n\t * @return {Number|null} Index number of the next panel element or null if it does not exist. A zero-based integer.<ko>다음 패널 요소의 인덱스 번호. 0부터 시작하는 정수. 패널이 없으면 `null`을 반환한다.</ko>\n\t * @see eg.Flicking#getIndex\n\t * @see eg.Flicking#getPrevIndex\n\t */\n\tgetNextIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[0], false, physical);\n\t}\n\n\t/**\n\t * Returns a reference to all panel elements.\n\t * @ko 모든 패널 요소의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getAllElements\n\t * @return {HTMLElement[]} Whole panel elements.<ko>모든 패널 요소.</ko>\n\t */\n\tgetAllElements() {\n\t\treturn this._conf.panel.$list;\n\t}\n\n\t/**\n\t * Returns the reference of the previous panel element.\n\t * @ko 이전 패널 요소의 레퍼런스를 반환한다.\n\t * @method eg.Flicking#getPrevElement\n\t * @return {HTMLElement|null} Previous panel element or `null` if it does not exist.<ko>이전 패널 요소. 패널이 없으면 `null`을 반환한다.</ko>\n\t * @see eg.Flicking#getElement\n\t * @see eg.Flicking#getNextElement\n\t */\n\tgetPrevElement() {\n\t\treturn this._getElement(this._conf.dirData[1], true);\n\t}\n\n\t/**\n\t * Returns the index number of the previous panel element.\n\t * @ko 이전 패널 요소의 인덱스 번호를 반환한다.\n\t * @method eg.Flicking#getPrevIndex\n\t * @param {Boolean} [physical=false] @deprecated since 2.2.0<br><br>Types of index numbers<br>- true (Physical): Minus one of [getIndex()]{@link eg.Flicking#getIndex} return value.<br>- false (Logical): The value of how the content(innerHTML) of the current panel element is in the defined order of the panel elements.<ko>@deprecated since 2.2.0<br><br>인덱스 번호의 종류<br>- true (물리적): [getIndex()]{@link eg.Flicking#getIndex} 반환값에 1을 뺀 값.<br>- false (논리적): 이전 패널 요소의 컨텐트(innerHTML)가 '패널 요소들의 정의된 순서'에서 몇 번째인지에 대한 값.</ko>\n\t * @return {Number|null} Previous element index value or null if no more element exist. A zero-based integer.<ko>이전 패널 요소의 인덱스 번호. 0부터 시작하는 정수. 패널이 없는 경우는 `null`.</ko>\n\t * @see eg.Flicking#getIndex\n\t * @see eg.Flicking#getNextIndex\n\t */\n\tgetPrevIndex(physical) {\n\t\treturn this._getElement(this._conf.dirData[1], false, physical);\n\t}\n\n\t/**\n\t * Checks whether the animated panel is playing.\n\t * @ko 패널 이동 애니메이션이 진행 중인지 확인한다.\n\t * @method eg.Flicking#isPlaying\n\t * @return {Boolean} Indicates whether the animated panel is playing <ko>패널 이동 애니메이션 진행 중 여부</ko>\n\t */\n\tisPlaying() {\n\t\treturn this._conf.panel.animating;\n\t}\n\n\t/**\n\t * Move panel to the given direction\n\t * @private\n\t * @param {Boolean} next\n\t * @param {Number} duration\n\t */\n\t_movePanel(next, duration) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst options = this.options;\n\n\t\tif (panel.animating || conf.touch.holding) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._setValueToMove(next);\n\n\t\tif (options.circular ||\n\t\t\tthis[`get${next ? \"Next\" : \"Prev\"}Index`]() !== null\n\t\t) {\n\t\t\tthis._movePanelByPhase(\"setBy\", panel.size * (next ? 1 : -1), duration);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Move panel applying start/end phase value\n\t * @private\n\t * @param {String} method Axes' method name\n\t * @param {Number} to destination value\n\t * @param {Number} durationValue duration value\n\t */\n\t_movePanelByPhase(method, to, durationValue) {\n\t\tconst duration = utils.getNumValue(durationValue, this.options.duration);\n\n\t\tif (this._setPhaseValue(\"start\") !== false) {\n\t\t\tthis._setAxes(method, to, duration);\n\t\t\t!duration && this._setPhaseValue(\"end\");\n\t\t}\n\t}\n\n\t/**\n\t * Moves an element to the next panel. If `horizontal=true`is right panel. If `horizontal=false`is lower panel.\n\t * @ko 다음 패널로 이동한다. `horizontal=true`이면 우측 패널. `horizontal=false`이면 하측 패널.\n\t * @method eg.Flicking#next\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t * @fires eg.Flicking#beforeFlickStart\n\t * @fires eg.Flicking#flick\n\t * @fires eg.Flicking#flickEnd\n\t * @see eg.Flicking#moveTo\n\t * @see eg.Flicking#prev\n\t */\n\tnext(duration) {\n\t\treturn this._movePanel(true, duration);\n\t}\n\n\t/**\n\t * Moves an element to the previous panel. If `horizontal=true`is left panel. If `horizontal=false`is upper panel.\n\t * @ko 이전 패널로 이동한다. `horizontal=true`이면 좌측 패널. `horizontal=false`이면 상측 패널.\n\t * @method eg.Flicking#prev\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @fires eg.Flicking#beforeFlickStart\n\t * @fires eg.Flicking#flick\n\t * @fires eg.Flicking#flickEnd\n\t * @see eg.Flicking#moveTo\n\t * @see eg.Flicking#next\n\t */\n\tprev(duration) {\n\t\treturn this._movePanel(false, duration);\n\t}\n\n\t/**\n\t * Moves to the panel in the order specified in `noValue`. If noValue is equal to the current logical index numbering, no action is taken. [beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart}, [flick]{@link eg.Flicking#event:flick}, [flickEnd]{@link eg.Flicking#event:flickEnd} events occur one after the other.\n\t * @ko `noValue`에 지정한 순서의 패널로 이동한다. `noValue`값이 현재의 논리적 인덱스 번호와 같다면 아무동작 하지 않는다. [beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart}, [flick]{@link eg.Flicking#event:flick}, [flickEnd]{@link eg.Flicking#event:flickEnd} 이벤트가 차례로 발생한다.\n\t * @method eg.Flicking#moveTo\n\t * @param {Number} noValue The logical index number of the panel element to be moved. (Based on the defined order of the panel elements.)<ko>이동할 패널 요소의 논리적 인덱스 번호. ([getIndex()]{@link eg.Flicking#getIndex}메서드 참조.)</ko>\n\t * @param {Number} [duration=options.duration] Duration of the panel movement (unit: ms) <ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @fires eg.Flicking#beforeFlickStart\n\t * @fires eg.Flicking#flick\n\t * @fires eg.Flicking#flickEnd\n\t * @see eg.Flicking#prev\n\t * @see eg.Flicking#next\n\t */\n\tmoveTo(noValue, duration) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst circular = this.options.circular;\n\t\tconst currentIndex = panel.index;\n\t\tlet indexToMove;\n\t\tlet isPositive;\n\t\tlet no = noValue;\n\n\t\tno = utils.getNumValue(no, -1);\n\n\t\tif (no < 0 || no >= panel.origCount || no === panel.no ||\n\t\t\tpanel.animating || conf.touch.holding) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindexToMove = no - (circular ? panel.no : currentIndex);\n\t\tisPositive = indexToMove > 0;\n\n\t\t// check for real panel count which can be moved on each sides in circular mode\n\t\tif (circular &&\n\t\t\tMath.abs(indexToMove) >\n\t\t\t(isPositive ? panel.count - (currentIndex + 1) : currentIndex)) {\n\t\t\tindexToMove += (isPositive ? -1 : 1) * panel.count;\n\t\t\tisPositive = indexToMove > 0;\n\t\t}\n\n\t\tthis._setPanelNo(circular ? {no} : {no, index: no});\n\t\tthis._conf.indexToMove = indexToMove;\n\t\tthis._setValueToMove(isPositive);\n\n\t\tthis._movePanelByPhase(\n\t\t\tcircular ? \"setBy\" : \"setTo\",\n\t\t\tpanel.size * (circular ? indexToMove : no),\n\t\t\tduration\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * The horizontal or vertical length of the panel is updated according to the base element. If `horizontal=true` is horizontal. If `horizontal=false` is vertical.\n\t * @ko 패널의 가로 혹은 세로 길이를 기준요소에 맞춰 갱신한다. `horizontal=true`이면 가로, `horizontal=false`이면 세로.\n\t * @method eg.Flicking#resize\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @example\n\t * const flick = new eg.Flicking(\"#flick\", {\n\t * \tpreviewPadding: [10, 10]\n\t * });\n\t *\n\t * // When device orientaion changes.\n\t * // 단말기를 회전했을 때.\n\t * flick.resize();\n\t *\n\t * // Or when changes previewPadding option from its original value.\n\t * // 또는 previewPadding옵션값을 변경했을 때.\n\t * flick.options.previewPadding = [20, 30];\n\t * flick.resize();\n\t */\n\tresize() {\n\t\tconst conf = this._conf;\n\t\tconst options = this.options;\n\t\tconst panel = conf.panel;\n\t\tconst horizontal = options.horizontal;\n\t\tconst useTranslate = options.useTranslate;\n\t\tlet panelSize;\n\n\t\tif (!this.isPlaying()) {\n\t\t\tif (utils.isArray(options.previewPadding) && typeof(+options.previewPadding.join(\"\")) === \"number\") {\n\t\t\t\tthis._setPadding(options.previewPadding.concat());\n\t\t\t\tpanelSize = panel.size;\n\t\t\t} else if (horizontal) {\n\t\t\t\tpanelSize = panel.size = utils.css(this.$wrapper, \"width\", true);\n\t\t\t}\n\n\t\t\t// resize panel elements\n\t\t\tutils.css(panel.$list, {\n\t\t\t\t[horizontal ? \"width\" : \"height\"]: utils.getUnitValue(panelSize)\n\t\t\t});\n\n\t\t\t// remove data-height attribute and re-evaluate panel's height\n\t\t\tif (options.adaptiveHeight) {\n\t\t\t\tconst $panel = this.$container.querySelectorAll(`[${DATA_HEIGHT}]`);\n\n\t\t\t\tif ($panel.length) {\n\t\t\t\t\tutils.toArray($panel)\n\t\t\t\t\t\t.forEach(v => v.removeAttribute(DATA_HEIGHT));\n\n\t\t\t\t\tthis._setAdaptiveHeight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._axesInst.axis.flick.range = [0, panelSize * (panel.count - 1)];\n\t\t\tthis._setAxes(\"setTo\", panelSize * panel.index, 0);\n\n\t\t\tif (!useTranslate) {\n\t\t\t\tthis._applyPanelsPos();\n\t\t\t\tthis._adjustContainerCss(\"end\");\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the panel to its original position. (It only works when the default behavior of the [beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart} event is canceled.) [beforeRestore]{@link eg.Flicking#event:beforeRestore}, [flick]{@link eg.Flicking#event:flick}, [restore]{@link eg.Flicking#event:restore} events are occur in order.\n\t * @ko 패널의 위치를 원래 자리로 되돌린다. ([beforeFlickStart]{@link eg.Flicking#event:beforeFlickStart} 이벤트의 기본동작을 취소한 경우에만 동작함.) [beforeRestore]{@link eg.Flicking#event:beforeRestore}, [flick]{@link eg.Flicking#event:flick}, [restore]{@link eg.Flicking#event:restore} 이벤트가 차례로 발생한다.\n\t * @method eg.Flicking#restore\n\t * @param {Number} [durationValue=options.duration] Duration of the panel movement (unit: ms)<ko>패널 이동 애니메이션 진행 시간(단위: ms)</ko>\n\t * @return {eg.Flicking} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n\t * @fires eg.Flicking#event:beforeRestore\n\t * @fires eg.Flicking#event:flick\n\t * @fires eg.Flicking#event:restore\n\t * @example\n\t * new eg.Flicking(\"#flick\").on(\"beforeFlickStart\", e => {\n\t * \tif (e.no === 2) {\n\t * \t\t// Cancels the default behavior of the 'beforeFlickStart' event.\n\t * \t\t// 'beforeFlickStart' 이벤트 기본동작 취소.\n\t * \t\te.stop();\n\t *\n\t * \t\t// Return to original position.\n\t * \t\t// 원래 자리로 되돌림.\n\t * \t\tthis.restore(100);\n\t * \t}\n\t * });\n\t */\n\trestore(durationValue) {\n\t\tconst conf = this._conf;\n\t\tconst panel = conf.panel;\n\t\tconst currPos = this._axesInst.get().flick;\n\t\tlet duration = durationValue;\n\t\tlet destPos;\n\n\t\t// check if the panel isn't in right position\n\t\tif (currPos !== panel.currIndex * panel.size) {\n\t\t\tconf.customEvent.restoreCall = true;\n\t\t\tduration = utils.getNumValue(duration, this.options.duration);\n\n\t\t\tthis._revertPanelNo();\n\t\t\tdestPos = panel.size * panel.index;\n\n\t\t\tthis._triggerBeforeRestore({depaPos: currPos, destPos});\n\t\t\tthis._setAxes(\"setTo\", destPos, duration);\n\n\t\t\tif (!duration) {\n\t\t\t\tthis._adjustContainerCss(\"end\");\n\t\t\t\tthis._triggerRestore();\n\t\t\t}\n\n\t\t\t// to handle on api call\n\t\t} else if (panel.changed) {\n\t\t\tthis._revertPanelNo();\n\t\t\tconf.touch.distance = conf.indexToMove = 0;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * The input from the input device is not blocked so that the panel can be moved by the input device.\n\t * @ko 막았던 입력 장치로부터의 입력을 푼다.\n\t * @method eg.Flicking#enableInput\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t * @see eg.Flicking#disableInput\n\t */\n\tenableInput() {\n\t\tthis._panInput.enable();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The input from the input device is blocked so that the panel is not moved by the input device.\n\t * @ko 패널이 입력 장치에 의해 움직이지 않도록 입력 장치로부터의 입력을 막는다.\n\t * @method eg.Flicking#disableInput\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t * @see eg.Flicking#enableInput\n\t */\n\tdisableInput() {\n\t\tthis._panInput.disable();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get current flicking status. If the returned value is specified as a [setStatus()]{@link eg.Flicking#setStatus} method argument, it can be returned to its value state.\n\t * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메서드 인자로 지정하면 그 값 상태로 되돌릴 수 있다.\n\t * @method eg.Flicking#getStatus\n\t * @param {Boolean} [stringify] Set true if want get stringified status value.<ko>true 지정시 json문자열 형태로 반환한다.</ko>\n\t * @return {Status|String} An object with current state value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n\t * @see eg.Flicking#setStatus\n\t * @example\n\t * const flick = new eg.Flicking(\"#flick\");\n\t * const status = flick.getStatus();\n\t * const jsonStaus = flick.getStatus(true);\n\t *\n\t * console.log(status); // {panel: {...}, $list: Array(7)}\n\t * console.log(jsonStatus); // \"{\\\"panel\\\":{\\\"index\\\":3,\\\"no\\\":6,\\\"currIndex\\\":3,\\\"currNo\\\":6},\\\"$list\\\":[{\\\"style\\\":\\\"background-color: rgb(155, 49, 137); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 3&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"},{\\\"style\\\":\\\"background-color: rgb(51, 172, 91); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 4&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"},{\\\"style\\\":\\\"background-color: rgb(116, 38, 241); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 5&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"},{\\\"style\\\":\\\"background-color: rgb(141, 139, 24); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 6&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"},{\\\"style\\\":\\\"background-color: rgb(204, 102, 204); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 0&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"},{\\\"style\\\":\\\"background-color: rgb(54, 53, 156); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 1&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"},{\\\"style\\\":\\\"background-color: rgb(196, 218, 72); position: absolute;  height: 100%;\\\",\\\"className\\\":\\\"eg-flick-panel\\\",\\\"html\\\":\\\"\\n\\t\\t\\t\\t\\t\\t\\t\\t&lt;p&gt;panel 2&lt;/p&gt;\\n\\t\\t\\t\\t\\t\\t\\\"}]}\"\n\t */\n\t/**\n\t * The return value specification of the getStatus () method.\n\t * @ko getStatus() 메서드의 반환값 명세.\n\t * @typedef {Object} Status\n\t * @property {Object} panel current panel position<ko>현재 패널 위치</ko>\n\t * @property {Number} panel.index Physical index number.<ko>물리적 인덱스 번호.</ko>\n\t * @property {Number} panel.currIndex Current physical index number.<ko>현재 물리적 인덱스 번호.</ko>\n\t * @property {Number} panel.no Logical index number.<ko>논리적 인덱스 번호.</ko>\n\t * @property {Number} panel.currNo Current logical index number.<ko>현재 논리적 인덱스 번호.</ko>\n\t * @property {Array.<{style: String, className: String, html: String}>} $list panel's html<ko>패널 정보</ko>\n\t * @property {Object} $list.obj For convenience, the element is denoted by obj.<ko>편의상 원소를 obj로 표기함</ko>\n\t * @property {String} $list.obj.style The value of the style attribute of the panel element. ('transform', 'left', 'top', 'will-change', 'box-sizing', 'width' style has been deleted.)<ko>패널 요소의 style 속성 값. ('transform', 'left', 'top', 'will-change', 'box-sizing', 'width' style은 삭제됨)</ko>\n\t * @property {String} $list.obj.className The class name of the panel element.<ko>패널 요소의 class 이름.</ko>\n\t * @property {String} $list.obj.html The innerHTML value of the panel element.<ko>패널 요소의 innerHTML 값.</ko>\n\t * @see eg.Flicking#getIndex\n\t */\n\tgetStatus(stringify) {\n\t\tconst panel = this._conf.panel;\n\t\tconst rxStyle = /((?:-webkit-)?transform|left|top|will-change|box-sizing|width):[^;]*;/g;\n\t\tconst status = {\n\t\t\t// current panel position\n\t\t\tpanel: {\n\t\t\t\tindex: panel.index,\n\t\t\t\tno: panel.no,\n\t\t\t\tcurrIndex: panel.currIndex,\n\t\t\t\tcurrNo: panel.currNo\n\t\t\t},\n\n\t\t\t// panel's html\n\t\t\t$list: panel.$list.map(v => ({\n\t\t\t\tstyle: v.style.cssText.replace(rxStyle, \"\").trim(),\n\t\t\t\tclassName: v.className,\n\t\t\t\thtml: v.innerHTML\n\t\t\t}))\n\t\t};\n\n\t\treturn stringify ?\n\t\t\tJSON.stringify(status) : status;\n\t}\n\n\t/**\n\t * Restore to the state of the `statusValue`.\n\t * @ko `statusValue`의 상태로 복원한다.\n\t * @method eg.Flicking#setStatus\n\t * @param {Status|String} statusValue Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드 반환값을 지정하면 된다.</ko>\n\t * @see eg.Flicking#getStatus\n\t * @example\n\t * const flick = new eg.Flicking(\"#flick\");\n\t * const status = flick.getStatus();\n\t *\n\t * // Move to arbitrary panel.\n\t * // 임의 패널로 이동\n\t * flick.moveTo(2);\n\t *\n\t * // Restore to status.\n\t * // status 상태로 복원\n\t * flick.setStatus(status);\n\t */\n\tsetStatus(statusValue) {\n\t\tconst panel = this._conf.panel;\n\t\tconst isAdaptiveHeight = this.options.adaptiveHeight;\n\t\tconst status = typeof statusValue === \"string\" ?\n\t\t\tJSON.parse(statusValue) : statusValue;\n\n\t\tif (status) {\n\t\t\tfor (const x in status.panel) {\n\t\t\t\tx in panel && (panel[x] = status.panel[x]);\n\t\t\t}\n\n\t\t\tpanel.$list.forEach((v, i) => {\n\t\t\t\tconst data = status.$list[i];\n\t\t\t\tconst style = data.style;\n\t\t\t\tconst className = data.className;\n\t\t\t\tconst html = data.html;\n\n\t\t\t\tstyle && (v.style.cssText += style);\n\t\t\t\tclassName && (v.className = className);\n\t\t\t\thtml && (v.innerHTML = html);\n\t\t\t});\n\n\t\t\tisAdaptiveHeight && this._setAdaptiveHeight();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the reference element and its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).<br>If plugin isn't empty, also reset all plugins registered.\n\t * @ko 기준 요소와 그 하위 요소를 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.<br>플러그인이 비어있지 않다면, 플러그인도 모두 리셋한다.\n\t * @method eg.Flicking#destroy\n\t * @example\n\t * const flick = new eg.Flicking(\"#flick\");\n\t * flick.destroy();\n\t * console.log(flick.moveTo); // null\n\t */\n\tdestroy() {\n\t\tconst conf = this._conf;\n\t\tconst origPanelStyle = conf.origPanelStyle;\n\t\tconst wrapper = origPanelStyle.wrapper;\n\t\tconst container = origPanelStyle.container;\n\t\tconst list = origPanelStyle.list;\n\n\t\t// unbind events\n\t\tthis._bindEvents(false);\n\t\tthis.off();\n\n\t\t// destroy eg.Axes instance\n\t\tthis._axesInst.destroy();\n\t\tthis._panInput.destroy();\n\n\t\t// unwrap container element and restore original inline style\n\t\t// restore wrapper style\n\t\tconst $wrapper = this.$wrapper;\n\n\t\t$wrapper.setAttribute(\"class\", wrapper.className);\n\t\t$wrapper[wrapper.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", wrapper.style);\n\n\t\t// restore container style\n\t\tconst $container = this.$container;\n\t\tconst $children = []\n\t\t\t.slice.call($container.children);\n\n\t\tif (origPanelStyle.container.className) {\n\t\t\t$container.setAttribute(\"class\", container.className);\n\t\t\t$container[container.style ? \"setAttribute\" : \"removeAttribute\"](\"style\", container.style);\n\t\t} else {\n\t\t\t$children.forEach(v => $wrapper.appendChild(v));\n\t\t\t$container.parentNode.removeChild($container);\n\t\t}\n\n\t\tfor (let i = 0, $el; ($el = $children[i]); i++) {\n\t\t\tif (i > list.length - 1) {\n\t\t\t\t$el.parentNode.removeChild($el);\n\t\t\t} else {\n\t\t\t\tconst className = list[i].className;\n\t\t\t\tconst style = list[i].style;\n\n\t\t\t\t$el[className ? \"setAttribute\" : \"removeAttribute\"](\"class\", className);\n\t\t\t\t$el[style ? \"setAttribute\" : \"removeAttribute\"](\"style\", style);\n\t\t\t}\n\t\t}\n\n\t\t// release plugin resources\n\t\tthis.plugins.forEach(v => {\n\t\t\tthis.plugins[v].$componentWillUnmount();\n\t\t});\n\n\t\t// release resources\n\t\tfor (const x in this) {\n\t\t\tthis[x] = null;\n\t\t}\n\t}\n\n\t/**\n\t * Register plugin to be used.\n\t * @ko 사용될 플러그인을 등록한다.\n\t * @method eg.Flicking#plugin\n\t * @example\n\t * new eg.Flicking(\"#flick\").plugin([\n\t *     new eg.Flicking.plugin.OpacityEffect(\"span\"),\n\t *     ...\n\t * ]);\n\t * @return {eg.Flicking} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>\n\t */\n\tplugin(list) {\n\t\tlist.forEach(p => {\n\t\t\t/**\n\t\t\t * A list of plugins used.\n\t\t\t * @ko 사용된 플러그인 목록\n\t\t\t * @property {Array} plugins An array of plugin instances <ko>플러그인 인스턴스 배열</ko>\n\t\t\t * @name plugins\n\t\t\t * @type {Array}\n\t\t\t * @instance\n\t\t\t * @example\n\t\t\t * const flick = new eg.Flicking( ... ).plugin([ ... ]);\n\t\t\t *\n\t\t\t * flick.plugins; // [ ... ] - array of plugins\n\t\t\t * @memberof eg.Flicking\n\t\t\t */\n\t\t\tif (this.plugins.filter(v => v.constructor === p.constructor).length === 0) {\n\t\t\t\tthis.plugins.push(p.$componentWillMount(this));\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Collection of utilities used internally\n\t * @ko 내부에서 사용되는 유틸리티 모음\n\t * @name utils\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @private\n\t * @type {Object}\n\t */\n\tstatic utils = utils;\n\t/**\n\t * Version info string\n\t * @ko 버전정보 문자열\n\t * @name VERSION\n\t * @static\n\t * @type {String}\n\t * @example\n\t * eg.Flicking.VERSION;  // ex) 2.2.0\n\t * @memberof eg.Flicking\n\t */\n\tstatic VERSION = \"#__VERSION__#\";\n\t/**\n\t * Constant value used internally\n\t * @ko 내부에서 사용되는 상수 값\n\t * @name consts\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @private\n\t * @type {Object}\n\t */\n\tstatic consts = {\n\t\tEVENTS,\n\t\tTRANSFORM,\n\t\tSUPPORT_WILLCHANGE,\n\t\tIS_ANDROID2\n\t};\n\n\t/**\n\t * Constant value for none direction.\n\t * @ko none 방향에 대한 상수 값.\n\t * @name DIRECTION_NONE\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 1\n\t */\n\tstatic DIRECTION_NONE = Axes.DIRECTION_NONE;\n\n\t/**\n\t * Constant value for left direction.\n\t * @ko left 방향에 대한 상수 값.\n\t * @name DIRECTION_LEFT\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 2\n\t */\n\tstatic DIRECTION_LEFT = Axes.DIRECTION_LEFT;\n\n\t/**\n\t * Constant value for right direction.\n\t * @ko right 방향에 대한 상수 값.\n\t * @name DIRECTION_RIGHT\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 4\n\t */\n\tstatic DIRECTION_RIGHT = Axes.DIRECTION_RIGHT;\n\n\t/**\n\t * Constant value for up direction.\n\t * @ko up 방향에 대한 상수 값.\n\t * @name DIRECTION_UP\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 8\n\t */\n\tstatic DIRECTION_UP = Axes.DIRECTION_UP;\n\n\t/**\n\t * Constant value for down direction.\n\t * @ko down 방향에 대한 상수 값.\n\t * @name DIRECTION_DOWN\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 16\n\t */\n\tstatic DIRECTION_DOWN = Axes.DIRECTION_DOWN;\n\n\t/**\n\t * Constant value for horizontal direction.\n\t * @ko horizontal 방향에 대한 상수 값.\n\t * @name DIRECTION_HORIZONTAL\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 6\n\t */\n\tstatic DIRECTION_HORIZONTAL = Axes.DIRECTION_HORIZONTAL;\n\n\t/**\n\t * Constant value for vertical direction.\n\t * @ko vertical 방향에 대한 상수 값.\n\t * @name DIRECTION_VERTICAL\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 24\n\t */\n\tstatic DIRECTION_VERTICAL = Axes.DIRECTION_VERTICAL;\n\n\t/**\n\t * Constant value for all direction.\n\t * @ko all 방향에 대한 상수 값.\n\t * @name DIRECTION_ALL\n\t * @memberof eg.Flicking\n\t * @static\n\t * @constant\n\t * @type {Number}\n\t * @default 30\n\t */\n\tstatic DIRECTION_ALL = Axes.DIRECTION_ALL;\n}\n"],"names":["style","win","window","Math","self","Function","document","utils","$","param","el","match","createElement","length","split","forEach","v","attr","setAttribute","trim","replace","querySelectorAll","nodeName","nodeType","toArray","slice","call","isArray","arr","constructor","Array","isObject","obj","this","extend","target","objectN","source","shift","Object","keys","key","value","_this","concat","css","getAsNumber","test","getComputedStyle","getNumValue","applyStyle","classList","className","add","res","isAddParam","indexOf","RegExp","val","defVal","num","isNaN","parseFloat","getUnitValue","String","getOuter","type","paddingMargin","dir","_this2","toLocaleLowerCase","outerWidth","outerHeight","translate","x","y","isHA","hasClickBug","ua","navigator","userAgent","result","MixinBuilder","superclass","mixins","reduce","c","m","EVENTS","beforeFlickStart","beforeRestore","flick","flickEnd","restore","TRANSFORM","name","support","doc","documentElement","SUPPORT_WILLCHANGE","global","CSS","supports","IS_ANDROID2","DATA_HEIGHT","CONFIG","panel","$list","index","no","currIndex","currNo","size","count","origCount","changed","animating","minCount","touch","holdPos","destPos","distance","direction","lastPos","holding","isTrusted","customEvent","restoreCall","dirData","indexToMove","$dummyAnchor","OPTIONS","hwAccelerable","prefix","deceleration","horizontal","circular","previewPadding","bounce","threshold","duration","panelEffect","pow","defaultIndex","inputType","thresholdAngle","adaptiveHeight","zIndex","useTranslate","_holdHandler","e","conf","_conf","pos","_adjustContainerCss","_changeHandler","movedPx","eventRes","_setPointerEvents","inputEvent","options","abs","_triggerEvent","_setTranslate","_releaseHandler","panelSize","isPlusMove","depaPos","moveTo","_isMovable","_triggerBeforeRestore","setTo","_animationStartHandler","isFromInput","_setPhaseValue","stop","_animationEndHandler","_triggerRestore","Flicking","element","_prefix","$wrapper","plugins","$children","children","Error","_setOptions","_setConfig","_build","_bindEvents","_applyPanelsCss","_arrangePanels","_setHint","_setAdaptiveHeight","arrVal","padding","$nodes","$container","origPanelStyle","wrapper","getAttribute","container","list","map","useLayerHack","eventPrefix","push","Axes","panelCount","_setPadding","sizeValue","_getDataByDirection","cssValue","position","width","height","top","$parent","parentNode","appendChild","boxSizing","left","_addClonePanels","_axesInst","range","easing","interruptable","_setDefaultPanel","build","a","reverse","join","overflow","paddingType","wrapperSize","max","cloneNodes","cloneCount","cloneNode","_movePanelPosition","append","listToMove","splice","coords","baseIndex","lastIndex","_getBasePositionIndex","_setPanelNo","_setAxes","sort","_arrangePanelPosition","_applyPanelsPos","bind","_setMoveStyle","$el","coordsValue","transform","$element","dummyAnchorClassName","i","phase","toValue","paddingTop","to","_getCoordsValue","focus","method","willChange","data","next","floor","axesInst","_panInput","PanInput","scale","on","hold","change","release","animationStart","animationEnd","connect","disableInput","off","$panel","DIRECTION_LEFT","DIRECTION_RIGHT","$first","querySelector","_getNumByDirection","_revertPanelNo","pointerEvents","pointer","preventSystemEvent","currPos","isMovable","axis","get","trigger","eventType","_getElement","physical","total","currentIndex","_setValueToMove","getIndex","getElement","getNextElement","getNextIndex","getAllElements","getPrevElement","getPrevIndex","isPlaying","_movePanel","_movePanelByPhase","durationValue","prev","noValue","isPositive","resize","removeAttribute","enableInput","enable","disable","getStatus","stringify","rxStyle","status","cssText","html","innerHTML","JSON","setStatus","statusValue","isAdaptiveHeight","parse","destroy","removeChild","_this3","$componentWillUnmount","plugin","p","_this4","filter","$componentWillMount","Component","eventHandler","VERSION","consts","DIRECTION_NONE","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL"],"mappings":"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"}