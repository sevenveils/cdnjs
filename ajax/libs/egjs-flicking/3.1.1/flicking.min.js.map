{"version":3,"file":"flicking.min.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/moves/Snap.ts","../src/moves/MoveType.ts","../src/moves/FreeScroll.ts","../src/components/Viewport.ts","../src/Flicking.ts","../src/index.umd.ts"],"sourcesContent":["/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { ElementLike, OriginalStyle } from \"./types\";\nimport Flicking from \"./Flicking\";\nimport { FLICKING_METHODS } from \"./consts\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n\n// Circulate number between range [min, max]\n/*\n * \"indexed\" means min and max is not same, so if it's true \"min - 1\" should be max\n * While if it's false, \"min - 1\" should be \"max - 1\"\n * use `indexed: true` when it should be used for circulating integers like index\n * or `indexed: false` when it should be used for something like positions.\n */\nexport function circulate(value: number, min: number, max: number, indexed: boolean): number {\n  const size = indexed\n    ? max - min + 1\n    : max - min;\n  if (value < min) {\n    const offset = indexed\n      ? (min - value - 1) % size\n      : (min - value) % size;\n    value = max - offset;\n  } else if (value > max) {\n    const offset = indexed\n      ? (value - max - 1) % size\n      : (value - max) % size;\n    value = min + offset;\n  }\n\n  return value;\n}\n\nexport function hasClass(element: HTMLElement | null, className: string): boolean {\n  if (!element) {\n    return false;\n  }\n\n  const classes = classList(element);\n\n  return findIndex(classes, name => name === className) > -1;\n}\n\nexport function restoreStyle(element: HTMLElement, originalStyle: OriginalStyle): void {\n  originalStyle.className\n    ? element.setAttribute(\"class\", originalStyle.className)\n    : element.removeAttribute(\"class\");\n  originalStyle.style\n    ? element.setAttribute(\"style\", originalStyle.style)\n    : element.removeAttribute(\"style\");\n}\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nexport function withFlickingMethods(prototype: any, flickingName: string) {\n\n  Object.keys(FLICKING_METHODS).forEach((name: keyof Flicking) => {\n    if (prototype[name]) {\n      return;\n    }\n    prototype[name] = function(...args) {\n      const result = this[flickingName][name](...args);\n\n      // fix `this` type to return your own `flicking` instance to the instance using the decorator.\n      if (result === this[flickingName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption, FlickingMethodsKeys } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const MOVE_TYPE: {\n  SNAP: \"snap\";\n  FREE_SCROLL: \"freeScroll\";\n} = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n};\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\n\n/**\n * Default options for creating Flicking.\n * @ko 플리킹을 만들 때 사용하는 기본 옵션들\n * @private\n * @memberof eg.Flicking\n */\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n  renderExternal: false,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\nexport const FLICKING_METHODS: {[key in FlickingMethodsKeys]: true} = {\n  prev: true,\n  next: true,\n  moveTo: true,\n  getIndex: true,\n  getAllPanels: true,\n  getCurrentPanel: true,\n  getElement: true,\n  getPanel: true,\n  getPanelCount: true,\n  getStatus: true,\n  getVisiblePanels: true,\n  setLastIndex: true,\n  enableInput: true,\n  disableInput: true,\n  destroy: true,\n  resize: true,\n  setStatus: true,\n  addPlugins: true,\n  removePlugins: true,\n  isPlaying: true,\n  getLastIndex: true,\n};\nexport const TRANSFORM = checkTranslateSupport();\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Viewport from \"./Viewport\";\nimport { OriginalStyle, FlickingPanel, ElementLike } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, parseElement, getProgress, restoreStyle } from \"../utils\";\n\nclass Panel implements FlickingPanel {\n  public viewport: Viewport;\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  protected state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    isVirtual: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    cachedBbox: ClientRect | null;\n  };\n  private element: HTMLElement;\n  private original?: Panel;\n  private clonedPanels: Panel[];\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    viewport: Viewport,\n  ) {\n    this.viewport = viewport;\n    this.prevSibling = null;\n    this.nextSibling = null;\n    this.clonedPanels = [];\n\n    this.state = {\n      index,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      isClone: false,\n      isVirtual: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\"),\n        style: element.getAttribute(\"style\"),\n      },\n      cachedBbox: null,\n    };\n\n    this.setElement(element);\n  }\n\n  public resize(): void {\n    const state = this.state;\n    const options = this.viewport.options;\n    const bbox = this.getBbox();\n\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n    state.relativeAnchorPosition = parseArithmeticExpression(options.anchor, state.size);\n\n    if (!state.isClone) {\n      this.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public unCacheBbox(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public getProgress() {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const panelCount = viewport.panelManager.getPanelCount();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n\n    const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n    const progress = relativeIndex - viewport.getCurrentProgress();\n\n    return progress;\n  }\n\n  public getOutsetProgress() {\n    const viewport = this.viewport;\n    const outsetRange = [\n      -this.getSize(),\n      viewport.getRelativeHangerPosition() - this.getRelativeAnchorPosition(),\n      viewport.getSize(),\n    ];\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    return outsetProgress;\n  }\n\n  public getVisibleRatio() {\n    const viewport = this.viewport;\n    const panelSize = this.getSize();\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const rightRelativePanelPosition = relativePanelPosition + panelSize;\n\n    const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0\n      ? visibleSize / panelSize\n      : 0;\n\n    return visibleRatio;\n  }\n\n  public focus(duration?: number): void {\n    const viewport = this.viewport;\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getHangerPosition();\n    const anchorPosition = this.getAnchorPosition();\n    if (hangerPosition === anchorPosition || !currentPanel) {\n      return;\n    }\n\n    const currentPosition = currentPanel.getPosition();\n    const eventType = currentPosition === this.getPosition()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(this, viewport.findEstimatedPosition(this), eventType, null, duration);\n  }\n\n  public update(updateFunction: (element: HTMLElement) => any): void {\n    this.getIdenticalPanels()\n      .forEach(eachPanel => {\n        updateFunction(eachPanel.getElement());\n        eachPanel.unCacheBbox();\n      });\n    this.viewport.resize();\n  }\n\n  public prev(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const prevSibling = this.prevSibling;\n\n    if (!prevSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const prevPanelIndex = prevSibling.getIndex();\n    const prevPanelPosition = prevSibling.getPosition();\n    const prevPanelSize = prevSibling.getSize();\n\n    const hasEmptyPanelBetween = currentIndex - prevPanelIndex > 1;\n    const notYetMinPanel = options.infinite\n      && currentIndex > 0\n      && prevPanelIndex > currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMinPanel) {\n      // Empty panel exists between\n      return null;\n    }\n\n    const newPosition = currentPosition - prevPanelSize - options.gap;\n\n    let prevPanel = prevSibling;\n    if (prevPanelPosition !== newPosition) {\n      prevPanel = prevSibling.clone(prevSibling.getCloneIndex(), true);\n      prevPanel.setPosition(newPosition);\n    }\n\n    return prevPanel;\n  }\n\n  public next(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const nextSibling = this.nextSibling;\n    const lastIndex = viewport.panelManager.getLastIndex();\n\n    if (!nextSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const nextPanelIndex = nextSibling.getIndex();\n    const nextPanelPosition = nextSibling.getPosition();\n\n    const hasEmptyPanelBetween = nextPanelIndex - currentIndex > 1;\n    const notYetMaxPanel = options.infinite\n      && currentIndex < lastIndex\n      && nextPanelIndex < currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMaxPanel) {\n      return null;\n    }\n\n    const newPosition = currentPosition + this.getSize() + options.gap;\n\n    let nextPanel = nextSibling;\n    if (nextPanelPosition !== newPosition) {\n      nextPanel = nextSibling.clone(nextSibling.getCloneIndex(), true);\n      nextPanel.setPosition(newPosition);\n    }\n\n    return nextPanel;\n  }\n\n  public insertBefore(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n    const firstPanel = viewport.panelManager.firstPanel()!;\n    const prevSibling = this.prevSibling;\n    // Finding correct inserting index\n    // While it should insert removing empty spaces,\n    // It also should have to be bigger than prevSibling' s index\n    const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n      ? Math.max(prevSibling.getIndex() + 1, this.getIndex() - parsedElements.length)\n      : Math.max(this.getIndex() - parsedElements.length, 0);\n\n    return viewport.insert(targetIndex, parsedElements);\n  }\n\n  public insertAfter(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.insert(this.getIndex() + 1, element);\n  }\n\n  public remove(): FlickingPanel {\n    this.viewport.remove(this.getIndex());\n\n    return this;\n  }\n\n  public destroy(): void {\n    const originalStyle = this.state.originalStyle;\n\n    restoreStyle(this.element, originalStyle);\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox!;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : this.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...this.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number): void {\n    const state = this.state;\n\n    state.index = index;\n    this.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number): this {\n    const state = this.state;\n    const options = this.viewport.options;\n\n    state.position = pos;\n    if (!state.isVirtual) {\n      const elementStyle = this.element.style;\n      options.horizontal\n        ? elementStyle.left = `${pos}px`\n        : elementStyle.top = `${pos}px`;\n    }\n\n    return this;\n  }\n\n  public clone(cloneIndex: number, isVirtual: boolean = false): Panel {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const cloneElement = isVirtual\n      ? this.element\n      : this.element.cloneNode(true) as HTMLElement;\n\n    const clonedPanel = new Panel(cloneElement, state.index, viewport);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = this;\n    clonedState.isClone = true;\n    clonedState.isVirtual = isVirtual;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n\n    if (!isVirtual) {\n      this.clonedPanels.push(clonedPanel);\n    } else {\n      clonedPanel.prevSibling = this.prevSibling;\n      clonedPanel.nextSibling = this.nextSibling;\n    }\n\n    return clonedPanel;\n  }\n\n  // Clone with external element\n  public cloneExternal(cloneIndex: number, element: HTMLElement): Panel {\n    const clonedPanel = this.clone(cloneIndex);\n    clonedPanel.setElement(element);\n\n    return clonedPanel;\n  }\n\n  public removeElement(): void {\n    if (!this.viewport.options.renderExternal) {\n      const element = this.element;\n      element.parentNode!.removeChild(element);\n    }\n\n    // Do the same thing for clones\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const removingPanels = this.clonedPanels.splice(start);\n\n    removingPanels.forEach(panel => {\n      panel.removeElement();\n    });\n  }\n\n  private setElement(element: HTMLElement): void {\n    this.element = element;\n\n    const options = this.viewport.options;\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n  }\n}\n\nexport default Panel;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private options: FlickingOptions;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private cloneCount: number;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.cloneCount = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clones.reduce((allClones, clones) => [...allClones, ...clones], []),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel[]> {\n    return this.clones;\n  }\n\n  public replacePanels(newPanels: Panel[], newClones: Panel[][]): void {\n    this.panels = newPanels;\n    this.clones = newClones;\n\n    this.range = {\n      min: findIndex(newPanels, panel => Boolean(panel)),\n      max: newPanels.length - 1,\n    };\n    this.length = newPanels.filter(panel => Boolean(panel)).length;\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.cloneCount;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      removingPanels.forEach(panel => panel.removeElement());\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n    }\n  }\n\n  public setCloneCount(cloneCount: number): void {\n    this.cloneCount = cloneCount;\n  }\n\n  public append(newPanels: Panel[]): void {\n    const range = this.range;\n    this.panels.push(...newPanels);\n\n    if (newPanels.length > 0) {\n      range.min = Math.max(0, range.min);\n      range.max += newPanels.length;\n      this.length += newPanels.length;\n    }\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        removedPanels.forEach(panel => panel.removeElement());\n        this.length -= removedPanels.length;\n\n        // Find first\n        const newLastIndex = lastIndex - findIndex(this.panels.concat().reverse(), panel => !!panel);\n\n        // Can be filled with empty after newLastIndex\n        this.panels.splice(newLastIndex + 1);\n        this.range.max = newLastIndex;\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): void {\n    const panels = this.panels;\n    const range = this.range;\n    const isCircular = this.options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n    replacedPanels.forEach(panel => {\n      if (panel) {\n        panel.removeElement();\n      }\n    });\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    deletedPanels.forEach(panel => {\n      panel.removeElement();\n    });\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 0) {\n      return;\n    }\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanelsCount - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanelsCount - 1];\n\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  // Clear both original & cloned\n  public clear(): void {\n    this.panels.forEach(panel => {\n      panel.removeElement();\n    });\n\n    this.panels = [];\n    this.clones = [];\n    this.length = 0;\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n  }\n\n  public clearClone(): void {\n    this.panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(0);\n    });\n    this.clones = [];\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels) {\n      if (panel && panel.getIndex() >= index) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        if (!this.options.renderExternal) {\n          cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        }\n\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n\n  private insertNewPanels(newPanels: Panel[], siblingElement: HTMLElement | null) {\n    if (!this.options.renderExternal) {\n      const fragment = document.createDocumentFragment();\n      newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n      this.cameraElement.insertBefore(fragment, siblingElement);\n    }\n  }\n}\n\nexport default PanelManager;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public lastPosition: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.lastPosition = prevState.lastPosition;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.lastPosition = 0;\n  }\n\n  public onHold(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      if (viewport.options.infinite) {\n        viewport.moveCamera(viewport.getCameraPosition(), e);\n      }\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    this.lastPosition = viewport.getCameraPosition();\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: clickedPanel,\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS, MOVE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const moveType = viewport.moveType;\n    const isFreeScroll = moveType.is(MOVE_TYPE.FREE_SCROLL);\n    const inputEvent = e.inputEvent;\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = horizontal\n      ? inputEvent.deltaX\n      : inputEvent.deltaY;\n    const isNextDirection = Math.abs(velocity) > 1\n      ? velocity < 0\n      : Math.abs(delta) > 0\n        ? delta > 0\n        : inputDelta < 0;\n\n    const swipeDistance = Math.max(Math.abs(delta), Math.abs(inputDelta));\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    const targetPanel = this.targetPanel;\n    if (!overThreshold && targetPanel) {\n      // Interrupted while animating\n      const destPos = isFreeScroll\n        ? e.destPos.flick\n        : viewport.findEstimatedPosition(targetPanel);\n      viewport.moveTo(targetPanel, destPos, \"\", e);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    const moveTypeContext = {\n      viewport,\n      axesEvent: e,\n      swipeDistance,\n      isNextDirection,\n    };\n\n    const destInfo = overThreshold\n      ? moveType.findTargetPanel(moveTypeContext)\n      : moveType.findRestorePanel(moveTypeContext);\n\n    viewport.moveTo(\n      destInfo.panel,\n      destInfo.destPos,\n      destInfo.eventType,\n      e,\n      destInfo.duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n}\n\nexport default DraggingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    const options = viewport.options;\n    const scrollArea = viewport.getScrollArea();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const loopCount = Math.floor((this.lastPosition + this.delta - scrollArea.prev) / scrollAreaSize);\n\n    const targetPanel = this.targetPanel;\n    if (options.circular && loopCount !== 0 && targetPanel) {\n      const cloneCount = viewport.panelManager.getCloneCount();\n      const originalTargetPosition = targetPanel.getPosition();\n\n      // cloneIndex is from -1 to cloneCount - 1\n      const newCloneIndex = circulate(targetPanel.getCloneIndex() - loopCount, -1, cloneCount - 1, true);\n      const newTargetPosition = originalTargetPosition - loopCount * scrollAreaSize;\n      const newTargetPanel = targetPanel.getIdenticalPanels()[newCloneIndex + 1].clone(newCloneIndex, true);\n\n      // Set new target panel considering looped count\n      newTargetPanel.setPosition(newTargetPosition);\n      this.targetPanel = newTargetPanel;\n    }\n\n    // Reset last position and delta\n    this.delta = 0;\n    this.lastPosition = viewport.getCameraPosition();\n\n    // Update current panel as current nearest panel\n    viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n\n    viewport.options.bound\n      ? viewport.setCurrentPanel(this.targetPanel!)\n      : viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    transitTo(STATE_TYPE.IDLE);\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted, {\n      direction: this.direction,\n    });\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n  }\n}\n\nexport default AnimatingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(e: any, { viewport, transitTo }: FlickingContext): void {\n    // Can stop Axes's change event\n    e.stop();\n\n    // Should update axes position as it's already changed at this moment\n    viewport.updateAxesPosition(viewport.getCameraPosition());\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport MoveType from \"./MoveType\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { clamp } from \"../utils\";\n\nclass Snap extends MoveType {\n  protected readonly type: string = MOVE_TYPE.SNAP;\n  protected count: number;\n\n  constructor(count: number) {\n    super();\n    this.count = count;\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, axesEvent, swipeDistance } = ctx;\n    const snapCount = this.count;\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const currentPanel = viewport.getCurrentPanel()!;\n    const nearestPanel = viewport.getNearestPanel()!;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n\n    // This can happen when bounce is 0\n    const shouldMoveWhenBounceIs0 = viewport.canSetBoundMode()\n      && (nearestPanel.getIndex() === currentPanel.getIndex());\n    const shouldMoveToAdjacent = !viewport.isOutOfBound()\n      && (swipeDistance <= minimumDistanceToChange || shouldMoveWhenBounceIs0);\n\n    if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n      return this.findSnappedPanel(ctx);\n    } else if (shouldMoveToAdjacent) {\n      return this.findAdjacentPanel(ctx);\n    } else {\n      return {\n        panel: nearestPanel,\n        duration: viewport.options.duration,\n        destPos: viewport.findEstimatedPosition(nearestPanel),\n        eventType: swipeDistance <= minimumDistanceToChange\n          ? EVENTS.RESTORE\n          : EVENTS.CHANGE,\n      };\n    }\n  }\n\n  protected findSnappedPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, isNextDirection } = ctx;\n\n    const snapCount = this.count;\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = axesEvent.destPos.flick + viewport.getRelativeHangerPosition();\n    let panelToMove = viewport.getNearestPanel()!;\n    let cycleIndex = panelToMove.getCloneIndex() + 1; // 0(original) or 1(clone)\n    let passedPanelCount = 0;\n\n    while (passedPanelCount < snapCount) {\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n\n      // Since panlToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      const panelNextPosition = panelPosition + panelSize + halfGap;\n      const panelPrevPosition = panelPosition - halfGap;\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && panelNextPosition > estimatedHangerPos)\n        || (!isNextDirection && panelPrevPosition < estimatedHangerPos)\n      ) {\n        break;\n      }\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n\n    panelToMove = panelToMove.clone(panelToMove.getCloneIndex(), true);\n    panelToMove.setPosition(originalPosition + cycleIndex * scrollAreaSize);\n\n    const defaultDuration = viewport.options.duration;\n    const duration = clamp(axesEvent.duration, defaultDuration, defaultDuration * passedPanelCount);\n\n    return {\n      panel: panelToMove,\n      destPos: viewport.findEstimatedPosition(panelToMove),\n      duration,\n      eventType: passedPanelCount > 0\n        ? EVENTS.CHANGE\n        : EVENTS.RESTORE,\n    };\n  }\n\n  private findAdjacentPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n    const basePosition = basePanel.getPosition();\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const eventType = adjacentPanel\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n    const targetRelativeAnchorPosition = panelToMove.getRelativeAnchorPosition();\n\n    const estimatedPanelPosition = options.circular\n      ? isNextDirection\n        ? basePosition + basePanel.getSize() + targetRelativeAnchorPosition + options.gap\n        : basePosition - (panelToMove.getSize() - targetRelativeAnchorPosition) - options.gap\n      : panelToMove.getAnchorPosition();\n    const estimatedPosition = estimatedPanelPosition - viewport.getRelativeHangerPosition();\n\n    return {\n      panel: panelToMove,\n      destPos: estimatedPosition,\n      duration: options.duration,\n      eventType,\n    };\n  }\n}\n\nexport default Snap;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { MoveTypeStringOption, MoveTypeContext, DestinationInfo } from \"../types\";\nimport Panel from \"../components/Panel\";\nimport { EVENTS } from \"../consts\";\n\nabstract class MoveType {\n  protected readonly abstract type: string;\n\n  public abstract findTargetPanel(ctx: MoveTypeContext): DestinationInfo;\n\n  public is(type: MoveTypeStringOption): boolean {\n    return type === this.type;\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    const viewport = ctx.viewport;\n    const options = viewport.options;\n\n    const panel = options.circular\n      ? this.findRestorePanelInCircularMode(ctx)\n      : viewport.getCurrentPanel()!;\n\n    return {\n      panel,\n      destPos: viewport.findEstimatedPosition(panel),\n      duration: options.duration,\n      eventType: EVENTS.RESTORE,\n    };\n  }\n\n  // Calculate minimum distance to \"change\" panel\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const relativeAnchorPosition = currentPanel.getRelativeAnchorPosition();\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - relativeAnchorPosition + halfGap\n      : relativeAnchorPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n\n  private findRestorePanelInCircularMode(ctx: MoveTypeContext): Panel {\n    const viewport = ctx.viewport;\n    const originalPanel = viewport.getCurrentPanel()!.getOriginalPanel();\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = originalPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(originalPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    return (!ctx.isNextDirection && lapped)\n      ? firstClonedPanel\n      : originalPanel;\n  }\n}\n\nexport default MoveType;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Snap from \"./Snap\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass FreeScroll extends Snap {\n  protected readonly type: string = MOVE_TYPE.FREE_SCROLL;\n\n  constructor() {\n    // Set snap count to Infinity\n    super(Infinity);\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, swipeDistance } = ctx;\n    const destPos = axesEvent.destPos.flick;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    if (eventDelta > minimumDistanceToChange) {\n      const destInfo = super.findSnappedPanel(ctx);\n      destInfo.destPos = destPos;\n      destInfo.eventType = destInfo.eventType === EVENTS.RESTORE\n        ? \"\"\n        : EVENTS.CHANGE;\n\n      return destInfo;\n    } else {\n      const scrollArea = viewport.getScrollArea();\n      const estimatedPosition = circulate(destPos, scrollArea.prev, scrollArea.next, false)\n        + viewport.getRelativeHangerPosition();\n\n      return {\n        panel: viewport.findNearestPanelAt(estimatedPosition)!,\n        destPos,\n        duration: viewport.options.duration,\n        eventType: swipeDistance > minimumDistanceToChange\n          ? EVENTS.CHANGE\n          : \"\",\n      };\n    }\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    return this.findTargetPanel(ctx);\n  }\n\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const lastPosition = viewport.stateMachine.getState().lastPosition;\n    const currentPanelPosition = currentPanel.getPosition();\n\n    // As camera can stop anywhere in free scroll mode,\n    // minimumDistanceToChange should be calculated differently.\n    // Ref #191(https://github.com/naver/egjs-flicking/issues/191)\n    const lastHangerPosition = lastPosition + viewport.getRelativeHangerPosition();\n\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanelPosition + currentPanel.getSize() - lastHangerPosition + halfGap\n      : lastHangerPosition - currentPanelPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n}\n\nexport default FreeScroll;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport MoveType from \"../moves/MoveType\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption, OriginalStyle, Plugin } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE, MOVE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement, hasClass, restoreStyle } from \"../utils\";\nimport Snap from \"../moves/Snap\";\nimport FreeScroll from \"../moves/FreeScroll\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n  public moveType: MoveType;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: {[key: string]: any};\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n\n  private plugins: Plugin[] = [];\n  private state: {\n    size: number;\n    position: number;\n    relativeHangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n    isViewportGiven: boolean;\n    isCameraGiven: boolean;\n    originalViewportStyle: OriginalStyle;\n    originalCameraStyle: OriginalStyle;\n  };\n\n  constructor(\n    flicking: Flicking,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      relativeHangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n      isViewportGiven: false,\n      isCameraGiven: false,\n      originalViewportStyle: {\n        className: null,\n        style: null,\n      },\n      originalCameraStyle: {\n        className: null,\n        style: null,\n      },\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    destPos: number,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | \"\",\n    axesEvent: any,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const currentPosition = state.position;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = destPos === currentPosition\n      ? null\n      : destPos > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel,\n        direction,\n      });\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      currentState.delta = 0;\n      currentState.lastPosition = this.getCameraPosition();\n      currentState.targetPanel = panel;\n      currentState.direction = destPos === currentPosition\n        ? null\n        : destPos > currentPosition\n            ? DIRECTION.NEXT\n            : DIRECTION.PREV;\n\n      if (destPos === currentPosition) {\n        // no move\n        this.nearestPanel = panel;\n        this.currentPanel = panel;\n      }\n\n      if (axesEvent && axesEvent.setTo) {\n        // freeScroll only occurs in release events\n        axesEvent.setTo({ flick: destPos }, duration);\n      } else {\n        this.axes.setTo({ flick: destPos }, duration);\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n\n    // Update position & nearestPanel\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    const moveVector = options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public resize(): void {\n    const panelManager = this.panelManager;\n\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n\n    panelManager.chainAllPanels();\n    this.updateCameraPosition();\n    this.updatePlugins();\n  }\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const hangerPosition = this.getHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n\n      return position <= state.scrollArea.prev\n        ? panelManager.firstPanel()\n        : panelManager.lastPanel();\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      } else if (distance === minimumDistance) {\n        const minimumAnchorDistance = Math.abs(position - nearestPanel!.getAnchorPosition());\n        const anchorDistance = Math.abs(position - panel.getAnchorPosition());\n\n        if (anchorDistance > minimumAnchorDistance) {\n          break;\n        }\n      }\n\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public findEstimatedPosition(panel: Panel): number {\n    const scrollArea = this.getScrollArea();\n\n    let estimatedPosition = panel.getAnchorPosition() - this.getRelativeHangerPosition();\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return estimatedPosition;\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index });\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    this.resize();\n\n    return panels;\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    panelManager.replace(index, panels);\n\n    const currentPanel = this.currentPanel;\n    const wasEmpty = !currentPanel;\n    if (wasEmpty) {\n      this.currentPanel = panels[0];\n    } else if (isBetween(currentPanel!.getIndex(), index, index + panels.length - 1)) {\n      // Current panel is replaced\n      this.currentPanel = panelManager.get(currentPanel!.getIndex());\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index + panels.length - 1 });\n\n    this.resize();\n\n    const isFreeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n    if (isFreeScroll && wasEmpty) {\n      this.moveTo(this.currentPanel!, this.findEstimatedPosition(this.currentPanel!), \"\", null, 0);\n    }\n\n    return panels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n\n    // Update checked indexes in infinite mode\n    if (deleteCount > 0) {\n      // Check whether removing index will affect checked indexes\n      // Suppose index 0 is empty and removed index 1, then checked index 0 should be deleted and vice versa.\n      this.updateCheckedIndexes({ min: index - 1, max: index + deleteCount });\n    }\n\n    this.resize();\n\n    return removedPanels;\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    let sizeToApply: number;\n    if (options.adaptive) {\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const state = this.state;\n    const wrapper = this.flicking.getElement();\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const originalPanels = this.panelManager.originalPanels();\n\n    this.removePlugins(this.plugins);\n    restoreStyle(viewportElement, state.originalViewportStyle);\n    restoreStyle(cameraElement, state.originalCameraStyle);\n\n    if (!state.isCameraGiven && !this.options.renderExternal) {\n      const topmostElement = state.isViewportGiven\n        ? viewportElement\n        : wrapper;\n      const deletingElement = state.isViewportGiven\n        ? cameraElement\n        : viewportElement;\n\n      originalPanels.forEach(panel => {\n        topmostElement.appendChild(panel.getElement());\n      });\n\n      topmostElement.removeChild(deletingElement);\n    }\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    originalPanels.forEach(panel => { panel.destroy(); });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const defaultIndex = this.options.defaultIndex;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    panelManager.clear();\n    cameraElement.innerHTML = status.panels.map(panel => panel.html).join(\"\");\n\n    this.createPanels();\n\n    // Reset panel index\n    panelManager.originalPanels().forEach((panel, idx) => {\n      panel.setIndex(panels[idx].index);\n    });\n\n    this.currentPanel = panelManager.get(status.index)\n      || panelManager.get(defaultIndex)\n      || panelManager.firstPanel();\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    const currentState = this.stateMachine.getState();\n    let nearestPanel = currentState.playing || currentState.holding\n      ? this.nearestPanel\n      : this.currentPanel;\n\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const {prev: prevRange, next: nextRange} = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : basePosition = nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  // Update axes flick position without triggering event\n  public updateAxesPosition(position: number) {\n    const axes = this.axes;\n    axes.off();\n    axes.setTo({\n      flick: position,\n    }, 0);\n    axes.on(this.axesHandlers);\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const scrollArea = state.scrollArea;\n\n    return !options.circular\n      && options.bound\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n\n  public canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const lastPanel = this.panelManager.lastPanel();\n    if (!lastPanel) {\n      return false;\n    }\n\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  public getViewportElement(): HTMLElement {\n    return this.viewportElement;\n  }\n\n  public getCameraElement(): HTMLElement {\n    return this.cameraElement;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public getCheckedIndexes(): Array<[number, number]> {\n    return this.state.checkedIndexes;\n  }\n\n  public setCurrentPanel(panel: Panel): void {\n    this.currentPanel = panel;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public connectAxesHandler(handlers: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this.flicking);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this.flicking);\n    });\n    return this;\n  }\n  public updateCheckedIndexes(changedRange: { min: number, max: number }): void {\n    const state = this.state;\n\n    let removed = 0;\n    state.checkedIndexes.concat().forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (changedRange.min <= max && changedRange.max >= min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx - removed, 1);\n        removed++;\n      }\n    });\n  }\n\n  private build(): void {\n    this.setElements();\n    this.applyCSSValue();\n    this.setMoveType();\n    this.setAxesInstance();\n    this.createPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private setElements(): void {\n    const state = this.state;\n    const options = this.options;\n    const wrapper = this.flicking.getElement();\n    const classPrefix = options.classPrefix;\n\n    const viewportCandidate = wrapper.children[0] as HTMLElement;\n    const hasViewportElement = hasClass(viewportCandidate, `${classPrefix}-viewport`);\n\n    const viewportElement = hasViewportElement\n      ? viewportCandidate\n      : document.createElement(\"div\");\n\n    const cameraCandidate = hasViewportElement\n      ? viewportElement.children[0] as HTMLElement\n      : wrapper.children[0] as HTMLElement;\n    const hasCameraElement = hasClass(cameraCandidate, `${classPrefix}-camera`);\n\n    const cameraElement = hasCameraElement\n      ? cameraCandidate\n      : document.createElement(\"div\");\n\n    if (!hasCameraElement) {\n      cameraElement.className = `${classPrefix}-camera`;\n\n      const panelElements = hasViewportElement\n        ? viewportElement.children\n        : wrapper.children;\n\n      // Make all panels to be a child of camera element\n      // wrapper <- viewport <- camera <- panels[1...n]\n      toArray(panelElements).forEach(child => {\n        cameraElement.appendChild(child);\n      });\n    } else {\n      state.originalCameraStyle = {\n        className: cameraElement.getAttribute(\"class\"),\n        style: cameraElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasViewportElement) {\n      viewportElement.className = `${classPrefix}-viewport`;\n\n      // Add viewport element to wrapper\n      wrapper.appendChild(viewportElement);\n    } else {\n      state.originalViewportStyle = {\n        className: viewportElement.getAttribute(\"class\"),\n        style: viewportElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasCameraElement || !hasViewportElement) {\n      viewportElement.appendChild(cameraElement);\n    }\n\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    state.isViewportGiven = hasViewportElement;\n    state.isCameraGiven = hasCameraElement;\n\n    // Create PanelManager instance\n    this.panelManager = new PanelManager(cameraElement, options);\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n\n    // Set default css values for each element\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setMoveType(): void {\n    const moveType = this.options.moveType as MoveTypeObjectOption;\n\n    switch (moveType.type) {\n      case MOVE_TYPE.SNAP:\n        this.moveType = new Snap(moveType.count);\n        break;\n      case MOVE_TYPE.FREE_SCROLL:\n        this.moveType = new FreeScroll();\n        break;\n      default:\n        throw new Error(\"moveType is not correct!\");\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this),\n    );\n\n    if (panels.length > 0) {\n      this.panelManager.append(panels);\n    }\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + this.options.gap;\n    const visibleAreaSize = viewportSize + firstPanel.getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    if (options.renderExternal) {\n      panelManager.setCloneCount(cloneCount);\n      return;\n    }\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n\n          this.cameraElement.appendChild(clonedPanel.getElement());\n\n          return clonedPanel;\n        });\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const panels = this.panelManager.originalPanels();\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n    state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n\n    // Resize all panels\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n    const scrollArea = this.state.scrollArea;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if (nearestPanel) {\n      // We should maintain nearestPanel's position\n      const looped = !isBetween(currentState.lastPosition + currentState.delta, scrollArea.prev, scrollArea.next);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const currentPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      if (currentPosition !== newPosition) {\n        panel.setPosition(newPosition);\n      }\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .reduce((allClones, clones) => [...allClones, ...clones], [])\n      .filter(panel => Boolean(panel));\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  // Update camera position after resizing\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.stateMachine.getState();\n    const isFreeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n\n    if (currentState.holding || currentState.playing || isFreeScroll) {\n      return;\n    }\n\n    let newPosition = currentPanel\n      ? currentPanel.getAnchorPosition() - state.relativeHangerPosition\n      : this.getCameraPosition();\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.updateAxesPosition(newPosition);\n\n    this.moveCamera(newPosition);\n  }\n\n  private updatePlugins(): void {\n    // update for resize\n    this.plugins.forEach(plugin => {\n      plugin.update && plugin.update(this.flicking);\n    });\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        siblingPanel: null,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      const lastPanel = panelManager.lastPanel()!;\n      const atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel();\n        const firstIndex = firstPanel\n          ? firstPanel.getIndex()\n          : -1;\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels are changed\n      const lastPanelAfterNeed = panelManager.lastPanel()!;\n      const atLastPanelAfterNeed = lastPanelAfterNeed && currentIndex === lastPanelAfterNeed.getIndex();\n\n      if (atLastPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      const firstPanel = panelManager.firstPanel()!;\n      const atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel();\n\n        if (lastPanel && lastPanel.getIndex() < maxLastIndex) {\n          const lastIndex = lastPanel.getIndex();\n\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels were changed\n      const firstPanelAfterNeed = panelManager.firstPanel();\n      const atFirstPanelAfterNeed = firstPanelAfterNeed && checkingIndex === firstPanelAfterNeed.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    siblingPanel: Panel | null,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, siblingPanel, direction, indexRange } = params;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const index = siblingPanel\n      ? siblingPanel.getIndex()\n      : 0;\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel: siblingPanel,\n        direction,\n        range: indexRange,\n      } as Partial<NeedPanelEvent>,\n    );\n  }\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\nimport Panel from \"./components/Panel\";\n\nimport { merge, getProgress, parseElement, isString, counter } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin, ElementLike } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event type object\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options An option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix of class name will be added for the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation for animation triggered by manual user input. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for continuous scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\n   * @param {boolean} [options.infinite=false] Enables infinite mode, which can automatically trigger needPanel until reaching last panel's index reaches lastIndex<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\n   * @param {number} [options.infiniteThreshold=0] A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\n   * @param {number} [options.lastIndex=Infinity] Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when event's panel index is greater than it.<br>Also, if last panel's index reached given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold angle value(0 ~ 90).<br>If input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\n   * @param {boolean} [options.autoResize=false] Whether resize() method should be called automatically after window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\n   * @param {boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\n   * @param {boolean} [options.bound=false] Prevent view from going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Reference position of hanger in viewport, which hangs panel anchors should be stopped at.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Reference position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels. Should be given in number.(px).<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\n   * @param {eg.Flicking.MoveTypeOption} [options.moveType=\"snap\"] Movement style by user input.(ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\n   */\n  constructor(\n    element: string | HTMLElement,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, this.options, this.triggerEvent);\n    this.listenInput();\n    this.listenResize();\n  }\n\n  /**\n   * Move to the previous panel if it exists.\n   * @ko 이전 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public prev(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const prevPanel = currentPanel.prev();\n      if (prevPanel) {\n        prevPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel if it exists.\n   * @ko 다음 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation(unit: ms).<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public next(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const nextPanel = currentPanel.next();\n      if (nextPanel) {\n        nextPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the panel of given index.\n   * @ko 주어진 인덱스에 해당하는 패널로 이동한다.\n   * @param index The index number of the panel to move.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let targetPanel = panel;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity) - panel.getRelativeAnchorPosition();\n\n      const identicals = panel.getIdenticalPanels();\n      const offset = nearestPosition - anchorPosition;\n      if (offset > 0) {\n        // First cloned panel is nearest\n        targetPanel = identicals[1];\n      } else if (offset < 0) {\n        // Last cloned panel is nearest\n        targetPanel = identicals[identicals.length - 1];\n      }\n\n      targetPanel = targetPanel.clone(targetPanel.getCloneIndex(), true);\n      targetPanel.setPosition(nearestPosition);\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === targetPanel.getAnchorPosition() && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      targetPanel,\n      viewport.findEstimatedPosition(targetPanel),\n      eventType,\n      null,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Return index of the current panel. `-1` if no panel exists.\n   * @ko 현재 패널의 인덱스 번호를 반환한다. 패널이 하나도 없을 경우 `-1`을 반환한다.\n   * @return Current panel's index, zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Return the wrapper element user provided in constructor.\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트.</ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Return current panel. `null` if no panel exists.\n   * @ko 현재 패널을 반환한다. 패널이 하나도 없을 경우 `null`을 반환한다.\n   * @return Current panel.<ko>현재 패널.</ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return the panel of given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 패널을 반환한다. 해당 패널이 존재하지 않을 시 `null`이다.\n   * @return Panel of given index.<ko>주어진 인덱스에 해당하는 패널.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return all panels.\n   * @ko 모든 패널들을 반환한다.\n   * @param - Should include cloned panels or not.<ko>복사된 패널들을 포함할지의 여부.</ko>\n   * @return All panels.<ko>모든 패널들.</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel);\n  }\n\n  /**\n   * Return the panels currently shown in viewport area.\n   * @ko 현재 뷰포트 영역에서 보여지고 있는 패널들을 반환한다.\n   * @return Panels currently shown in viewport area.<ko>현재 뷰포트 영역에 보여지는 패널들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(panel => {\n      const outsetProgress = panel.getOutsetProgress();\n\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n\n  /**\n   * Return length of original panels.\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Return how many groups of clones are created.\n   * @ko 몇 개의 클론 그룹이 생성되었는지를 반환한다.\n   * @return Length of cloned panel groups.<ko>클론된 패널 그룹의 개수</ko>\n   */\n  public getCloneCount(): number {\n    return this.viewport.panelManager.getCloneCount();\n  }\n\n  /**\n   * Get maximum panel index for `infinite` mode.\n   * @ko `infinite` 모드에서 적용되는 추가 가능한 패널의 최대 인덱스 값을 반환한다.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return Maximum index of panel that can be added.<ko>최대 추가 가능한 패널의 인덱스.</ko>\n   */\n  public getLastIndex(): number {\n    return this.viewport.panelManager.getLastIndex();\n  }\n\n  /**\n   * Set maximum panel index for `infinite' mode.<br>[needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it.<br>Also, you can't add more panels after it.\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다.<br>마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다.<br>또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\n   * @param - Maximum panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public setLastIndex(index: number): this {\n    this.viewport.setLastIndex(index);\n\n    return this;\n  }\n\n  /**\n   * Return panel movement animation.\n   * @ko 현재 패널 이동 애니메이션이 진행 중인지를 반환한다.\n   * @return Is animating or not.<ko>애니메이션 진행 여부.</ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * Unblock input devices.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * Block input devices.\n   * @ko 입력 장치로부터의 입력을 막는다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to [setStatus()]{@link eg.Flicking#setStatus}.\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있다.\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus(): FlickingStatus {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`의 상태로 복원한다.\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking.\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add.<ko>추가할 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.addPlugins(plugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.removePlugins(plugins);\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * Update panels to current state.\n   * @ko 패널들을 현재 상태에 맞춰 갱신한다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public resize(): this {\n    const viewport = this.viewport;\n\n    viewport.panelManager.allPanels()\n      .forEach(panel => panel.unCacheBbox());\n    viewport.resize();\n\n    return this;\n  }\n\n  /**\n   * Add new panels at the beginning of panels.\n   * @ko 제일 앞에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 0, pushing every panels behind it.\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  }\n\n  /**\n   * Add new panels at the end of panels.\n   * @ko 제일 끝에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  }\n\n  /**\n   * Replace existing panels with new panels from given index. If target index is empty, add new panel at target index.\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.replace(index, element);\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  /**\n   * Synchronize info of panels instance with info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 패널의 정보와 현재 플리킹이 갖는 패널 정보를 동기화한다.\n   * @param diffInfo - Info object of how panel elements are changed.<ko>패널의 DOM 요소들의 변경 정보를 담는 오브젝트.</ko>\n   * @param {HTMLElement[]} [diffInfo.list] - DOM elements list after update.<ko>업데이트 이후 DOM 요소들의 리스트</ko>\n   * @param {number[][]} [diffInfo.maintained] - Index tuple array of DOM elements maintained. Formatted with `[before, after]`.<ko>변경 전후에 유지된 DOM 요소들의 인덱스 튜플 배열. `[이전, 이후]`의 형식을 갖고 있어야 한다.</ko>\n   * @param {number[]} [diffInfo.added] - Index array of DOM elements added to `list`.<ko>`list`에서 추가된 DOM 요소들의 인덱스 배열.</ko>\n   * @param {number[]} [diffInfo.removed] - Index array of DOM elements removed from previous element list.<ko>이전 리스트에서 제거된 DOM 요소들의 인덱스 배열.</ko>\n   */\n  public sync(diffInfo: {\n    list: HTMLElement[],\n    maintained: number[][],\n    added: number[],\n    changed: number[][],\n    removed: number[],\n  }): this {\n    const { list, maintained, added, changed, removed } = diffInfo;\n\n    // Did not changed at all\n    if (added.length <= 0 && removed.length <= 0 && changed.length <= 0) {\n      return this;\n    }\n\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const indexRange = panelManager.getRange();\n    const isCircular = this.options.circular;\n\n    // Make sure that new \"list\" should include cloned elements\n    const newOriginalPanelCount = (list.length / (panelManager.getCloneCount() + 1)) >> 0; // Make sure it's integer. Same with Math.floor, but faster\n    const newCloneCount = ((list.length / newOriginalPanelCount) >> 0) - 1;\n\n    const prevOriginalPanels = panelManager.originalPanels();\n    const prevClonedPanels = panelManager.clonedPanels();\n\n    const newOriginalElements = list.slice(0, newOriginalPanelCount);\n    const newClonedElements = list.slice(newOriginalPanelCount);\n\n    const newPanels: Panel[] = [];\n    const newClones: Panel[][] = counter(newCloneCount).map(() => []);\n\n    // For maintained panels after external rendering, they should be maintained in newPanels.\n    const originalMaintained = maintained.filter(([beforeIdx, afterIdx]) => beforeIdx <= indexRange.max);\n    // For newly added panels after external rendering, they will be added with their elements.\n    const originalAdded = added.filter(index => index < newOriginalPanelCount);\n\n    originalMaintained.forEach(([beforeIdx, afterIdx]) => {\n      newPanels[afterIdx] = prevOriginalPanels[beforeIdx];\n      newPanels[afterIdx].setIndex(afterIdx);\n    });\n\n    originalAdded.forEach(addIndex => {\n      newPanels[addIndex] = new Panel(newOriginalElements[addIndex], addIndex, viewport);\n    });\n\n    if (isCircular) {\n      counter(newCloneCount).forEach(groupIndex => {\n        const cloneGroupOffset = newOriginalPanelCount * groupIndex;\n        const prevCloneGroup = prevClonedPanels[groupIndex];\n        const newCloneGroup = newClones[groupIndex];\n\n        originalMaintained.forEach(([beforeIdx, afterIdx]) => {\n          newCloneGroup[afterIdx] = prevCloneGroup\n            ? prevCloneGroup[beforeIdx]\n            : newPanels[afterIdx].cloneExternal(groupIndex, newClonedElements[cloneGroupOffset + afterIdx]);\n        });\n\n        originalAdded.forEach(addIndex => {\n          const newPanel = newPanels[addIndex];\n\n          newCloneGroup[addIndex] = newPanel.cloneExternal(groupIndex, newClonedElements[cloneGroupOffset + addIndex]);\n        });\n      });\n    }\n\n    // Replace current info of panels this holds\n    added.forEach(index => { viewport.updateCheckedIndexes({ min: index, max: index }); });\n    removed.forEach(index => { viewport.updateCheckedIndexes({ min: index - 1, max: index + 1 }); });\n\n    const checkedIndexes = viewport.getCheckedIndexes();\n    checkedIndexes.forEach(([min, max], idx) => {\n      // Push checked indexes backward\n      const pushedIndex = added.filter(index => index < min && panelManager.has(index)).length\n        - removed.filter(index => index < min).length;\n      checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n    });\n\n    // Only effective only when there are least one panel which have changed its index\n    if (changed.length > 0) {\n      // Removed checked index by changed ones after pushing\n      maintained.forEach(([prev, next]) => { viewport.updateCheckedIndexes({ min: next, max: next }); });\n    }\n\n    panelManager.replacePanels(newPanels, newClones);\n    this.resize();\n\n    return this;\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params));\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = (cameraChange > 0 ? -1 : 1) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.direction = currentDirection;\n    }\n    state.delta += axesEvent.delta.flick;\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n}\n\nexport default Flicking;\n","import Flicking from \"./Flicking\";\nimport { withFlickingMethods } from \"./utils\";\nimport { DEFAULT_OPTIONS, MOVE_TYPE } from \"./consts\";\n\n(Flicking as any).withFlickingMethods = withFlickingMethods;\n(Flicking as any).DEFAULT_OPTIONS = DEFAULT_OPTIONS;\n(Flicking as any).MOVE_TYPE = MOVE_TYPE;\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","element","Array","isArray","elements","el","isString","tempDiv","document","createElement","innerHTML","push","toArray","children","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","cssObj","property","val","min","max","Math","iterable","slice","call","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","callback","i","counterArray","indexed","size","className","findIndex","classList","split","originalStyle","setAttribute","removeAttribute","MOVE_TYPE","SNAP","FREE_SCROLL","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","renderExternal","DEFAULT_VIEWPORT_CSS","position","width","height","DEFAULT_CAMERA_CSS","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","DIRECTION","PREV","NEXT","FLICKING_METHODS","prev","next","moveTo","getIndex","getAllPanels","getCurrentPanel","getElement","getPanel","getPanelCount","getStatus","getVisiblePanels","setLastIndex","enableInput","disableInput","destroy","resize","setStatus","addPlugins","removePlugins","isPlaying","getLastIndex","TRANSFORM","index","viewport","prevSibling","nextSibling","clonedPanels","state","relativeAnchorPosition","isClone","isVirtual","cloneIndex","getAttribute","cachedBbox","setElement","this","options","bbox","getBbox","parseArithmeticExpression","panel","panelCount","panelManager","scrollAreaSize","getScrollAreaSize","floor","getPosition","getCurrentProgress","outsetRange","getSize","getRelativeHangerPosition","getRelativeAnchorPosition","getProgress","getCameraPosition","panelSize","relativePanelPosition","rightRelativePanelPosition","visibleSize","currentPanel","getHangerPosition","getAnchorPosition","eventType","findEstimatedPosition","updateFunction","getIdenticalPanels","eachPanel","unCacheBbox","currentIndex","currentPosition","prevPanelIndex","prevPanelPosition","prevPanelSize","hasEmptyPanelBetween","notYetMinPanel","newPosition","prevPanel","clone","getCloneIndex","setPosition","nextPanelIndex","nextPanelPosition","notYetMaxPanel","nextPanel","parsedElements","parseElement","firstPanel","targetIndex","insert","remove","restoreStyle","getBoundingClientRect","original","getClonedPanels","elementStyle","left","top","clonedPanel","Panel","cloneNode","clonedState","parentNode","removeClonedPanelsAfter","start","splice","removeElement","add","indexOf","replace","applyCSS","cameraElement","panels","clones","cloneCount","reduce","allClones","newPanels","newClones","Boolean","filter","lastPanel","removingPanels","possibleLastPanel","_a","isCircular","findFirstPanelFrom","siblingElement","insertNewPanels","pushedIndex","offset","panelsAfterIndex","emptyPanelCount","removedPanels","newLastIndex","concat","reverse","setIndex","addNewClones","updateIndex","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","cloneSet","nonEmptyIndexFromLast","allPanels","allPanelsCount","insertTarget_1","newClones_1","allPanels_1","contains","originalPanels","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","map","_this","this_1","insertClones","counter","insertingIndex","fragment_1","createDocumentFragment","appendChild","prevState","delta","direction","targetPanel","lastPosition","nextState","e","context","tslib_1","flicking","triggerEvent","transitTo","moveCamera","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","flick","setTo","releaseEvent","clickedElement","srcEvent","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","stopCamera","isFreeScroll","is","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","abs","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","destPos","nearestPanel","getNearestPanel","stop","moveTypeContext","axesEvent","destInfo","findTargetPanel","findRestorePanel","scrollArea","getScrollArea","loopCount","originalTargetPosition","newCloneIndex","circulate","newTargetPosition","newTargetPanel","setCurrentPanel","isTrusted","updateAdaptiveSize","updateAxesPosition","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onEnter","onHold","onRelease","onAnimationEnd","onFinish","_super","ctx","snapCount","eventDelta","minimumDistanceToChange","calcBrinkOfChange","shouldMoveWhenBounceIs0","canSetBoundMode","shouldMoveToAdjacent","isOutOfBound","findSnappedPanel","findAdjacentPanel","halfGap","estimatedHangerPos","panelToMove","cycleIndex","passedPanelCount","siblingPanel","panelIndex","siblingIndex","originalPanel","getOriginalPanel","panelPosition","originalPosition","defaultDuration","getCurrentIndex","get","hangerPosition","firstClonedPanel","basePanel","basePosition","adjacentPanel","targetRelativeAnchorPosition","estimatedPanelPosition","findRestorePanelInCircularMode","lapped","estimatedPosition","findNearestPanelAt","stateMachine","getState","currentPanelPosition","lastHangerPosition","Snap","relativeHangerPosition","translate","checkedIndexes","isViewportGiven","isCameraGiven","originalViewportStyle","originalCameraStyle","StateMachine","build","eventResult","axes","findNearestPanel","originalNearestPosition","checkNeedPanel","moveCoord","coord","round","join","updateSize","updateOriginalPanelPositions","updateScrollArea","clonePanels","updateClonedPanelPositions","chainAllPanels","updateCameraPosition","updatePlugins","minimumDistance","prevPosition","nextPosition","distance","isBetween","nearest","shortestDistance","identical","anchorPosition","panInput","enable","disable","updateCheckedIndexes","indexes","wasEmpty","newCurrentIndex","getRange","sizeToApply","panelBbox","maximum","viewportStyle","viewportElement","minHeight","minWidth","wrapper","plugins","topmostElement_1","deletingElement","status","clear","html","createPanels","playing","holding","NaN","prevRange","nextRange","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","targetPosition","progressBetween","off","on","axesHandlers","summedPanelSize","handlers","newPlugins","plugin","init","currentPlugins","changedRange","removed","setElements","applyCSSValue","setMoveType","setAxesInstance","setDefaultPanel","moveToDefaultPanel","viewportCandidate","hasViewportElement","hasClass","cameraCandidate","hasCameraElement","child","PanelManager","FreeScroll","Axes","easing","interruptable","PanInput","scale","connect","append","indexRange","viewportSize","sumOriginalPanelSize","visibleAreaSize","ceil","prevCloneCount","setCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","nextPanelPos","maintainingPanel","accumulatedSize","total","clonedPanels_1","clonedPanelPos","lastReplacePosition","_b","replacePosition","arr","parsedBounce","constructor","parsedVal","axis","update","maxLastIndex","checkingPanel","nextIndex","currentNearestPosition","triggerNeedPanel","firstIndex","lastPanelAfterNeed","cameraPrev","checkingIndex","prevIndex","firstPanelAfterNeed","params","alreadyTriggered","some","hasHandler","hasOn","eventName","canceled","progress","trigger","merge","previousPosition","inputOffset","cameraChange","looped","currentDirection","querySelector","nodeName","nodeType","currentOptions","Viewport","listenInput","listenResize","focus","nearestPosition","current","identicals","includeClone","outsetProgress","getOutsetProgress","outerHTML","restore","diffInfo","list","maintained","added","changed","newOriginalPanelCount","newCloneCount","prevOriginalPanels","prevClonedPanels","newOriginalElements","newClonedElements","originalMaintained","beforeIdx","originalAdded","afterIdx","addIndex","groupIndex","cloneGroupOffset","prevCloneGroup","newCloneGroup","cloneExternal","newPanel","getCheckedIndexes","has","replacePanels","eventContext","fire","connectAxesHandler","addEventListener","Flicking","Component","withFlickingMethods","prototype","flickingName","args","result"],"mappings":"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"}