{"version":3,"file":"flicking.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/moves/MoveType.ts","../src/moves/Snap.ts","../src/moves/FreeScroll.ts","../src/components/Viewport.ts","../src/Flicking.ts","../src/index.umd.ts"],"sourcesContent":["/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { ElementLike, OriginalStyle } from \"./types\";\nimport Flicking from \"./Flicking\";\nimport { FLICKING_METHODS } from \"./consts\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n\n// Circulate number between range [min, max]\n/*\n * \"indexed\" means min and max is not same, so if it's true \"min - 1\" should be max\n * While if it's false, \"min - 1\" should be \"max - 1\"\n * use `indexed: true` when it should be used for circulating integers like index\n * or `indexed: false` when it should be used for something like positions.\n */\nexport function circulate(value: number, min: number, max: number, indexed: boolean): number {\n  const size = indexed\n    ? max - min + 1\n    : max - min;\n  if (value < min) {\n    const offset = indexed\n      ? (min - value - 1) % size\n      : (min - value) % size;\n    value = max - offset;\n  } else if (value > max) {\n    const offset = indexed\n      ? (value - max - 1) % size\n      : (value - max) % size;\n    value = min + offset;\n  }\n\n  return value;\n}\n\nexport function hasClass(element: HTMLElement | null, className: string): boolean {\n  if (!element) {\n    return false;\n  }\n\n  const classes = classList(element);\n\n  return findIndex(classes, name => name === className) > -1;\n}\n\nexport function restoreStyle(element: HTMLElement, originalStyle: OriginalStyle): void {\n  originalStyle.className\n    ? element.setAttribute(\"class\", originalStyle.className)\n    : element.removeAttribute(\"class\");\n  originalStyle.style\n    ? element.setAttribute(\"style\", originalStyle.style)\n    : element.removeAttribute(\"style\");\n}\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nexport function withFlickingMethods(prototype: any, flickingName: string) {\n\n  Object.keys(FLICKING_METHODS).forEach((name: keyof Flicking) => {\n    if (prototype[name]) {\n      return;\n    }\n    prototype[name] = function(...args) {\n      const result = this[flickingName][name](...args);\n\n      // fix `this` type to return your own `flicking` instance to the instance using the decorator.\n      if (result === this[flickingName]) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n  });\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption, FlickingMethodsKeys } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const MOVE_TYPE: {\n  SNAP: \"snap\";\n  FREE_SCROLL: \"freeScroll\";\n} = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n};\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\n\n/**\n * Default options for creating Flicking.\n * @ko 플리킹을 만들 때 사용하는 기본 옵션들\n * @private\n * @memberof eg.Flicking\n */\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n  renderExternal: false,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\nexport const FLICKING_METHODS: {[key in FlickingMethodsKeys]: true} = {\n  prev: true,\n  next: true,\n  moveTo: true,\n  getIndex: true,\n  getAllPanels: true,\n  getCurrentPanel: true,\n  getElement: true,\n  getPanel: true,\n  getPanelCount: true,\n  getStatus: true,\n  getVisiblePanels: true,\n  setLastIndex: true,\n  enableInput: true,\n  disableInput: true,\n  destroy: true,\n  resize: true,\n  setStatus: true,\n  addPlugins: true,\n  removePlugins: true,\n  isPlaying: true,\n  getLastIndex: true,\n};\nexport const TRANSFORM = checkTranslateSupport();\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Viewport from \"./Viewport\";\nimport { OriginalStyle, FlickingPanel, ElementLike } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, parseElement, getProgress, restoreStyle } from \"../utils\";\n\nclass Panel implements FlickingPanel {\n  public viewport: Viewport;\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  protected state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    isVirtual: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    cachedBbox: ClientRect | null;\n  };\n  private element: HTMLElement;\n  private original?: Panel;\n  private clonedPanels: Panel[];\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    viewport: Viewport,\n  ) {\n    this.viewport = viewport;\n    this.prevSibling = null;\n    this.nextSibling = null;\n    this.clonedPanels = [];\n\n    this.state = {\n      index,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      isClone: false,\n      isVirtual: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\"),\n        style: element.getAttribute(\"style\"),\n      },\n      cachedBbox: null,\n    };\n\n    this.setElement(element);\n  }\n\n  public resize(): void {\n    const state = this.state;\n    const options = this.viewport.options;\n    const bbox = this.getBbox();\n\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n    state.relativeAnchorPosition = parseArithmeticExpression(options.anchor, state.size);\n\n    if (!state.isClone) {\n      this.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public unCacheBbox(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public getProgress() {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const panelCount = viewport.panelManager.getPanelCount();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n\n    const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n    const progress = relativeIndex - viewport.getCurrentProgress();\n\n    return progress;\n  }\n\n  public getOutsetProgress() {\n    const viewport = this.viewport;\n    const outsetRange = [\n      -this.getSize(),\n      viewport.getRelativeHangerPosition() - this.getRelativeAnchorPosition(),\n      viewport.getSize(),\n    ];\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    return outsetProgress;\n  }\n\n  public getVisibleRatio() {\n    const viewport = this.viewport;\n    const panelSize = this.getSize();\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const rightRelativePanelPosition = relativePanelPosition + panelSize;\n\n    const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0\n      ? visibleSize / panelSize\n      : 0;\n\n    return visibleRatio;\n  }\n\n  public focus(duration?: number): void {\n    const viewport = this.viewport;\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getHangerPosition();\n    const anchorPosition = this.getAnchorPosition();\n    if (hangerPosition === anchorPosition || !currentPanel) {\n      return;\n    }\n\n    const currentPosition = currentPanel.getPosition();\n    const eventType = currentPosition === this.getPosition()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(this, viewport.findEstimatedPosition(this), eventType, null, duration);\n  }\n\n  public update(updateFunction: (element: HTMLElement) => any): void {\n    this.getIdenticalPanels()\n      .forEach(eachPanel => {\n        updateFunction(eachPanel.getElement());\n        eachPanel.unCacheBbox();\n      });\n    this.viewport.resize();\n  }\n\n  public prev(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const prevSibling = this.prevSibling;\n\n    if (!prevSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const prevPanelIndex = prevSibling.getIndex();\n    const prevPanelPosition = prevSibling.getPosition();\n    const prevPanelSize = prevSibling.getSize();\n\n    const hasEmptyPanelBetween = currentIndex - prevPanelIndex > 1;\n    const notYetMinPanel = options.infinite\n      && currentIndex > 0\n      && prevPanelIndex > currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMinPanel) {\n      // Empty panel exists between\n      return null;\n    }\n\n    const newPosition = currentPosition - prevPanelSize - options.gap;\n\n    let prevPanel = prevSibling;\n    if (prevPanelPosition !== newPosition) {\n      prevPanel = prevSibling.clone(prevSibling.getCloneIndex(), true);\n      prevPanel.setPosition(newPosition);\n    }\n\n    return prevPanel;\n  }\n\n  public next(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const nextSibling = this.nextSibling;\n    const lastIndex = viewport.panelManager.getLastIndex();\n\n    if (!nextSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const nextPanelIndex = nextSibling.getIndex();\n    const nextPanelPosition = nextSibling.getPosition();\n\n    const hasEmptyPanelBetween = nextPanelIndex - currentIndex > 1;\n    const notYetMaxPanel = options.infinite\n      && currentIndex < lastIndex\n      && nextPanelIndex < currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMaxPanel) {\n      return null;\n    }\n\n    const newPosition = currentPosition + this.getSize() + options.gap;\n\n    let nextPanel = nextSibling;\n    if (nextPanelPosition !== newPosition) {\n      nextPanel = nextSibling.clone(nextSibling.getCloneIndex(), true);\n      nextPanel.setPosition(newPosition);\n    }\n\n    return nextPanel;\n  }\n\n  public insertBefore(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n    const firstPanel = viewport.panelManager.firstPanel()!;\n    const prevSibling = this.prevSibling;\n    // Finding correct inserting index\n    // While it should insert removing empty spaces,\n    // It also should have to be bigger than prevSibling' s index\n    const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n      ? Math.max(prevSibling.getIndex() + 1, this.getIndex() - parsedElements.length)\n      : Math.max(this.getIndex() - parsedElements.length, 0);\n\n    return viewport.insert(targetIndex, parsedElements);\n  }\n\n  public insertAfter(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.insert(this.getIndex() + 1, element);\n  }\n\n  public remove(): FlickingPanel {\n    this.viewport.remove(this.getIndex());\n\n    return this;\n  }\n\n  public destroy(): void {\n    const originalStyle = this.state.originalStyle;\n\n    restoreStyle(this.element, originalStyle);\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox!;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : this.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...this.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number): void {\n    const state = this.state;\n\n    state.index = index;\n    this.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number): this {\n    const state = this.state;\n    const options = this.viewport.options;\n\n    state.position = pos;\n    if (!state.isVirtual) {\n      const elementStyle = this.element.style;\n      options.horizontal\n        ? elementStyle.left = `${pos}px`\n        : elementStyle.top = `${pos}px`;\n    }\n\n    return this;\n  }\n\n  public clone(cloneIndex: number, isVirtual: boolean = false): Panel {\n    const state = this.state;\n    const viewport = this.viewport;\n\n    const cloneElement = isVirtual\n      ? this.element\n      : this.element.cloneNode(true) as HTMLElement;\n\n    const clonedPanel = new Panel(cloneElement, state.index, viewport);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = this;\n    clonedState.isClone = true;\n    clonedState.isVirtual = isVirtual;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n\n    if (!isVirtual) {\n      this.clonedPanels.push(clonedPanel);\n    } else {\n      clonedPanel.prevSibling = this.prevSibling;\n      clonedPanel.nextSibling = this.nextSibling;\n    }\n\n    return clonedPanel;\n  }\n\n  // Clone with external element\n  public cloneExternal(cloneIndex: number, element: HTMLElement): Panel {\n    const clonedPanel = this.clone(cloneIndex);\n    clonedPanel.setElement(element);\n\n    return clonedPanel;\n  }\n\n  public removeElement(): void {\n    if (!this.viewport.options.renderExternal) {\n      const element = this.element;\n      element.parentNode!.removeChild(element);\n    }\n\n    // Do the same thing for clones\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const removingPanels = this.clonedPanels.splice(start);\n\n    removingPanels.forEach(panel => {\n      panel.removeElement();\n    });\n  }\n\n  private setElement(element: HTMLElement): void {\n    this.element = element;\n\n    const options = this.viewport.options;\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n  }\n}\n\nexport default Panel;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private options: FlickingOptions;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private cloneCount: number;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.cloneCount = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clones.reduce((allClones, clones) => [...allClones, ...clones], []),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel[]> {\n    return this.clones;\n  }\n\n  public replacePanels(newPanels: Panel[], newClones: Panel[][]): void {\n    this.panels = newPanels;\n    this.clones = newClones;\n\n    this.range = {\n      min: findIndex(newPanels, panel => Boolean(panel)),\n      max: newPanels.length - 1,\n    };\n    this.length = newPanels.filter(panel => Boolean(panel)).length;\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.cloneCount;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      removingPanels.forEach(panel => panel.removeElement());\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n    }\n  }\n\n  public setCloneCount(cloneCount: number): void {\n    this.cloneCount = cloneCount;\n  }\n\n  public append(newPanels: Panel[]): void {\n    const range = this.range;\n    this.panels.push(...newPanels);\n\n    if (newPanels.length > 0) {\n      range.min = Math.max(0, range.min);\n      range.max += newPanels.length;\n      this.length += newPanels.length;\n    }\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        removedPanels.forEach(panel => panel.removeElement());\n        this.length -= removedPanels.length;\n\n        // Find first\n        const newLastIndex = lastIndex - findIndex(this.panels.concat().reverse(), panel => !!panel);\n\n        // Can be filled with empty after newLastIndex\n        this.panels.splice(newLastIndex + 1);\n        this.range.max = newLastIndex;\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): void {\n    const panels = this.panels;\n    const range = this.range;\n    const isCircular = this.options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    this.insertNewPanels(newPanels, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n    replacedPanels.forEach(panel => {\n      if (panel) {\n        panel.removeElement();\n      }\n    });\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    deletedPanels.forEach(panel => {\n      panel.removeElement();\n    });\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 0) {\n      return;\n    }\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanelsCount - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanelsCount - 1];\n\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  // Clear both original & cloned\n  public clear(): void {\n    this.panels.forEach(panel => {\n      panel.removeElement();\n    });\n\n    this.panels = [];\n    this.clones = [];\n    this.length = 0;\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n  }\n\n  public clearClone(): void {\n    this.panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(0);\n    });\n    this.clones = [];\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels) {\n      if (panel && panel.getIndex() >= index) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        if (!this.options.renderExternal) {\n          cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        }\n\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n\n  private insertNewPanels(newPanels: Panel[], siblingElement: HTMLElement | null) {\n    if (!this.options.renderExternal) {\n      const fragment = document.createDocumentFragment();\n      newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n      this.cameraElement.insertBefore(fragment, siblingElement);\n    }\n  }\n}\n\nexport default PanelManager;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public lastPosition: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.lastPosition = prevState.lastPosition;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.lastPosition = 0;\n  }\n\n  public onHold(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      if (viewport.options.infinite) {\n        viewport.moveCamera(viewport.getCameraPosition(), e);\n      }\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    this.lastPosition = viewport.getCameraPosition();\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: clickedPanel,\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS, MOVE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const moveType = viewport.moveType;\n    const isFreeScroll = moveType.is(MOVE_TYPE.FREE_SCROLL);\n    const inputEvent = e.inputEvent;\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = horizontal\n      ? inputEvent.deltaX\n      : inputEvent.deltaY;\n    const isNextDirection = Math.abs(velocity) > 1\n      ? velocity < 0\n      : Math.abs(delta) > 0\n        ? delta > 0\n        : inputDelta < 0;\n\n    const swipeDistance = Math.max(Math.abs(delta), Math.abs(inputDelta));\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    const targetPanel = this.targetPanel;\n    if (!overThreshold && targetPanel) {\n      // Interrupted while animating\n      const destPos = isFreeScroll\n        ? e.destPos.flick\n        : viewport.findEstimatedPosition(targetPanel);\n      viewport.moveTo(targetPanel, destPos, \"\", e);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    const moveTypeContext = {\n      viewport,\n      axesEvent: e,\n      swipeDistance,\n      isNextDirection,\n    };\n\n    const destInfo = overThreshold\n      ? moveType.findTargetPanel(moveTypeContext)\n      : moveType.findRestorePanel(moveTypeContext);\n\n    viewport.moveTo(\n      destInfo.panel,\n      destInfo.destPos,\n      destInfo.eventType,\n      e,\n      destInfo.duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n}\n\nexport default DraggingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    const options = viewport.options;\n    const scrollArea = viewport.getScrollArea();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const loopCount = Math.floor((this.lastPosition + this.delta - scrollArea.prev) / scrollAreaSize);\n\n    const targetPanel = this.targetPanel;\n    if (options.circular && loopCount !== 0 && targetPanel) {\n      const cloneCount = viewport.panelManager.getCloneCount();\n      const originalTargetPosition = targetPanel.getPosition();\n\n      // cloneIndex is from -1 to cloneCount - 1\n      const newCloneIndex = circulate(targetPanel.getCloneIndex() - loopCount, -1, cloneCount - 1, true);\n      const newTargetPosition = originalTargetPosition - loopCount * scrollAreaSize;\n      const newTargetPanel = targetPanel.getIdenticalPanels()[newCloneIndex + 1].clone(newCloneIndex, true);\n\n      // Set new target panel considering looped count\n      newTargetPanel.setPosition(newTargetPosition);\n      this.targetPanel = newTargetPanel;\n    }\n\n    // Reset last position and delta\n    this.delta = 0;\n    this.lastPosition = viewport.getCameraPosition();\n\n    // Update current panel as current nearest panel\n    viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n\n    viewport.options.bound\n      ? viewport.setCurrentPanel(this.targetPanel!)\n      : viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    transitTo(STATE_TYPE.IDLE);\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted, {\n      direction: this.direction,\n    });\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n  }\n}\n\nexport default AnimatingState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(e: any, { viewport, transitTo }: FlickingContext): void {\n    // Can stop Axes's change event\n    e.stop();\n\n    // Should update axes position as it's already changed at this moment\n    viewport.updateAxesPosition(viewport.getCameraPosition());\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { MoveTypeStringOption, MoveTypeContext, DestinationInfo } from \"../types\";\nimport Panel from \"../components/Panel\";\nimport { EVENTS } from \"../consts\";\n\nabstract class MoveType {\n  protected readonly abstract type: string;\n\n  public abstract findTargetPanel(ctx: MoveTypeContext): DestinationInfo;\n\n  public is(type: MoveTypeStringOption): boolean {\n    return type === this.type;\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    const viewport = ctx.viewport;\n    const options = viewport.options;\n\n    const panel = options.circular\n      ? this.findRestorePanelInCircularMode(ctx)\n      : viewport.getCurrentPanel()!;\n\n    return {\n      panel,\n      destPos: viewport.findEstimatedPosition(panel),\n      duration: options.duration,\n      eventType: EVENTS.RESTORE,\n    };\n  }\n\n  // Calculate minimum distance to \"change\" panel\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const relativeAnchorPosition = currentPanel.getRelativeAnchorPosition();\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - relativeAnchorPosition + halfGap\n      : relativeAnchorPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n\n  private findRestorePanelInCircularMode(ctx: MoveTypeContext): Panel {\n    const viewport = ctx.viewport;\n    const originalPanel = viewport.getCurrentPanel()!.getOriginalPanel();\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = originalPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(originalPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    return (!ctx.isNextDirection && lapped)\n      ? firstClonedPanel\n      : originalPanel;\n  }\n}\n\nexport default MoveType;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport MoveType from \"./MoveType\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { clamp } from \"../utils\";\n\nclass Snap extends MoveType {\n  protected readonly type: string = MOVE_TYPE.SNAP;\n  protected count: number;\n\n  constructor(count: number) {\n    super();\n    this.count = count;\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, axesEvent, swipeDistance } = ctx;\n    const snapCount = this.count;\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const currentPanel = viewport.getCurrentPanel()!;\n    const nearestPanel = viewport.getNearestPanel()!;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n\n    // This can happen when bounce is 0\n    const shouldMoveWhenBounceIs0 = viewport.canSetBoundMode()\n      && (nearestPanel.getIndex() === currentPanel.getIndex());\n    const shouldMoveToAdjacent = !viewport.isOutOfBound()\n      && (swipeDistance <= minimumDistanceToChange || shouldMoveWhenBounceIs0);\n\n    if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n      return this.findSnappedPanel(ctx);\n    } else if (shouldMoveToAdjacent) {\n      return this.findAdjacentPanel(ctx);\n    } else {\n      return {\n        panel: nearestPanel,\n        duration: viewport.options.duration,\n        destPos: viewport.findEstimatedPosition(nearestPanel),\n        eventType: swipeDistance <= minimumDistanceToChange\n          ? EVENTS.RESTORE\n          : EVENTS.CHANGE,\n      };\n    }\n  }\n\n  protected findSnappedPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, isNextDirection } = ctx;\n\n    const snapCount = this.count;\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = axesEvent.destPos.flick + viewport.getRelativeHangerPosition();\n    let panelToMove = viewport.getNearestPanel()!;\n    let cycleIndex = panelToMove.getCloneIndex() + 1; // 0(original) or 1(clone)\n    let passedPanelCount = 0;\n\n    while (passedPanelCount < snapCount) {\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n\n      // Since panlToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      const panelNextPosition = panelPosition + panelSize + halfGap;\n      const panelPrevPosition = panelPosition - halfGap;\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && panelNextPosition > estimatedHangerPos)\n        || (!isNextDirection && panelPrevPosition < estimatedHangerPos)\n      ) {\n        break;\n      }\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n\n    panelToMove = panelToMove.clone(panelToMove.getCloneIndex(), true);\n    panelToMove.setPosition(originalPosition + cycleIndex * scrollAreaSize);\n\n    const defaultDuration = viewport.options.duration;\n    const duration = clamp(axesEvent.duration, defaultDuration, defaultDuration * passedPanelCount);\n\n    return {\n      panel: panelToMove,\n      destPos: viewport.findEstimatedPosition(panelToMove),\n      duration,\n      eventType: passedPanelCount > 0\n        ? EVENTS.CHANGE\n        : EVENTS.RESTORE,\n    };\n  }\n\n  private findAdjacentPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n    const basePosition = basePanel.getPosition();\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const eventType = adjacentPanel\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n    const targetRelativeAnchorPosition = panelToMove.getRelativeAnchorPosition();\n\n    const estimatedPanelPosition = options.circular\n      ? isNextDirection\n        ? basePosition + basePanel.getSize() + targetRelativeAnchorPosition + options.gap\n        : basePosition - (panelToMove.getSize() - targetRelativeAnchorPosition) - options.gap\n      : panelToMove.getAnchorPosition();\n    const estimatedPosition = estimatedPanelPosition - viewport.getRelativeHangerPosition();\n\n    return {\n      panel: panelToMove,\n      destPos: estimatedPosition,\n      duration: options.duration,\n      eventType,\n    };\n  }\n}\n\nexport default Snap;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Snap from \"./Snap\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass FreeScroll extends Snap {\n  protected readonly type: string = MOVE_TYPE.FREE_SCROLL;\n\n  constructor() {\n    // Set snap count to Infinity\n    super(Infinity);\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, swipeDistance } = ctx;\n    const destPos = axesEvent.destPos.flick;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    if (eventDelta > minimumDistanceToChange) {\n      const destInfo = super.findSnappedPanel(ctx);\n      destInfo.destPos = destPos;\n      destInfo.eventType = destInfo.eventType === EVENTS.RESTORE\n        ? \"\"\n        : EVENTS.CHANGE;\n\n      return destInfo;\n    } else {\n      const scrollArea = viewport.getScrollArea();\n      const estimatedPosition = circulate(destPos, scrollArea.prev, scrollArea.next, false)\n        + viewport.getRelativeHangerPosition();\n\n      return {\n        panel: viewport.findNearestPanelAt(estimatedPosition)!,\n        destPos,\n        duration: viewport.options.duration,\n        eventType: swipeDistance > minimumDistanceToChange\n          ? EVENTS.CHANGE\n          : \"\",\n      };\n    }\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    return this.findTargetPanel(ctx);\n  }\n\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const lastPosition = viewport.stateMachine.getState().lastPosition;\n    const currentPanelPosition = currentPanel.getPosition();\n\n    // As camera can stop anywhere in free scroll mode,\n    // minimumDistanceToChange should be calculated differently.\n    // Ref #191(https://github.com/naver/egjs-flicking/issues/191)\n    const lastHangerPosition = lastPosition + viewport.getRelativeHangerPosition();\n\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanelPosition + currentPanel.getSize() - lastHangerPosition + halfGap\n      : lastHangerPosition - currentPanelPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n}\n\nexport default FreeScroll;\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport MoveType from \"../moves/MoveType\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption, OriginalStyle, Plugin } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE, MOVE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement, hasClass, restoreStyle } from \"../utils\";\nimport Snap from \"../moves/Snap\";\nimport FreeScroll from \"../moves/FreeScroll\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n  public moveType: MoveType;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: {[key: string]: any};\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n\n  private plugins: Plugin[] = [];\n  private state: {\n    size: number;\n    position: number;\n    relativeHangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n    isViewportGiven: boolean;\n    isCameraGiven: boolean;\n    originalViewportStyle: OriginalStyle;\n    originalCameraStyle: OriginalStyle;\n  };\n\n  constructor(\n    flicking: Flicking,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      relativeHangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n      isViewportGiven: false,\n      isCameraGiven: false,\n      originalViewportStyle: {\n        className: null,\n        style: null,\n      },\n      originalCameraStyle: {\n        className: null,\n        style: null,\n      },\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    destPos: number,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | \"\",\n    axesEvent: any,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const currentPosition = state.position;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = destPos === currentPosition\n      ? null\n      : destPos > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel,\n        direction,\n      });\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      currentState.delta = 0;\n      currentState.lastPosition = this.getCameraPosition();\n      currentState.targetPanel = panel;\n      currentState.direction = destPos === currentPosition\n        ? null\n        : destPos > currentPosition\n            ? DIRECTION.NEXT\n            : DIRECTION.PREV;\n\n      if (destPos === currentPosition) {\n        // no move\n        this.nearestPanel = panel;\n        this.currentPanel = panel;\n      }\n\n      if (axesEvent && axesEvent.setTo) {\n        // freeScroll only occurs in release events\n        axesEvent.setTo({ flick: destPos }, duration);\n      } else {\n        this.axes.setTo({ flick: destPos }, duration);\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n\n    // Update position & nearestPanel\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    const moveVector = options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public resize(): void {\n    const panelManager = this.panelManager;\n\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n\n    panelManager.chainAllPanels();\n    this.updateCameraPosition();\n    this.updatePlugins();\n  }\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const hangerPosition = this.getHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n\n      return position <= state.scrollArea.prev\n        ? panelManager.firstPanel()\n        : panelManager.lastPanel();\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      } else if (distance === minimumDistance) {\n        const minimumAnchorDistance = Math.abs(position - nearestPanel!.getAnchorPosition());\n        const anchorDistance = Math.abs(position - panel.getAnchorPosition());\n\n        if (anchorDistance > minimumAnchorDistance) {\n          break;\n        }\n      }\n\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public findEstimatedPosition(panel: Panel): number {\n    const scrollArea = this.getScrollArea();\n\n    let estimatedPosition = panel.getAnchorPosition() - this.getRelativeHangerPosition();\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return estimatedPosition;\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index });\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    this.resize();\n\n    return panels;\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    panelManager.replace(index, panels);\n\n    const currentPanel = this.currentPanel;\n    const wasEmpty = !currentPanel;\n    if (wasEmpty) {\n      this.currentPanel = panels[0];\n    } else if (isBetween(currentPanel!.getIndex(), index, index + panels.length - 1)) {\n      // Current panel is replaced\n      this.currentPanel = panelManager.get(currentPanel!.getIndex());\n    }\n\n    // Update checked indexes in infinite mode\n    this.updateCheckedIndexes({ min: index, max: index + panels.length - 1 });\n\n    this.resize();\n\n    const isFreeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n    if (isFreeScroll && wasEmpty) {\n      this.moveTo(this.currentPanel!, this.findEstimatedPosition(this.currentPanel!), \"\", null, 0);\n    }\n\n    return panels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n\n    // Update checked indexes in infinite mode\n    if (deleteCount > 0) {\n      // Check whether removing index will affect checked indexes\n      // Suppose index 0 is empty and removed index 1, then checked index 0 should be deleted and vice versa.\n      this.updateCheckedIndexes({ min: index - 1, max: index + deleteCount });\n    }\n\n    this.resize();\n\n    return removedPanels;\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    let sizeToApply: number;\n    if (options.adaptive) {\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const state = this.state;\n    const wrapper = this.flicking.getElement();\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const originalPanels = this.panelManager.originalPanels();\n\n    this.removePlugins(this.plugins);\n    restoreStyle(viewportElement, state.originalViewportStyle);\n    restoreStyle(cameraElement, state.originalCameraStyle);\n\n    if (!state.isCameraGiven && !this.options.renderExternal) {\n      const topmostElement = state.isViewportGiven\n        ? viewportElement\n        : wrapper;\n      const deletingElement = state.isViewportGiven\n        ? cameraElement\n        : viewportElement;\n\n      originalPanels.forEach(panel => {\n        topmostElement.appendChild(panel.getElement());\n      });\n\n      topmostElement.removeChild(deletingElement);\n    }\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    originalPanels.forEach(panel => { panel.destroy(); });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const defaultIndex = this.options.defaultIndex;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    panelManager.clear();\n    cameraElement.innerHTML = status.panels.map(panel => panel.html).join(\"\");\n\n    this.createPanels();\n\n    // Reset panel index\n    panelManager.originalPanels().forEach((panel, idx) => {\n      panel.setIndex(panels[idx].index);\n    });\n\n    this.currentPanel = panelManager.get(status.index)\n      || panelManager.get(defaultIndex)\n      || panelManager.firstPanel();\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    const currentState = this.stateMachine.getState();\n    let nearestPanel = currentState.playing || currentState.holding\n      ? this.nearestPanel\n      : this.currentPanel;\n\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const {prev: prevRange, next: nextRange} = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : basePosition = nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  // Update axes flick position without triggering event\n  public updateAxesPosition(position: number) {\n    const axes = this.axes;\n    axes.off();\n    axes.setTo({\n      flick: position,\n    }, 0);\n    axes.on(this.axesHandlers);\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const scrollArea = state.scrollArea;\n\n    return !options.circular\n      && options.bound\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n\n  public canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const lastPanel = this.panelManager.lastPanel();\n    if (!lastPanel) {\n      return false;\n    }\n\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  public getViewportElement(): HTMLElement {\n    return this.viewportElement;\n  }\n\n  public getCameraElement(): HTMLElement {\n    return this.cameraElement;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public getCheckedIndexes(): Array<[number, number]> {\n    return this.state.checkedIndexes;\n  }\n\n  public setCurrentPanel(panel: Panel): void {\n    this.currentPanel = panel;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public connectAxesHandler(handlers: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this.flicking);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this.flicking);\n    });\n    return this;\n  }\n  public updateCheckedIndexes(changedRange: { min: number, max: number }): void {\n    const state = this.state;\n\n    let removed = 0;\n    state.checkedIndexes.concat().forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (changedRange.min <= max && changedRange.max >= min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx - removed, 1);\n        removed++;\n      }\n    });\n  }\n\n  private build(): void {\n    this.setElements();\n    this.applyCSSValue();\n    this.setMoveType();\n    this.setAxesInstance();\n    this.createPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private setElements(): void {\n    const state = this.state;\n    const options = this.options;\n    const wrapper = this.flicking.getElement();\n    const classPrefix = options.classPrefix;\n\n    const viewportCandidate = wrapper.children[0] as HTMLElement;\n    const hasViewportElement = hasClass(viewportCandidate, `${classPrefix}-viewport`);\n\n    const viewportElement = hasViewportElement\n      ? viewportCandidate\n      : document.createElement(\"div\");\n\n    const cameraCandidate = hasViewportElement\n      ? viewportElement.children[0] as HTMLElement\n      : wrapper.children[0] as HTMLElement;\n    const hasCameraElement = hasClass(cameraCandidate, `${classPrefix}-camera`);\n\n    const cameraElement = hasCameraElement\n      ? cameraCandidate\n      : document.createElement(\"div\");\n\n    if (!hasCameraElement) {\n      cameraElement.className = `${classPrefix}-camera`;\n\n      const panelElements = hasViewportElement\n        ? viewportElement.children\n        : wrapper.children;\n\n      // Make all panels to be a child of camera element\n      // wrapper <- viewport <- camera <- panels[1...n]\n      toArray(panelElements).forEach(child => {\n        cameraElement.appendChild(child);\n      });\n    } else {\n      state.originalCameraStyle = {\n        className: cameraElement.getAttribute(\"class\"),\n        style: cameraElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasViewportElement) {\n      viewportElement.className = `${classPrefix}-viewport`;\n\n      // Add viewport element to wrapper\n      wrapper.appendChild(viewportElement);\n    } else {\n      state.originalViewportStyle = {\n        className: viewportElement.getAttribute(\"class\"),\n        style: viewportElement.getAttribute(\"style\"),\n      };\n    }\n\n    if (!hasCameraElement || !hasViewportElement) {\n      viewportElement.appendChild(cameraElement);\n    }\n\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    state.isViewportGiven = hasViewportElement;\n    state.isCameraGiven = hasCameraElement;\n\n    // Create PanelManager instance\n    this.panelManager = new PanelManager(cameraElement, options);\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n\n    // Set default css values for each element\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setMoveType(): void {\n    const moveType = this.options.moveType as MoveTypeObjectOption;\n\n    switch (moveType.type) {\n      case MOVE_TYPE.SNAP:\n        this.moveType = new Snap(moveType.count);\n        break;\n      case MOVE_TYPE.FREE_SCROLL:\n        this.moveType = new FreeScroll();\n        break;\n      default:\n        throw new Error(\"moveType is not correct!\");\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this),\n    );\n\n    if (panels.length > 0) {\n      this.panelManager.append(panels);\n    }\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + this.options.gap;\n    const visibleAreaSize = viewportSize + firstPanel.getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    if (options.renderExternal) {\n      panelManager.setCloneCount(cloneCount);\n      return;\n    }\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n\n          this.cameraElement.appendChild(clonedPanel.getElement());\n\n          return clonedPanel;\n        });\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const panels = this.panelManager.originalPanels();\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n    state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n\n    // Resize all panels\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n    const scrollArea = this.state.scrollArea;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if (nearestPanel) {\n      // We should maintain nearestPanel's position\n      const looped = !isBetween(currentState.lastPosition + currentState.delta, scrollArea.prev, scrollArea.next);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const currentPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      if (currentPosition !== newPosition) {\n        panel.setPosition(newPosition);\n      }\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .reduce((allClones, clones) => [...allClones, ...clones], [])\n      .filter(panel => Boolean(panel));\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  // Update camera position after resizing\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.stateMachine.getState();\n    const isFreeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n\n    if (currentState.holding || currentState.playing || isFreeScroll) {\n      return;\n    }\n\n    let newPosition = currentPanel\n      ? currentPanel.getAnchorPosition() - state.relativeHangerPosition\n      : this.getCameraPosition();\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.updateAxesPosition(newPosition);\n\n    this.moveCamera(newPosition);\n  }\n\n  private updatePlugins(): void {\n    // update for resize\n    this.plugins.forEach(plugin => {\n      plugin.update && plugin.update(this.flicking);\n    });\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        siblingPanel: null,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      const lastPanel = panelManager.lastPanel()!;\n      const atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel();\n        const firstIndex = firstPanel\n          ? firstPanel.getIndex()\n          : -1;\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels are changed\n      const lastPanelAfterNeed = panelManager.lastPanel()!;\n      const atLastPanelAfterNeed = lastPanelAfterNeed && currentIndex === lastPanelAfterNeed.getIndex();\n\n      if (atLastPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      const firstPanel = panelManager.firstPanel()!;\n      const atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel();\n\n        if (lastPanel && lastPanel.getIndex() < maxLastIndex) {\n          const lastIndex = lastPanel.getIndex();\n\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether panels were changed\n      const firstPanelAfterNeed = panelManager.firstPanel();\n      const atFirstPanelAfterNeed = firstPanelAfterNeed && checkingIndex === firstPanelAfterNeed.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanelAfterNeed || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    siblingPanel: Panel | null,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, siblingPanel, direction, indexRange } = params;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const index = siblingPanel\n      ? siblingPanel.getIndex()\n      : 0;\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel: siblingPanel,\n        direction,\n        range: indexRange,\n      } as Partial<NeedPanelEvent>,\n    );\n  }\n}\n","/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\nimport Panel from \"./components/Panel\";\n\nimport { merge, getProgress, parseElement, isString, counter } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin, ElementLike } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event type object\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options An option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix of class name will be added for the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation for animation triggered by manual user input. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for continuous scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\n   * @param {boolean} [options.infinite=false] Enables infinite mode, which can automatically trigger needPanel until reaching last panel's index reaches lastIndex<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\n   * @param {number} [options.infiniteThreshold=0] A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\n   * @param {number} [options.lastIndex=Infinity] Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when event's panel index is greater than it.<br>Also, if last panel's index reached given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold angle value(0 ~ 90).<br>If input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\n   * @param {boolean} [options.autoResize=false] Whether resize() method should be called automatically after window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\n   * @param {boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\n   * @param {boolean} [options.bound=false] Prevent view from going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Reference position of hanger in viewport, which hangs panel anchors should be stopped at.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Reference position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels. Should be given in number.(px).<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\n   * @param {eg.Flicking.MoveTypeOption} [options.moveType=\"snap\"] Movement style by user input.(ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\n   */\n  constructor(\n    element: string | HTMLElement,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, this.options, this.triggerEvent);\n    this.listenInput();\n    this.listenResize();\n  }\n\n  /**\n   * Move to the previous panel if it exists.\n   * @ko 이전 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public prev(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const prevPanel = currentPanel.prev();\n      if (prevPanel) {\n        prevPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel if it exists.\n   * @ko 다음 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation(unit: ms).<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public next(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (currentPanel && currentState.type === STATE_TYPE.IDLE) {\n      const nextPanel = currentPanel.next();\n      if (nextPanel) {\n        nextPanel.focus(duration);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the panel of given index.\n   * @ko 주어진 인덱스에 해당하는 패널로 이동한다.\n   * @param index The index number of the panel to move.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let targetPanel = panel;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity) - panel.getRelativeAnchorPosition();\n\n      const identicals = panel.getIdenticalPanels();\n      const offset = nearestPosition - anchorPosition;\n      if (offset > 0) {\n        // First cloned panel is nearest\n        targetPanel = identicals[1];\n      } else if (offset < 0) {\n        // Last cloned panel is nearest\n        targetPanel = identicals[identicals.length - 1];\n      }\n\n      targetPanel = targetPanel.clone(targetPanel.getCloneIndex(), true);\n      targetPanel.setPosition(nearestPosition);\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === targetPanel.getAnchorPosition() && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      targetPanel,\n      viewport.findEstimatedPosition(targetPanel),\n      eventType,\n      null,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Return index of the current panel. `-1` if no panel exists.\n   * @ko 현재 패널의 인덱스 번호를 반환한다. 패널이 하나도 없을 경우 `-1`을 반환한다.\n   * @return Current panel's index, zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Return the wrapper element user provided in constructor.\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트.</ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Return current panel. `null` if no panel exists.\n   * @ko 현재 패널을 반환한다. 패널이 하나도 없을 경우 `null`을 반환한다.\n   * @return Current panel.<ko>현재 패널.</ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return the panel of given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 패널을 반환한다. 해당 패널이 존재하지 않을 시 `null`이다.\n   * @return Panel of given index.<ko>주어진 인덱스에 해당하는 패널.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return all panels.\n   * @ko 모든 패널들을 반환한다.\n   * @param - Should include cloned panels or not.<ko>복사된 패널들을 포함할지의 여부.</ko>\n   * @return All panels.<ko>모든 패널들.</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel);\n  }\n\n  /**\n   * Return the panels currently shown in viewport area.\n   * @ko 현재 뷰포트 영역에서 보여지고 있는 패널들을 반환한다.\n   * @return Panels currently shown in viewport area.<ko>현재 뷰포트 영역에 보여지는 패널들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(panel => {\n      const outsetProgress = panel.getOutsetProgress();\n\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n\n  /**\n   * Return length of original panels.\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Return how many groups of clones are created.\n   * @ko 몇 개의 클론 그룹이 생성되었는지를 반환한다.\n   * @return Length of cloned panel groups.<ko>클론된 패널 그룹의 개수</ko>\n   */\n  public getCloneCount(): number {\n    return this.viewport.panelManager.getCloneCount();\n  }\n\n  /**\n   * Get maximum panel index for `infinite` mode.\n   * @ko `infinite` 모드에서 적용되는 추가 가능한 패널의 최대 인덱스 값을 반환한다.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return Maximum index of panel that can be added.<ko>최대 추가 가능한 패널의 인덱스.</ko>\n   */\n  public getLastIndex(): number {\n    return this.viewport.panelManager.getLastIndex();\n  }\n\n  /**\n   * Set maximum panel index for `infinite' mode.<br>[needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it.<br>Also, you can't add more panels after it.\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다.<br>마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다.<br>또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\n   * @param - Maximum panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public setLastIndex(index: number): this {\n    this.viewport.setLastIndex(index);\n\n    return this;\n  }\n\n  /**\n   * Return panel movement animation.\n   * @ko 현재 패널 이동 애니메이션이 진행 중인지를 반환한다.\n   * @return Is animating or not.<ko>애니메이션 진행 여부.</ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * Unblock input devices.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * Block input devices.\n   * @ko 입력 장치로부터의 입력을 막는다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to [setStatus()]{@link eg.Flicking#setStatus}.\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있다.\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus(): FlickingStatus {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`의 상태로 복원한다.\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking.\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add.<ko>추가할 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.addPlugins(plugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    this.viewport.removePlugins(plugins);\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * Update panels to current state.\n   * @ko 패널들을 현재 상태에 맞춰 갱신한다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public resize(): this {\n    const viewport = this.viewport;\n\n    viewport.panelManager.allPanels()\n      .forEach(panel => panel.unCacheBbox());\n    viewport.resize();\n\n    return this;\n  }\n\n  /**\n   * Add new panels at the beginning of panels.\n   * @ko 제일 앞에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 0, pushing every panels behind it.\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  }\n\n  /**\n   * Add new panels at the end of panels.\n   * @ko 제일 끝에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  }\n\n  /**\n   * Replace existing panels with new panels from given index. If target index is empty, add new panel at target index.\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.replace(index, element);\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  /**\n   * Synchronize info of panels instance with info given by external rendering.\n   * @ko 외부 렌더링 방식에 의해 입력받은 패널의 정보와 현재 플리킹이 갖는 패널 정보를 동기화한다.\n   * @param diffInfo - Info object of how panel elements are changed.<ko>패널의 DOM 요소들의 변경 정보를 담는 오브젝트.</ko>\n   * @param {HTMLElement[]} [diffInfo.list] - DOM elements list after update.<ko>업데이트 이후 DOM 요소들의 리스트</ko>\n   * @param {number[][]} [diffInfo.maintained] - Index tuple array of DOM elements maintained. Formatted with `[before, after]`.<ko>변경 전후에 유지된 DOM 요소들의 인덱스 튜플 배열. `[이전, 이후]`의 형식을 갖고 있어야 한다.</ko>\n   * @param {number[]} [diffInfo.added] - Index array of DOM elements added to `list`.<ko>`list`에서 추가된 DOM 요소들의 인덱스 배열.</ko>\n   * @param {number[]} [diffInfo.removed] - Index array of DOM elements removed from previous element list.<ko>이전 리스트에서 제거된 DOM 요소들의 인덱스 배열.</ko>\n   */\n  public sync(diffInfo: {\n    list: HTMLElement[],\n    maintained: number[][],\n    added: number[],\n    changed: number[][],\n    removed: number[],\n  }): this {\n    const { list, maintained, added, changed, removed } = diffInfo;\n\n    // Did not changed at all\n    if (added.length <= 0 && removed.length <= 0 && changed.length <= 0) {\n      return this;\n    }\n\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const indexRange = panelManager.getRange();\n    const isCircular = this.options.circular;\n\n    // Make sure that new \"list\" should include cloned elements\n    const newOriginalPanelCount = (list.length / (panelManager.getCloneCount() + 1)) >> 0; // Make sure it's integer. Same with Math.floor, but faster\n    const newCloneCount = ((list.length / newOriginalPanelCount) >> 0) - 1;\n\n    const prevOriginalPanels = panelManager.originalPanels();\n    const prevClonedPanels = panelManager.clonedPanels();\n\n    const newOriginalElements = list.slice(0, newOriginalPanelCount);\n    const newClonedElements = list.slice(newOriginalPanelCount);\n\n    const newPanels: Panel[] = [];\n    const newClones: Panel[][] = counter(newCloneCount).map(() => []);\n\n    // For maintained panels after external rendering, they should be maintained in newPanels.\n    const originalMaintained = maintained.filter(([beforeIdx, afterIdx]) => beforeIdx <= indexRange.max);\n    // For newly added panels after external rendering, they will be added with their elements.\n    const originalAdded = added.filter(index => index < newOriginalPanelCount);\n\n    originalMaintained.forEach(([beforeIdx, afterIdx]) => {\n      newPanels[afterIdx] = prevOriginalPanels[beforeIdx];\n      newPanels[afterIdx].setIndex(afterIdx);\n    });\n\n    originalAdded.forEach(addIndex => {\n      newPanels[addIndex] = new Panel(newOriginalElements[addIndex], addIndex, viewport);\n    });\n\n    if (isCircular) {\n      counter(newCloneCount).forEach(groupIndex => {\n        const cloneGroupOffset = newOriginalPanelCount * groupIndex;\n        const prevCloneGroup = prevClonedPanels[groupIndex];\n        const newCloneGroup = newClones[groupIndex];\n\n        originalMaintained.forEach(([beforeIdx, afterIdx]) => {\n          newCloneGroup[afterIdx] = prevCloneGroup\n            ? prevCloneGroup[beforeIdx]\n            : newPanels[afterIdx].cloneExternal(groupIndex, newClonedElements[cloneGroupOffset + afterIdx]);\n        });\n\n        originalAdded.forEach(addIndex => {\n          const newPanel = newPanels[addIndex];\n\n          newCloneGroup[addIndex] = newPanel.cloneExternal(groupIndex, newClonedElements[cloneGroupOffset + addIndex]);\n        });\n      });\n    }\n\n    // Replace current info of panels this holds\n    added.forEach(index => { viewport.updateCheckedIndexes({ min: index, max: index }); });\n    removed.forEach(index => { viewport.updateCheckedIndexes({ min: index - 1, max: index + 1 }); });\n\n    const checkedIndexes = viewport.getCheckedIndexes();\n    checkedIndexes.forEach(([min, max], idx) => {\n      // Push checked indexes backward\n      const pushedIndex = added.filter(index => index < min && panelManager.has(index)).length\n        - removed.filter(index => index < min).length;\n      checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n    });\n\n    // Only effective only when there are least one panel which have changed its index\n    if (changed.length > 0) {\n      // Removed checked index by changed ones after pushing\n      maintained.forEach(([prev, next]) => { viewport.updateCheckedIndexes({ min: next, max: next }); });\n    }\n\n    panelManager.replacePanels(newPanels, newClones);\n    this.resize();\n\n    return this;\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params));\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = (cameraChange > 0 ? -1 : 1) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.direction = currentDirection;\n    }\n    state.delta += axesEvent.delta.flick;\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n}\n\nexport default Flicking;\n","import Flicking from \"./Flicking\";\nimport { withFlickingMethods } from \"./utils\";\nimport { DEFAULT_OPTIONS, MOVE_TYPE } from \"./consts\";\n\n(Flicking as any).withFlickingMethods = withFlickingMethods;\n(Flicking as any).DEFAULT_OPTIONS = DEFAULT_OPTIONS;\n(Flicking as any).MOVE_TYPE = MOVE_TYPE;\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","element","Array","isArray","elements","el","isString","tempDiv","document","createElement","innerHTML","push","toArray","children","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","classList","className","split","add","indexOf","replace","cssObj","property","val","min","max","Math","iterable","slice","call","arr","constructor","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","callback","i","counterArray","indexed","size","offset","classes","findIndex","originalStyle","setAttribute","removeAttribute","prototype","flickingName","FLICKING_METHODS","args","result","_a","MOVE_TYPE","SNAP","FREE_SCROLL","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","renderExternal","DEFAULT_VIEWPORT_CSS","position","width","height","DEFAULT_CAMERA_CSS","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","IDLE","HOLDING","DRAGGING","ANIMATING","DISABLED","DIRECTION","PREV","NEXT","prev","next","moveTo","getIndex","getAllPanels","getCurrentPanel","getElement","getPanel","getPanelCount","getStatus","getVisiblePanels","setLastIndex","enableInput","disableInput","destroy","resize","setStatus","addPlugins","removePlugins","isPlaying","getLastIndex","TRANSFORM","index","viewport","prevSibling","nextSibling","clonedPanels","state","relativeAnchorPosition","isClone","isVirtual","cloneIndex","getAttribute","cachedBbox","setElement","options","bbox","getBbox","parseArithmeticExpression","panel","panelCount","panelManager","scrollAreaSize","getScrollAreaSize","relativeIndex","floor","getPosition","progress","getCurrentProgress","outsetRange","getSize","getRelativeHangerPosition","getRelativeAnchorPosition","relativePanelPosition","getCameraPosition","outsetProgress","getProgress","panelSize","rightRelativePanelPosition","visibleSize","visibleRatio","currentPanel","hangerPosition","getHangerPosition","anchorPosition","getAnchorPosition","currentPosition","eventType","findEstimatedPosition","updateFunction","getIdenticalPanels","eachPanel","unCacheBbox","currentIndex","prevPanelIndex","prevPanelPosition","prevPanelSize","hasEmptyPanelBetween","notYetMinPanel","newPosition","prevPanel","clone","getCloneIndex","setPosition","nextPanelIndex","nextPanelPosition","notYetMaxPanel","nextPanel","parsedElements","parseElement","firstPanel","targetIndex","insert","remove","restoreStyle","getBoundingClientRect","original","getClonedPanels","elementStyle","left","top","cloneElement","cloneNode","clonedPanel","Panel","clonedState","parentNode","removeClonedPanelsAfter","start","removingPanels","splice","removeElement","addClass","applyCSS","cameraElement","panels","clones","cloneCount","reduce","allClones","newPanels","newClones","Boolean","filter","lastPanel","firstRemovedPanel","possibleLastPanel","isCircular","findFirstPanelFrom","siblingElement","insertNewPanels","pushedIndex","panelsAfterIndex","emptyPanelCount","removedPanels","newLastIndex","concat","reverse","setIndex","addNewClones","updateIndex","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","cloneSet","reversedPanels","nonEmptyIndexFromLast","allPanels","allPanelsCount","newClones_1","insertTarget_1","allPanels_1","panelElement","contains","originalPanels","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","map","_this","this_1","insertClones","counter","insertingIndex","fragment_1","createDocumentFragment","appendChild","prevState","delta","direction","targetPanel","lastPosition","nextState","e","context","tslib_1","flicking","triggerEvent","transitTo","moveCamera","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","flick","setTo","releaseEvent","clickedElement","srcEvent","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","stopCamera","isFreeScroll","is","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","abs","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","destPos","nearestPanel","getNearestPanel","stop","moveTypeContext","axesEvent","destInfo","findTargetPanel","findRestorePanel","scrollArea","getScrollArea","loopCount","originalTargetPosition","newCloneIndex","circulate","newTargetPosition","newTargetPanel","setCurrentPanel","isTrusted","updateAdaptiveSize","updateAxesPosition","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onEnter","onHold","onRelease","onAnimationEnd","onFinish","ctx","findRestorePanelInCircularMode","halfGap","minimumDistanceToChange","originalPanel","getOriginalPanel","firstClonedPanel","lapped","_super","snapCount","eventDelta","calcBrinkOfChange","shouldMoveWhenBounceIs0","canSetBoundMode","shouldMoveToAdjacent","isOutOfBound","findSnappedPanel","findAdjacentPanel","estimatedHangerPos","panelToMove","cycleIndex","passedPanelCount","siblingPanel","panelIndex","siblingIndex","panelPosition","panelNextPosition","panelPrevPosition","originalPosition","defaultDuration","getCurrentIndex","get","basePanel","basePosition","adjacentPanel","targetRelativeAnchorPosition","estimatedPanelPosition","estimatedPosition","MoveType","findNearestPanelAt","stateMachine","getState","currentPanelPosition","lastHangerPosition","Snap","relativeHangerPosition","translate","checkedIndexes","isViewportGiven","isCameraGiven","originalViewportStyle","originalCameraStyle","StateMachine","build","eventResult","axes","findNearestPanel","originalNearestPosition","checkNeedPanel","modifiedNearestPosition","moveVector","moveCoord","coord","round","join","updateSize","updateOriginalPanelPositions","updateScrollArea","clonePanels","updateClonedPanelPositions","chainAllPanels","updateCameraPosition","updatePlugins","minimumDistance","prevPosition","nextPosition","distance","isBetween","minimumAnchorDistance","anchorDistance","nearest","shortestDistance","identicals","identical","panInput","enable","disable","updateCheckedIndexes","indexes","wasEmpty","newCurrentIndex","getRange","sizeToApply","panelBbox","maximumPanelSize","maximum","viewportStyle","viewportElement","minHeight","minWidth","wrapper","plugins","topmostElement_1","deletingElement","status","clear","html","createPanels","playing","holding","NaN","prevRange","nextRange","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","targetPosition","progressBetween","startIndex","off","on","axesHandlers","summedPanelSize","handlers","newPlugins","plugin","init","currentPlugins","removedPlugins","changedRange","removed","setElements","applyCSSValue","setMoveType","setAxesInstance","setDefaultPanel","moveToDefaultPanel","viewportCandidate","hasViewportElement","hasClass","cameraCandidate","hasCameraElement","panelElements","child","PanelManager","FreeScroll","Axes","easing","interruptable","PanInput","scale","connect","append","indexRange","viewportSize","sumOriginalPanelSize","visibleAreaSize","ceil","prevCloneCount","setCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","nextPanelPos","maintainingPanel","looped","panelsBeforeMaintainPanel","accumulatedSize","total","clonedPanels_1","cloneBasePos","clonedPanelPos","lastReplacePosition","_b","replacePosition","parsedBounce","parsedVal","axis","update","maxLastIndex","triggerNeedPanel","checkingPanel","atLastPanel","nextIndex","currentNearestPosition","panelRight","cameraNext","emptyPanelExistsBetween","firstIndex","lastPanelAfterNeed","atLastPanelAfterNeed","cameraPrev","checkingIndex","atFirstPanel","prevIndex","panelLeft","firstPanelAfterNeed","atFirstPanelAfterNeed","params","alreadyTriggered","some","hasHandler","hasOn","eventName","canceled","trigger","merge","previousPosition","inputOffset","cameraChange","currentDirection","querySelector","nodeName","nodeType","currentOptions","Viewport","listenInput","listenResize","focus","possiblePositions","nearestPosition","current","includeClone","getOutsetProgress","outerHTML","restore","diffInfo","list","maintained","added","changed","newOriginalPanelCount","newCloneCount","prevOriginalPanels","prevClonedPanels","newOriginalElements","newClonedElements","originalMaintained","beforeIdx","afterIdx","originalAdded","addIndex","groupIndex","cloneGroupOffset","prevCloneGroup","newCloneGroup","cloneExternal","newPanel","getCheckedIndexes","has","replacePanels","eventContext","fire","connectAxesHandler","addEventListener","Flicking","Component","withFlickingMethods"],"mappings":"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"}