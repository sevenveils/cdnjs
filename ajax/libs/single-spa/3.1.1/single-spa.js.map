{"version":3,"sources":["../jspm_packages/npm/custom-event@1.0.0/index.js","../src/child-applications/child-app-errors.js","../src/child-applications/child-app.helpers.js","../jspm_packages/npm/systemjs-plugin-babel@0.0.13/babel-helpers/extends.js","../src/child-applications/timeouts.js","../src/utils/find.js","../src/child-applications/lifecycles/load.js","../src/loader.js","../src/navigation/navigation-events.js","../src/jquery-support.js","../src/child-applications/child-apps.js","../src/navigation/reroute.js","../src/start.js","../jspm_packages/npm/systemjs-plugin-babel@0.0.13/regenerator-runtime.js","../jspm_packages/npm/systemjs-plugin-babel@0.0.13/babel-helpers/asyncToGenerator.js","../src/child-applications/lifecycles/bootstrap.js","../src/child-applications/lifecycles/mount.js","../src/child-applications/lifecycles/unmount.js"],"names":["NativeCustomEvent","global","CustomEvent","useNative","p","detail","foo","type","e","module","exports","document","createEvent","params","initCustomEvent","bubbles","cancelable","createEventObject","Boolean"],"mappings":"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","file":"single-spa.js","sourcesContent":["\nvar NativeCustomEvent = global.CustomEvent;\n\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n","export function handleChildAppError(err, childApp) {\n\tconst transformedErr = transformErr(err, childApp);\n\n\tif (window.SINGLE_SPA_TESTING) {\n\t\tconsole.error(transformedErr);\n\t} else {\n\t\tsetTimeout(() => {\n\t\t\tthrow transformedErr;\n\t\t});\n\t}\n}\n\nfunction transformErr(ogErr, childApp) {\n\tconst errPrefix = `'${childApp.name}' died in status ${childApp.status}: `;\n\n\tlet result;\n\n\tif (ogErr instanceof Error) {\n\t\togErr.message = errPrefix + ogErr.message;\n\t\tresult = ogErr;\n\t} else {\n\t\tconsole.warn(`While ${childApp.status}, '${childApp.name}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`);\n\t\ttry {\n\t\t\tresult = new Error(errPrefix + JSON.stringify(ogErr));\n\t\t} catch(err) {\n\t\t\t// If it's not an Error and you can't stringify it, then what else can you even do to it?\n\t\t\tresult = ogErr;\n\t\t}\n\t}\n\n\treturn result;\n}\n","import { handleChildAppError } from './child-app-errors.js';\n\n// App statuses\nexport const NOT_LOADED = 'NOT_LOADED';\nexport const LOADING_SOURCE_CODE = 'LOADING_SOURCE_CODE';\nexport const NOT_BOOTSTRAPPED = 'NOT_BOOTSTRAPPED';\nexport const BOOTSTRAPPING = 'BOOTSTRAPPING';\nexport const NOT_MOUNTED = 'NOT_MOUNTED';\nexport const MOUNTING = 'MOUNTING';\nexport const MOUNTED = 'MOUNTED';\nexport const UNMOUNTING = 'UNMOUNTING';\nexport const SKIP_BECAUSE_BROKEN = 'SKIP_BECAUSE_BROKEN';\n\nexport function isActive(app) {\n\treturn app.status === MOUNTED;\n}\n\nexport function isntActive(app) {\n\treturn !isActive(app);\n}\n\nexport function isLoaded(app) {\n\treturn app.status !== NOT_LOADED && app.status !== LOADING_SOURCE_CODE;\n}\n\nexport function isntLoaded(app) {\n\treturn !isLoaded(app);\n}\n\nexport function shouldBeActive(app) {\n\ttry {\n\t\treturn app.activeWhen(window.location);\n\t} catch (err) {\n\t\thandleChildAppError(err, app);\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t}\n}\n\nexport function shouldntBeActive(app) {\n\ttry {\n\t\treturn !app.activeWhen(window.location);\n\t} catch (err) {\n\t\thandleChildAppError(err, app);\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t}\n}\n\nexport function notBootstrapped(app) {\n\treturn app.status !== NOT_BOOTSTRAPPED;\n}\n\nexport function notSkipped(item) {\n\treturn item !== SKIP_BECAUSE_BROKEN && (!item || item.status !== SKIP_BECAUSE_BROKEN);\n}\n\nexport function toName(app) {\n\treturn app.name;\n}\n","export default Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};","const globalTimeoutConfig = {\n\tbootstrap: {\n\t\tmillis: 4000,\n\t\tdieOnTimeout: false,\n\t},\n\tmount: {\n\t\tmillis: 3000,\n\t\tdieOnTimeout: false,\n\t},\n\tunmount: {\n\t\tmillis: 3000,\n\t\tdieOnTimeout: false,\n\t},\n};\n\nexport function setBootstrapMaxTime(time, dieOnTimeout = false) {\n\tif (typeof time !== 'number' || time <= 0) {\n\t\tthrow new Error(`bootstrap max time must be a positive integer number of milliseconds`);\n\t}\n\n\tglobalTimeoutConfig.bootstrap = {\n\t\tmillis: time,\n\t\tdieOnTimeout,\n\t};\n}\n\nexport function setMountMaxTime(time, dieOnTimeout = false) {\n\tif (typeof time !== 'number' || time <= 0) {\n\t\tthrow new Error(`mount max time must be a positive integer number of milliseconds`);\n\t}\n\n\tglobalTimeoutConfig.mount = {\n\t\tmillis: time,\n\t\tdieOnTimeout,\n\t};\n}\n\nexport function setUnmountMaxTime(time, dieOnTimeout = false) {\n\tif (typeof time !== 'number' || time <= 0) {\n\t\tthrow new Error(`unmount max time must be a positive integer number of milliseconds`);\n\t}\n\n\tglobalTimeoutConfig.unmount = {\n\t\tmillis: time,\n\t\tdieOnTimeout,\n\t};\n}\n\nexport function reasonableTime(promise, description, timeoutConfig, app) {\n\tconst warningPeriod = 1000;\n\n\treturn new Promise((resolve, reject) => {\n\t\tlet finished = false;\n\t\tlet errored = false;\n\n\t\tpromise\n\t\t.then(val => {\n\t\t\tfinished = true;\n\t\t\tresolve(val);\n\t\t})\n\t\t.catch(val => {\n\t\t\tfinished = true;\n\t\t\treject(val);\n\t\t});\n\n\t\tsetTimeout(() => maybeTimingOut(1), warningPeriod);\n\t\tsetTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n\t\tfunction maybeTimingOut(shouldError) {\n\t\t\tif (!finished) {\n\t\t\t\tif (shouldError === true) {\n\t\t\t\t\terrored = true;\n\t\t\t\t\tif (timeoutConfig.dieOnTimeout) {\n\t\t\t\t\t\treject(`${description} did not resolve or reject for ${timeoutConfig.millis} milliseconds`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(`${description} did not resolve or reject for ${timeoutConfig.millis} milliseconds -- we're no longer going to warn you about it.`);\n\t\t\t\t\t\t//don't resolve or reject, we're waiting this one out\n\t\t\t\t\t}\n\t\t\t\t} else if (!errored) {\n\t\t\t\t\tconst numWarnings = shouldError;\n\t\t\t\t\tconst numMillis = numWarnings * warningPeriod;\n\t\t\t\t\tconsole.warn(`${description} did not resolve or reject within ${numMillis} milliseconds`);\n\t\t\t\t\tif (numMillis + warningPeriod < timeoutConfig.millis) {\n\t\t\t\t\t\tsetTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function ensureValidAppTimeouts(timeouts = {}) {\n\treturn {\n\t\t...globalTimeoutConfig,\n\t\t...timeouts,\n\t};\n}\n","/* the array.prototype.find polyfill on npmjs.com is ~20kb (not worth it)\n * and lodash is ~200kb (not worth it)\n */\n\nexport function find(arr, func) {\n\tfor (let i=0; i<arr.length; i++) {\n\t\tif (func(arr[i])) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\n\treturn null;\n}\n","import { NOT_BOOTSTRAPPED, LOADING_SOURCE_CODE, SKIP_BECAUSE_BROKEN, NOT_LOADED } from '../child-app.helpers.js';\nimport { ensureValidAppTimeouts } from '../timeouts.js';\nimport { handleChildAppError } from '../child-app-errors.js';\nimport { find } from 'src/utils/find.js';\n\nexport async function toLoadPromise(app) {\n\tif (app.status !== NOT_LOADED) {\n\t\treturn app;\n\t}\n\n\tapp.status = LOADING_SOURCE_CODE;\n\n\tlet appOpts;\n\n\ttry {\n\t\tappOpts = await app.loadImpl();\n\t} catch(err) {\n\t\thandleChildAppError(err, app);\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t\treturn app;\n\t}\n\n\tlet validationErrMessage;\n\n\tif (typeof appOpts !== 'object') {\n\t\tvalidationErrMessage = `does not export anything`;\n\t}\n\n\tif (!validLifecycleFn(appOpts.bootstrap)) {\n\t\tvalidationErrMessage = `does not export a bootstrap function or array of functions`;\n\t}\n\n\tif (!validLifecycleFn(appOpts.mount)) {\n\t\tvalidationErrMessage = `does not export a mount function or array of functions`;\n\t}\n\n\tif (!validLifecycleFn(appOpts.unmount)) {\n\t\tvalidationErrMessage = `does not export an unmount function or array of functions`;\n\t}\n\n\tif (validationErrMessage) {\n\t\thandleChildAppError(validationErrMessage, app);\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t\treturn app;\n\t}\n\n\tapp.status = NOT_BOOTSTRAPPED;\n\tapp.bootstrap = flattenFnArray(appOpts.bootstrap, `App '${app.name}' bootstrap function`);\n\tapp.mount = flattenFnArray(appOpts.mount, `App '${app.name}' mount function`);\n\tapp.unmount = flattenFnArray(appOpts.unmount, `App '${app.name}' unmount function`);\n\tapp.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n\n\treturn app;\n}\n\nfunction validLifecycleFn(fn) {\n\treturn fn && (typeof fn === 'function' || isArrayOfFns(fn));\n\n\tfunction isArrayOfFns(arr) {\n\t\treturn Array.isArray(arr) && !find(arr, item => typeof item !== 'function');\n\t}\n}\n\nfunction flattenFnArray(fns, description) {\n\tfns = Array.isArray(fns) ? fns : [fns];\n\tif (fns.length === 0) {\n\t\tfns = [() => Promise.resolve()];\n\t}\n\n\treturn function() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\twaitForPromises(0);\n\n\t\t\tfunction waitForPromises(index) {\n\t\t\t\tconst promise = fns[index]();\n\t\t\t\tif (!promise || typeof promise.then !== 'function' || typeof promise.catch !== 'function') {\n\t\t\t\t\treject(`${description} at index ${index} did not return a promise`);\n\t\t\t\t} else {\n\t\t\t\t\tpromise\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tif (index === fns.length - 1) {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twaitForPromises(index + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(reject);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n","export let Loader = null;\n\nexport function setLoader(loader) {\n\tif (!loader || typeof loader.import !== 'function') {\n\t\tthrow new Error(`'loader' is not a real loader. Must have an import function that returns a Promise`);\n\t}\n\tLoader = loader;\n}\n","import { reroute } from './reroute.js';\nimport { find } from 'src/utils/find.js';\n\n/* We capture navigation event listeners so that we can make sure\n * that child application navigation listeners are not called until\n * single-spa has ensured that the correct child applications are\n * unmounted and mounted.\n */\nconst capturedEventListeners = {\n\thashchange: [],\n\tpopstate: [],\n};\n\nexport const routingEventsListeningTo = ['hashchange', 'popstate'];\n\nexport function navigateToUrl(obj) {\n\tlet url;\n\tif (typeof obj === 'string') {\n\t\turl = obj ;\n\t} else if (this && this.href) {\n\t\turl = this.href;\n\t} else if (obj && obj.currentTarget && obj.currentTarget.href && obj.preventDefault) {\n\t\turl = obj.currentTarget.href;\n\t\tobj.preventDefault();\n\t} else {\n\t\tthrow new Error(`singleSpaNavigate must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`);\n\t}\n\n\tconst current = parseUri(window.location.href);\n\tconst destination = parseUri(url);\n\n\tif (url.indexOf('#') === 0) {\n\t\twindow.location.hash = '#' + destination.anchor;\n\t} else if (!isSamePath(destination.path, current.path) || (current.host !== destination.host && destination.host)) {\n\t\t// different path or a different host\n\t\twindow.history.pushState(null, null, url);\n\t} else {\n\t\twindow.location.hash = '#' + destination.anchor;\n\t}\n\n\tfunction isSamePath(destination, current) {\n\t\t// if the destination has a path but no domain, it doesn't include the root '/'\n\t\treturn current === destination || current === '/' + destination;\n\t}\n}\n\nexport function callCapturedEventListeners(eventArguments) {\n\tif (eventArguments) {\n\t\tconst eventType = eventArguments[0].type;\n\t\tif (routingEventsListeningTo.indexOf(eventType) >= 0) {\n\t\t\tcapturedEventListeners[eventType].forEach(listener => {\n\t\t\t\tlistener.apply(this, eventArguments);\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction urlReroute() {\n\treroute([], arguments)\n}\n\n\n// We will trigger an app change for any routing events.\nwindow.addEventListener('hashchange', urlReroute);\nwindow.addEventListener('popstate', urlReroute);\n\n// Monkeypatch addEventListener so that we can ensure correct timing\nconst originalAddEventListener = window.addEventListener;\nconst originalRemoveEventListener = window.removeEventListener;\nwindow.addEventListener = function(eventName, fn) {\n\tif (typeof fn === 'function') {\n\t\tif (routingEventsListeningTo.indexOf(eventName) >= 0 && !find(capturedEventListeners[eventName], listener => listener === fn)) {\n\t\t\tcapturedEventListeners[eventName].push(fn);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn originalAddEventListener.apply(this, arguments);\n}\n\nwindow.removeEventListener = function(eventName, listenerFn) {\n\tif (typeof listenerFn === 'function') {\n\t\tif (routingEventsListeningTo.indexOf(eventName) >= 0) {\n\t\t\tcapturedEventListeners[eventName] = capturedEventListeners[eventName].filter(fn => fn.toString() !== listenerFn.toString());\n\t\t\treturn;\n\t\t}\n\t}\n\n\treturn originalRemoveEventListener.apply(this, arguments);\n}\n\nconst originalPushState = window.history.pushState;\nwindow.history.pushState = function(state) {\n\tconst result = originalPushState.apply(this, arguments);\n\n\treroute();\n\t\n\treturn result;\n}\n\nconst originalReplaceState = window.history.replaceState;\nwindow.history.replaceState = function() {\n\tconst result = originalReplaceState.apply(this, arguments);\n\treroute();\n\treturn result;\n}\n\n/* For convenience in `onclick` attributes, we expose a global function for navigating to\n * whatever an <a> tag's href is.\n */\nwindow.singleSpaNavigate = navigateToUrl;\n\nfunction parseUri(str) {\n\t// parseUri 1.2.2\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\t// http://blog.stevenlevithan.com/archives/parseuri\n\tconst parseOptions = {\n\t\tstrictMode: true,\n\t\tkey: [\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],\n\t\tq:   {\n\t\t\tname:   \"queryKey\",\n\t\t\tparser: /(?:^|&)([^&=]*)=?([^&]*)/g\n\t\t},\n\t\tparser: {\n\t\t\tstrict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n\t\t\tloose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n\t\t}\n\t};\n\n\tlet\to = parseOptions;\n\tlet m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n\tlet uri = {};\n\tlet i = 14;\n\n\twhile (i--) uri[o.key[i]] = m[i] || \"\";\n\n\turi[o.q.name] = {};\n\turi[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n\t\tif ($1) uri[o.q.name][$1] = $2;\n\t});\n\n\treturn uri;\n}\n","import { routingEventsListeningTo } from './navigation/navigation-events.js';\n\nlet hasInitialized = false;\n\nexport function ensureJQuerySupport(jQuery = window.jQuery) {\n\tif (!jQuery) {\n\t\tif (window.$ && window.$.fn && window.$.fn.jquery) {\n\t\t\tjQuery = window.$;\n\t\t}\n\t}\n\n\tif (jQuery && !hasInitialized) {\n\t\tconst originalJQueryOn = jQuery.fn.on;\n\t\tconst originalJQueryOff = jQuery.fn.off;\n\n\t\tjQuery.fn.on = function(eventString, fn) {\n\t\t\treturn captureRoutingEvents.call(this, originalJQueryOn, window.addEventListener, eventString, fn, arguments);\n\t\t}\n\n\t\tjQuery.fn.off = function(eventString, fn) {\n\t\t\treturn captureRoutingEvents.call(this, originalJQueryOff, window.removeEventListener, eventString, fn, arguments);\n\t\t}\n\n\t\thasInitialized = true;\n\t}\n}\n\nfunction captureRoutingEvents(originalJQueryFunction, nativeFunctionToCall, eventString, fn, originalArgs) {\n\tif (typeof eventString !== 'string') {\n\t\treturn originalJQueryFunction.apply(this, originalArgs);\n\t}\n\n\tconst eventNames = eventString.split(/\\s+/);\n\teventNames.forEach(eventName => {\n\t\tif (routingEventsListeningTo.indexOf(eventName) >= 0) {\n\t\t\tnativeFunctionToCall(eventName, fn);\n\t\t\teventString = eventString.replace(eventName, '');\n\t\t}\n\t});\n\n\tif (eventString.trim() === '') {\n\t\treturn this;\n\t} else {\n\t\treturn originalJQueryFunction.apply(this, originalArgs);\n\t}\n}\n","import { Loader } from '../loader.js';\nimport { ensureJQuerySupport } from '../jquery-support.js';\nimport { isActive, isLoaded, isntLoaded, toName, NOT_LOADED, shouldBeActive, shouldntBeActive, isntActive, notSkipped } from './child-app.helpers.js';\nimport { reroute } from 'src/navigation/reroute.js';\nimport { find } from 'src/utils/find.js';\n\nconst childApps = [];\n\nexport function getMountedApps() {\n\treturn childApps.filter(isActive).map(toName);\n}\n\nexport function getAppStatus(appName) {\n\tconst app = find(childApps, app => app.name === appName);\n\treturn app ? app.status : null;\n}\n\nexport function declareChildApplication(appName, arg1, arg2) {\n\tif (typeof appName !== 'string' || appName.length === 0)\n\t\tthrow new Error(`The first argument must be a non-empty string 'appName'`);\n\tif (childApps[appName])\n\t\tthrow new Error(`There is already an app declared with name ${appName}`);\n\n\tlet loadImpl, activeWhen;\n\tif (!arg2) {\n\t\tif (!Loader) {\n\t\t\tthrow new Error(`You cannot declare a single-spa child application without either providing a way to load the application or a Loader. See https://github.com/CanopyTax/single-spa/blob/master/docs/single-spa-api.md#declarechildapplication`);\n\t\t}\n\t\tloadImpl = () => Loader.import(appName);\n\t\tactiveWhen = arg1;\n\t} else {\n\t\tloadImpl = arg1;\n\t\tactiveWhen = arg2;\n\t}\n\tif (typeof activeWhen !== 'function')\n\t\tthrow new Error(`The activeWhen argument must be a function`);\n\n\tchildApps.push({\n\t\tname: appName,\n\t\tloadImpl,\n\t\tactiveWhen,\n\t\tstatus: NOT_LOADED,\n\t});\n\n\tensureJQuerySupport();\n\n\treroute();\n}\n\nexport function getAppsToLoad() {\n\treturn childApps\n\t\t.filter(shouldBeActive)\n\t\t.filter(notSkipped)\n\t\t.filter(isntLoaded)\n}\n\nexport function getAppsToUnmount() {\n\treturn childApps\n\t\t.filter(shouldntBeActive)\n\t\t.filter(notSkipped)\n\t\t.filter(isActive)\n}\n\nexport function getAppsToMount() {\n\treturn childApps\n\t\t.filter(shouldBeActive)\n\t\t.filter(notSkipped)\n\t\t.filter(isntActive)\n\t\t.filter(isLoaded)\n}\n","import CustomEvent from 'custom-event';\nimport { isStarted } from 'src/start.js';\nimport { toLoadPromise } from 'src/child-applications/lifecycles/load.js';\nimport { toBootstrapPromise } from 'src/child-applications/lifecycles/bootstrap.js';\nimport { toMountPromise } from 'src/child-applications/lifecycles/mount.js';\nimport { toUnmountPromise } from 'src/child-applications/lifecycles/unmount.js';\nimport { getMountedApps, getAppsToLoad, getAppsToUnmount, getAppsToMount } from 'src/child-applications/child-apps.js';\nimport { notSkipped } from 'src/child-applications/child-app.helpers.js';\nimport { callCapturedEventListeners } from './navigation-events.js';\n\nlet appChangeUnderway = false, peopleWaitingOnAppChange = [];\n\nexport function reroute(pendingPromises = [], eventArguments) {\n\tif (appChangeUnderway) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tpeopleWaitingOnAppChange.push({\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\teventArguments,\n\t\t\t});\n\t\t});\n\t}\n\n\tappChangeUnderway = true;\n\tlet wasNoOp = true;\n\n\tif (isStarted()) {\n\t\treturn performAppChanges();\n\t} else {\n\t\treturn loadApps();\n\t}\n\n\tasync function loadApps() {\n\t\tconst loadPromises = getAppsToLoad().map(toLoadPromise);\n\n\t\tif (loadPromises.length > 0) {\n\t\t\twasNoOp = false;\n\t\t}\n\n\t\ttry {\n\t\t\tawait Promise.all(loadPromises);\n\t\t} catch(err) {\n\t\t\tcallAllEventListeners();\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn finishUpAndReturn();\n\t}\n\n\tasync function performAppChanges() {\n\t\tconst unmountPromises = getAppsToUnmount().map(toUnmountPromise);\n\t\tif (unmountPromises.length > 0) {\n\t\t\twasNoOp = false;\n\t\t}\n\t\tconst unmountAllPromise = Promise.all(unmountPromises);\n\n\t\tconst appsToLoad = getAppsToLoad();\n\n\t\t/* We load and bootstrap apps while other apps are unmounting, but we\n\t\t * wait to mount the app until all apps are finishing unmounting\n\t\t */\n\t\tconst loadThenMountPromises = appsToLoad.map(app => {\n\t\t\treturn toLoadPromise(app)\n\t\t\t\t.then(toBootstrapPromise)\n\t\t\t\t.then(async function(app) {\n\t\t\t\t\tawait unmountAllPromise;\n\t\t\t\t\treturn toMountPromise(app);\n\t\t\t\t})\n\t\t})\n\t\tif (loadThenMountPromises.length > 0) {\n\t\t\twasNoOp = false;\n\t\t}\n\n\t\t/* These are the apps that are already bootstrapped and just need\n\t\t * to be mounted. They each wait for all unmounting apps to finish up\n\t\t * before they mount.\n\t\t */\n\t\tconst mountPromises = getAppsToMount()\n\t\t\t.filter(appToMount => appsToLoad.indexOf(appToMount) < 0)\n\t\t\t.map(async function(appToMount) {\n\t\t\t\tawait toBootstrapPromise(appToMount);\n\t\t\t\tawait unmountAllPromise;\n\t\t\t\treturn toMountPromise(appToMount);\n\t\t\t})\n\t\tif (mountPromises.length > 0) {\n\t\t\twasNoOp = false;\n\t\t}\n\n\t\ttry {\n\t\t\tawait Promise.all(unmountPromises);\n\t\t} catch(err) {\n\t\t\tcallAllEventListeners();\n\t\t\tthrow err;\n\t\t}\n\n\t\t/* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n\t\t * events (like hashchange or popstate) should have been cleaned up. So it's safe\n\t\t * to let the remaining captured event listeners to handle about the DOM event.\n\t\t */\n\t\tcallAllEventListeners();\n\n\t\ttry {\n\t\t\tawait Promise.all(loadThenMountPromises.concat(mountPromises));\n\t\t} catch(err) {\n\t\t\tpendingPromises.forEach(promise => promise.reject(err));\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn finishUpAndReturn();\n\t}\n\n\tfunction finishUpAndReturn() {\n\t\tconst returnValue = getMountedApps();\n\n\t\tcallAllEventListeners();\n\t\tpendingPromises.forEach(promise => promise.resolve(returnValue));\n\n\t\t/* Setting this allows for subsequent calls to reroute() to actually perform\n\t\t * a reroute instead of just getting queued behind the current reroute call.\n\t\t * We want to do this after the mounting/unmounting is done but before we\n\t\t * resolve the promise for the `reroute` async function.\n\t\t */\n\t\tappChangeUnderway = false;\n\n\t\tif (peopleWaitingOnAppChange.length > 0) {\n\t\t\t/* While we were rerouting, someone else triggered another reroute that got queued.\n\t\t\t * So we need reroute again.\n\t\t\t */\n\t\t\tconst nextPendingPromises = peopleWaitingOnAppChange;\n\t\t\tpeopleWaitingOnAppChange = [];\n\t\t\treroute(nextPendingPromises);\n\t\t} else {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!wasNoOp) {\n\t\t\t\t\twindow.dispatchEvent(new CustomEvent(\"single-spa:app-change\"));\n\t\t\t\t}\n\n\t\t\t\twindow.dispatchEvent(new CustomEvent(\"single-spa:routing-event\"));\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t}\n\n\t/* We need to call all event listeners that have been delayed because they were\n\t * waiting on single-spa. This includes haschange and popstate events for both\n\t * the current run of performAppChanges(), but also all of the queued event listeners.\n\t * We want to call the listeners in the same order as if they had not been delayed by\n\t * single-spa, which means queued ones first and then the most recent one.\n\t */\n\tfunction callAllEventListeners() {\n\t\tpendingPromises.forEach(pendingPromise => {\n\t\t\tcallCapturedEventListeners(pendingPromise.eventArguments);\n\t\t});\n\n\t\tcallCapturedEventListeners(eventArguments);\n\t}\n}\n","import { reroute } from './navigation/reroute.js';\nimport { setLoader } from './loader.js';\n\nexport let started = false;\n\nexport function start() {\n\tstarted = true;\n\treroute();\n}\n\nexport function isStarted() {\n\treturn started;\n}\n","export default (function(module) {\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided, then outerFn.prototype instanceof Generator.\n    var generator = Object.create((outerFn || Generator).prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `value instanceof AwaitArgument` to determine if the yielded value is\n  // meant to be awaited. Some may consider the name of this method too\n  // cutesy, but they are curmudgeons.\n  runtime.awrap = function(arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value instanceof AwaitArgument) {\n          return Promise.resolve(value.arg).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = arg;\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\nreturn module.exports; })({exports:{}});\n","export default (function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n});","import { NOT_BOOTSTRAPPED, BOOTSTRAPPING, NOT_MOUNTED, SKIP_BECAUSE_BROKEN } from '../child-app.helpers.js';\nimport { reasonableTime } from '../timeouts.js';\nimport { handleChildAppError } from 'src/child-applications/child-app-errors.js';\n\nexport async function toBootstrapPromise(app) {\n\tif (app.status !== NOT_BOOTSTRAPPED) {\n\t\treturn app;\n\t}\n\n\tapp.status = BOOTSTRAPPING;\n\n\ttry {\n\t\tawait reasonableTime(app.bootstrap(), `Bootstrapping app '${app.name}'`, app.timeouts.bootstrap);\n\t\tapp.status = NOT_MOUNTED;\n\t} catch(err) {\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t\thandleChildAppError(err, app);\n\t}\n\n\treturn app;\n}\n","import { NOT_MOUNTED, MOUNTED, SKIP_BECAUSE_BROKEN } from '../child-app.helpers.js';\nimport { handleChildAppError } from '../child-app-errors.js';\nimport { reasonableTime } from '../timeouts.js';\n\nexport async function toMountPromise(app) {\n\tif (app.status !== NOT_MOUNTED) {\n\t\treturn app;\n\t}\n\ttry {\n\t\tawait reasonableTime(app.mount(), `Mounting application ${app.name}'`, app.timeouts.mount);\n\t\tapp.status = MOUNTED;\n\t} catch (err) {\n\t\thandleChildAppError(err, app);\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t}\n\n\treturn app;\n}\n","import { UNMOUNTING, NOT_MOUNTED, MOUNTED, SKIP_BECAUSE_BROKEN } from '../child-app.helpers.js';\nimport { handleChildAppError } from '../child-app-errors.js';\nimport { reasonableTime } from '../timeouts.js';\n\nexport async function toUnmountPromise(app) {\n\tif (app.status !== MOUNTED) {\n\t\treturn app;\n\t}\n\tapp.status = UNMOUNTING\n\n\ttry {\n\t\tawait reasonableTime(app.unmount(), `Unmounting application ${app.name}'`, app.timeouts.unmount);\n\t\tapp.status = NOT_MOUNTED;\n\t} catch (err) {\n\t\thandleChildAppError(err, app);\n\t\tapp.status = SKIP_BECAUSE_BROKEN;\n\t}\n\n\treturn app;\n}\n"]}