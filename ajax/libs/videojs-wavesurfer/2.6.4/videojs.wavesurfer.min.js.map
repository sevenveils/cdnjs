{"version":3,"sources":["webpack://VideojsWavesurfer/webpack/universalModuleDefinition","webpack://VideojsWavesurfer/webpack/bootstrap","webpack://VideojsWavesurfer/./src/js/videojs.wavesurfer.js","webpack://VideojsWavesurfer/./src/js/utils/log.js","webpack://VideojsWavesurfer/./src/js/utils/format-time.js","webpack://VideojsWavesurfer/./src/js/defaults.js","webpack://VideojsWavesurfer/./node_modules/global/window.js","webpack://VideojsWavesurfer/(webpack)/buildin/global.js","webpack://VideojsWavesurfer/external \"videojs\"","webpack://VideojsWavesurfer/external \"WaveSurfer\""],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__7__","__WEBPACK_EXTERNAL_MODULE__8__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_log2","_interopRequireDefault","_formatTime","_defaults","_window","_video","_wavesurfer","Plugin","videojs","getPlugin","Wavesurfer","player","options","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","addClass","mergeOptions","pluginDefaultOptions","waveReady","waveFinished","liveMode","debug","toString","msDisplayMax","parseFloat","textTracksEnabled","options_","tracks","length","src","undefined","WaveSurfer","microphone","onWaveError","one","initialize","_assertThisInitialized","bigPlayButton","hide","usingNativeControls_","tech_","el_","controls","controlBar","show","style","display","progressControl","currentTimeDisplay","timeDivider","durationDisplay","forEach","element","remainingTimeDisplay","playToggle","on","onPlayToggle","mergedOptions","parseOptions","plugins","wavesurfer","surfer","onWaveFinish","surferReady","onWaveReady","surferProgress","onWaveProgress","surferSeek","onWaveSeek","setupPlaybackEvents","onVolumeChange","onScreenChange","muted","setVolume","fluid","drawer","wrapper","className","responsiveWave","util","debounce","onResizeChange","addEventListener","off","throttledUpdateContent","trackCurrentTime","startPlayers","surferOpts","rect","getBoundingClientRect","originalWidth","width","originalHeight","height","controlBarHeight","container","waveformHeight","playerHeight","splitChannels","log","loadingSpinner","load","peaks","enable","un","url","_this2","Blob","File","JSON","stringify","loadBlob","Array","isArray","ajaxOptions","responseType","xhr","ajax","data","e","target","status","contentEl","handlePlay","active","paused","pause","play","start","handlePause","setCurrentTime","destroy","stopTrackingCurrentTime","children","dispose","volume","format","quality","exportImage","deviceId","_this3","setSinkId","then","result","trigger","catch","err","currentTime","getCurrentTime","isNaN","duration","getDuration","time","Math","min","formattedTime_","lastChild","textContent","default","setDuration","autoplay","_this4","loop","stop","once","removeClass","error","hasClass","isPlaying","_this5","fullscreenDelay","setInterval","newWidth","newHeight","isFullscreen","redrawWaveform","clearInterval","isDestroyed","params","createDrawer","drawBuffer","progress","backend","getPlayedPercents","args","logType","VERSION","__VERSION__","registerPlugin","warn","seconds","guide","floor","h","gm","gh","ms","Infinity","global","win","self","g","Function"],"mappings":"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","file":"videojs.wavesurfer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"videojs\"), require(\"WaveSurfer\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"VideojsWavesurfer\", [\"videojs\", \"WaveSurfer\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VideojsWavesurfer\"] = factory(require(\"videojs\"), require(\"WaveSurfer\"));\n\telse\n\t\troot[\"VideojsWavesurfer\"] = factory(root[\"videojs\"], root[\"WaveSurfer\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @file videojs.wavesurfer.js\n *\n * The main file for the videojs-wavesurfer project.\n * MIT license: https://github.com/collab-project/videojs-wavesurfer/blob/master/LICENSE\n */\n\nimport log from './utils/log';\nimport formatTime from './utils/format-time';\nimport pluginDefaultOptions from './defaults';\nimport window from 'global/window';\n\nimport videojs from 'video.js';\nimport WaveSurfer from 'wavesurfer.js';\n\nconst Plugin = videojs.getPlugin('plugin');\n\nconst wavesurferClassName = 'vjs-wavedisplay';\n\n/**\n * Draw a waveform for audio and video files in a video.js player.\n *\n * @class\n * @augments videojs.Plugin\n */\nclass Wavesurfer extends Plugin {\n    /**\n     * The constructor function for the class.\n     *\n     * @param {(videojs.Player|Object)} player - video.js Player object.\n     * @param {Object} options - Player options.\n     */\n    constructor(player, options) {\n        super(player, options);\n\n        // add plugin style\n        player.addClass('vjs-wavesurfer');\n\n        // parse options\n        options = videojs.mergeOptions(pluginDefaultOptions, options);\n        this.waveReady = false;\n        this.waveFinished = false;\n        this.liveMode = false;\n        this.debug = (options.debug.toString() === 'true');\n        this.msDisplayMax = parseFloat(options.msDisplayMax);\n        this.textTracksEnabled = (this.player.options_.tracks.length > 0);\n\n        // microphone plugin\n        if (options.src === 'live') {\n            // check if the wavesurfer.js microphone plugin can be enabled\n            if (WaveSurfer.microphone !== undefined) {\n                // enable audio input from a microphone\n                this.liveMode = true;\n                this.waveReady = true;\n            } else {\n                this.onWaveError('Could not find wavesurfer.js ' +\n                    'microphone plugin!');\n                return;\n            }\n        }\n\n        // wait until player ui is ready\n        this.player.one('ready', this.initialize.bind(this));\n    }\n\n    /**\n     * Player UI is ready: customize controls.\n     *\n     * @private\n     */\n    initialize() {\n        // hide big play button\n        this.player.bigPlayButton.hide();\n\n        // the native controls don't work for this UI so disable\n        // them no matter what\n        if (this.player.usingNativeControls_ === true) {\n            if (this.player.tech_.el_ !== undefined) {\n                this.player.tech_.el_.controls = false;\n            }\n        }\n\n        // controls\n        if (this.player.options_.controls === true) {\n            // make sure controlBar is showing\n            this.player.controlBar.show();\n            this.player.controlBar.el_.style.display = 'flex';\n\n            // progress control isn't used by this plugin\n            this.player.controlBar.progressControl.hide();\n\n            // make sure time displays are visible\n            let uiElements = [\n                this.player.controlBar.currentTimeDisplay,\n                this.player.controlBar.timeDivider,\n                this.player.controlBar.durationDisplay\n            ];\n            uiElements.forEach((element) => {\n                // ignore and show when essential elements have been disabled\n                // by user\n                if (element !== undefined) {\n                    element.el_.style.display = 'block';\n                    element.show();\n                }\n            });\n            if (this.player.controlBar.remainingTimeDisplay !== undefined) {\n                this.player.controlBar.remainingTimeDisplay.hide();\n            }\n\n            // handle play toggle interaction\n            this.player.controlBar.playToggle.on(['tap', 'click'],\n                this.onPlayToggle.bind(this));\n\n            // disable play button until waveform is ready\n            // (except when in live mode)\n            if (!this.liveMode) {\n                this.player.controlBar.playToggle.hide();\n            }\n        }\n\n        // wavesurfer.js setup\n        let mergedOptions = this.parseOptions(this.player.options_.plugins.wavesurfer);\n        this.surfer = WaveSurfer.create(mergedOptions);\n        this.surfer.on('error', this.onWaveError.bind(this));\n        this.surfer.on('finish', this.onWaveFinish.bind(this));\n        if (this.liveMode === true) {\n            // listen for wavesurfer.js microphone plugin events\n            this.surfer.microphone.on('deviceError', this.onWaveError.bind(this));\n        }\n        this.surferReady = this.onWaveReady.bind(this);\n        this.surferProgress = this.onWaveProgress.bind(this);\n        this.surferSeek = this.onWaveSeek.bind(this);\n\n        // only listen to these wavesurfer.js playback events when not\n        // in live mode\n        if (!this.liveMode) {\n            this.setupPlaybackEvents(true);\n        }\n\n        // video.js player events\n        this.player.on('volumechange', this.onVolumeChange.bind(this));\n        this.player.on('fullscreenchange', this.onScreenChange.bind(this));\n\n        // make sure volume is muted when requested\n        if (this.player.muted()) {\n            this.setVolume(0);\n        }\n\n        // video.js fluid option\n        if (this.player.options_.fluid === true) {\n            // give wave element a classname so it can be styled\n            this.surfer.drawer.wrapper.className = wavesurferClassName;\n            // listen for window resize events\n            this.responsiveWave = WaveSurfer.util.debounce(\n                this.onResizeChange.bind(this), 150);\n            window.addEventListener('resize', this.responsiveWave);\n        }\n\n        // text tracks\n        if (this.textTracksEnabled) {\n            // disable timeupdates\n            this.player.controlBar.currentTimeDisplay.off(this.player, 'timeupdate',\n                this.player.controlBar.currentTimeDisplay.throttledUpdateContent);\n\n            // sets up an interval function to track current time\n            // and trigger timeupdate every 250 milliseconds.\n            // needed for text tracks\n            this.player.tech_.trackCurrentTime();\n        }\n\n        // kick things off\n        this.startPlayers();\n    }\n\n    /**\n     * Initializes the waveform options.\n     *\n     * @private\n     * @param {Object} surferOpts - Plugin options.\n     * @returns {Object} - Updated `surferOpts` object.\n     */\n    parseOptions(surferOpts) {\n        let rect = this.player.el_.getBoundingClientRect();\n        this.originalWidth = this.player.options_.width || rect.width;\n        this.originalHeight = this.player.options_.height || rect.height;\n\n        // controlbar\n        let controlBarHeight = this.player.controlBar.height();\n        if (this.player.options_.controls === true && controlBarHeight === 0) {\n            // the dimensions of the controlbar are not known yet, but we\n            // need it now, so we can calculate the height of the waveform.\n            // The default height is 30px, so use that instead.\n            controlBarHeight = 30;\n        }\n\n        // set waveform element and dimensions\n        // Set the container to player's container if \"container\" option is\n        // not provided. If a waveform needs to be appended to your custom\n        // element, then use below option. For example:\n        // container: document.querySelector(\"#vjs-waveform\")\n        if (surferOpts.container === undefined) {\n            surferOpts.container = this.player.el_;\n        }\n\n        // set the height of generated waveform if user has provided height\n        // from options. If height of waveform need to be customized then use\n        // option below. For example: waveformHeight: 30\n        if (surferOpts.waveformHeight === undefined) {\n            let playerHeight = rect.height;\n            surferOpts.height = playerHeight - controlBarHeight;\n        } else {\n            surferOpts.height = surferOpts.waveformHeight;\n        }\n\n        // split channels\n        if (surferOpts.splitChannels && surferOpts.splitChannels === true) {\n            surferOpts.height /= 2;\n        }\n\n        // enable wavesurfer.js microphone plugin\n        if (this.liveMode === true) {\n            surferOpts.plugins = [\n                WaveSurfer.microphone.create(surferOpts)\n            ];\n            this.log('wavesurfer.js microphone plugin enabled.');\n        }\n\n        return surferOpts;\n    }\n\n    /**\n     * Start the players.\n     * @private\n     */\n    startPlayers() {\n        let options = this.player.options_.plugins.wavesurfer;\n        if (options.src !== undefined) {\n            if (this.surfer.microphone === undefined) {\n                // show loading spinner\n                this.player.loadingSpinner.show();\n\n                // start loading file\n                this.load(options.src, options.peaks);\n            } else {\n                // hide loading spinner\n                this.player.loadingSpinner.hide();\n\n                // connect microphone input to our waveform\n                options.wavesurfer = this.surfer;\n            }\n        } else {\n            // no valid src found, hide loading spinner\n            this.player.loadingSpinner.hide();\n        }\n    }\n\n    /**\n     * Starts or stops listening to events related to audio-playback.\n     *\n     * @param {boolean} enable - Start or stop listening to playback\n     *     related events.\n     * @private\n     */\n    setupPlaybackEvents(enable) {\n        if (enable === false) {\n            this.surfer.un('ready', this.surferReady);\n            this.surfer.un('audioprocess', this.surferProgress);\n            this.surfer.un('seek', this.surferSeek);\n        } else if (enable === true) {\n            this.surfer.on('ready', this.surferReady);\n            this.surfer.on('audioprocess', this.surferProgress);\n            this.surfer.on('seek', this.surferSeek);\n        }\n    }\n\n    /**\n     * Start loading waveform data.\n     *\n     * @param {string|blob|file} url - Either the URL of the audio file,\n     *     a Blob or a File object.\n     * @param {string|number[]} peaks - Either the URL of peaks\n     *     data for the audio file, or an array with peaks data.\n     */\n    load(url, peaks) {\n        if (url instanceof Blob || url instanceof File) {\n            this.log('Loading object: ' + JSON.stringify(url));\n            this.surfer.loadBlob(url);\n        } else {\n            // load peak data from file\n            if (peaks !== undefined) {\n                if (Array.isArray(peaks)) {\n                    // use supplied peaks data\n                    this.log('Loading URL: ' + url);\n                    this.surfer.load(url, peaks);\n                } else {\n                    // load peak data from file\n                    let ajaxOptions = {\n                        url: peaks,\n                        responseType: 'json'\n                    };\n                    // supply xhr options, if any\n                    if (this.player.options_.plugins.wavesurfer.xhr !== undefined) {\n                        ajaxOptions.xhr = this.player.options_.plugins.wavesurfer.xhr;\n                    }\n                    let ajax = WaveSurfer.util.ajax(ajaxOptions);\n\n                    ajax.on('success', (data, e) => {\n                        this.log('Loaded Peak Data URL: ' + peaks);\n                        this.surfer.load(url, data.data);\n                    });\n                    ajax.on('error', (e) => {\n                        this.log('Unable to retrieve peak data from ' + peaks +\n                            '. Status code: ' + e.target.status, 'warn');\n                        this.log('Loading URL: ' + url);\n                        this.surfer.load(url);\n                    });\n                }\n            } else {\n                // no peaks\n                this.log('Loading URL: ' + url);\n                this.surfer.load(url);\n            }\n        }\n    }\n\n    /**\n     * Start/resume playback or microphone.\n     */\n    play() {\n        // show pause button\n        if (this.player.controlBar.playToggle.contentEl()) {\n            this.player.controlBar.playToggle.handlePlay();\n        }\n\n        if (this.liveMode) {\n            // start/resume microphone visualization\n            if (!this.surfer.microphone.active)\n            {\n                this.log('Start microphone');\n                this.surfer.microphone.start();\n            } else {\n                // toggle paused\n                let paused = !this.surfer.microphone.paused;\n\n                if (paused) {\n                    this.pause();\n                } else {\n                    this.log('Resume microphone');\n                    this.surfer.microphone.play();\n                }\n            }\n        } else {\n            this.log('Start playback');\n\n            // put video.js player UI in playback mode\n            this.player.play();\n\n            // start surfer playback\n            this.surfer.play();\n        }\n    }\n\n    /**\n     * Pauses playback or microphone visualization.\n     */\n    pause() {\n        // show play button\n        if (this.player.controlBar.playToggle.contentEl()) {\n            this.player.controlBar.playToggle.handlePause();\n        }\n\n        if (this.liveMode) {\n            // pause microphone visualization\n            this.log('Pause microphone');\n            this.surfer.microphone.pause();\n        } else {\n            // pause playback\n            this.log('Pause playback');\n\n            if (!this.waveFinished) {\n                // pause wavesurfer playback\n                this.surfer.pause();\n            } else {\n                this.waveFinished = false;\n            }\n\n            this.setCurrentTime();\n        }\n    }\n\n    /**\n     * @private\n     */\n    dispose() {\n        if (this.surfer) {\n            if (this.liveMode && this.surfer.microphone) {\n                // destroy microphone plugin\n                this.surfer.microphone.destroy();\n                this.log('Destroyed microphone plugin');\n            }\n            // destroy wavesurfer instance\n            this.surfer.destroy();\n        }\n        if (this.textTracksEnabled) {\n            this.player.tech_.stopTrackingCurrentTime();\n        }\n        this.log('Destroyed plugin');\n    }\n\n    /**\n     * Indicates whether the plugin is destroyed or not.\n     *\n     * @return {boolean} Plugin destroyed or not.\n     */\n    isDestroyed() {\n        return this.player && (this.player.children() === null);\n    }\n\n    /**\n     * Remove the player and waveform.\n     */\n    destroy() {\n        this.player.dispose();\n    }\n\n    /**\n     * Set the volume level.\n     *\n     * @param {number} volume - The new volume level.\n     */\n    setVolume(volume) {\n        if (volume !== undefined) {\n            this.log('Changing volume to: ' + volume);\n\n            // update player volume\n            this.player.volume(volume);\n        }\n    }\n\n    /**\n     * Save waveform image as data URI.\n     *\n     * The default format is `'image/png'`. Other supported types are\n     * `'image/jpeg'` and `'image/webp'`.\n     *\n     * @param {string} [format=image/png] - String indicating the image format.\n     * @param {number} [quality=1] - Number between 0 and 1 indicating image\n     *     quality if the requested type is `'image/jpeg'` or `'image/webp'`.\n     * @returns {string} The data URI of the image data.\n     */\n    exportImage(format, quality) {\n        return this.surfer.exportImage(format, quality);\n    }\n\n    /**\n     * Change the audio output device.\n     *\n     * @param {string} deviceId - Id of audio output device.\n     */\n    setAudioOutput(deviceId) {\n        if (deviceId) {\n            this.surfer.setSinkId(deviceId).then((result) => {\n                // notify listeners\n                this.player.trigger('audioOutputReady');\n            }).catch((err) => {\n                // notify listeners\n                this.player.trigger('error', err);\n\n                this.log(err, 'error');\n            });\n        }\n    }\n\n    /**\n     * Get the current time (in seconds) of the stream during playback.\n     *\n     * Returns 0 if no stream is available (yet).\n     *\n     * @returns {float} Current time of the stream.\n     */\n    getCurrentTime() {\n        let currentTime = this.surfer.getCurrentTime();\n        currentTime = isNaN(currentTime) ? 0 : currentTime;\n\n        return currentTime;\n    }\n\n    /**\n     * Updates the player's element displaying the current time.\n     *\n     * @param {number} [currentTime] - Current position of the playhead\n     *     (in seconds).\n     * @param {number} [duration] - Duration of the waveform (in seconds).\n     * @private\n     */\n    setCurrentTime(currentTime, duration) {\n        if (currentTime === undefined) {\n            currentTime = this.surfer.getCurrentTime();\n        }\n\n        if (duration === undefined) {\n            duration = this.surfer.getDuration();\n        }\n\n        currentTime = isNaN(currentTime) ? 0 : currentTime;\n        duration = isNaN(duration) ? 0 : duration;\n\n        // update current time display component\n        if (this.player.controlBar.currentTimeDisplay &&\n            this.player.controlBar.currentTimeDisplay.contentEl()) {\n            let time = Math.min(currentTime, duration);\n\n            this.player.controlBar.currentTimeDisplay.formattedTime_ =\n                this.player.controlBar.currentTimeDisplay.contentEl().lastChild.textContent =\n                    formatTime(time, duration, this.msDisplayMax);\n        }\n\n        if (this.textTracksEnabled && this.player.tech_ && this.player.tech_.el_) {\n            // only needed for text tracks\n            this.player.tech_.setCurrentTime(currentTime);\n        }\n    }\n\n    /**\n     * Get the duration of the stream in seconds.\n     *\n     * Returns 0 if no stream is available (yet).\n     *\n     * @returns {float} Duration of the stream.\n     */\n    getDuration() {\n        let duration = this.surfer.getDuration();\n        duration = isNaN(duration) ? 0 : duration;\n\n        return duration;\n    }\n\n    /**\n     * Updates the player's element displaying the duration time.\n     *\n     * @param {number} [duration] - Duration of the waveform (in seconds).\n     * @private\n     */\n    setDuration(duration) {\n        if (duration === undefined) {\n            duration = this.surfer.getDuration();\n        }\n        duration = isNaN(duration) ? 0 : duration;\n\n        // update duration display component\n        if (this.player.controlBar.durationDisplay &&\n            this.player.controlBar.durationDisplay.contentEl()) {\n            this.player.controlBar.durationDisplay.formattedTime_ =\n                this.player.controlBar.durationDisplay.contentEl().lastChild.textContent =\n                    formatTime(duration, duration, this.msDisplayMax);\n        }\n    }\n\n    /**\n     * Audio is loaded, decoded and the waveform is drawn.\n     *\n     * @fires waveReady\n     * @private\n     */\n    onWaveReady() {\n        this.waveReady = true;\n        this.waveFinished = false;\n        this.liveMode = false;\n\n        this.log('Waveform is ready');\n        this.player.trigger('waveReady');\n\n        // update time display\n        this.setCurrentTime();\n        this.setDuration();\n\n        // enable and show play button\n        if (this.player.controlBar.playToggle.contentEl()) {\n            this.player.controlBar.playToggle.show();\n        }\n\n        // hide loading spinner\n        if (this.player.loadingSpinner.contentEl()) {\n            this.player.loadingSpinner.hide();\n        }\n\n        // auto-play when ready (if enabled)\n        if (this.player.options_.autoplay === true) {\n            this.play();\n        }\n    }\n\n    /**\n     * Fires when audio playback completed.\n     *\n     * @fires playbackFinish\n     * @private\n     */\n    onWaveFinish() {\n        this.log('Finished playback');\n\n        // notify listeners\n        this.player.trigger('playbackFinish');\n\n        // check if loop is enabled\n        if (this.player.options_.loop === true) {\n            // reset waveform\n            this.surfer.stop();\n            this.play();\n        } else {\n            // finished\n            this.waveFinished = true;\n\n            // pause player\n            this.pause();\n\n            // show the replay state of play toggle\n            this.player.trigger('ended');\n\n            // this gets called once after the clip has ended and the user\n            // seeks so that we can change the replay button back to a play\n            // button\n            this.surfer.once('seek', () => {\n                this.player.controlBar.playToggle.removeClass('vjs-ended');\n                this.player.trigger('pause');\n            });\n        }\n    }\n\n    /**\n     * Fires continuously during audio playback.\n     *\n     * @param {number} time - Current time/location of the playhead.\n     * @private\n     */\n    onWaveProgress(time) {\n        this.setCurrentTime();\n    }\n\n    /**\n     * Fires during seeking of the waveform.\n     * @private\n     */\n    onWaveSeek() {\n        this.setCurrentTime();\n    }\n\n    /**\n     * Waveform error.\n     *\n     * @param {string} error - The wavesurfer error.\n     * @private\n     */\n    onWaveError(error) {\n        // notify listeners\n        this.player.trigger('error', error);\n\n        this.log(error, 'error');\n    }\n\n    /**\n     * Fired when the play toggle is clicked.\n     * @private\n     */\n    onPlayToggle() {\n        // workaround for video.js 6.3.1 and newer\n        if (this.player.controlBar.playToggle.hasClass('vjs-ended')) {\n            this.player.controlBar.playToggle.removeClass('vjs-ended');\n        }\n        if (this.surfer.isPlaying()) {\n            this.pause();\n        } else {\n            this.play();\n        }\n    }\n\n    /**\n     * Fired when the volume in the video.js player changes.\n     * @private\n     */\n    onVolumeChange() {\n        let volume = this.player.volume();\n        if (this.player.muted()) {\n            // muted volume\n            volume = 0;\n        }\n\n        // update wavesurfer.js volume\n        this.surfer.setVolume(volume);\n    }\n\n    /**\n     * Fired when the video.js player switches in or out of fullscreen mode.\n     * @private\n     */\n    onScreenChange() {\n        // execute with tiny delay so the player element completes\n        // rendering and correct dimensions are reported\n        let fullscreenDelay = this.player.setInterval(() => {\n            let isFullscreen = this.player.isFullscreen();\n            let newWidth, newHeight;\n            if (!isFullscreen) {\n                // restore original dimensions\n                newWidth = this.originalWidth;\n                newHeight = this.originalHeight;\n            }\n\n            if (this.waveReady) {\n                if (this.liveMode && !this.surfer.microphone.active) {\n                    // we're in live mode but the microphone hasn't been\n                    // started yet\n                    return;\n                }\n                // redraw\n                this.redrawWaveform(newWidth, newHeight);\n            }\n\n            // stop fullscreenDelay interval\n            this.player.clearInterval(fullscreenDelay);\n\n        }, 100);\n    }\n\n    /**\n     * Fired when the video.js player is resized.\n     *\n     * @private\n     */\n    onResizeChange() {\n        if (this.surfer !== undefined) {\n            // redraw waveform\n            this.redrawWaveform();\n        }\n    }\n\n    /**\n     * Redraw waveform.\n     *\n     * @param {number} [newWidth] - New width for the waveform.\n     * @param {number} [newHeight] - New height for the waveform.\n     * @private\n     */\n    redrawWaveform(newWidth, newHeight) {\n        if (!this.isDestroyed()) {\n            if (this.player.el_) {\n                let rect = this.player.el_.getBoundingClientRect();\n                if (newWidth === undefined) {\n                    // get player width\n                    newWidth = rect.width;\n                }\n                if (newHeight === undefined) {\n                    // get player height\n                    newHeight = rect.height;\n                }\n            }\n\n            // destroy old drawing\n            this.surfer.drawer.destroy();\n\n            // set new dimensions\n            this.surfer.params.width = newWidth;\n            this.surfer.params.height = newHeight - this.player.controlBar.height();\n\n            // redraw waveform\n            this.surfer.createDrawer();\n            this.surfer.drawer.wrapper.className = wavesurferClassName;\n            this.surfer.drawBuffer();\n\n            // make sure playhead is restored at right position\n            this.surfer.drawer.progress(this.surfer.backend.getPlayedPercents());\n        }\n    }\n\n    /**\n     * Log message to console (if the debug option is enabled).\n     *\n     * @private\n     * @param {Array} args - The arguments to be passed to the matching console\n     *     method.\n     * @param {string} logType - The name of the console method to use.\n     */\n    log(args, logType) {\n        log(args, logType, this.debug);\n    }\n}\n\n// version nr is injected during build\nWavesurfer.VERSION = __VERSION__;\n\n// register plugin once\nvideojs.Wavesurfer = Wavesurfer;\nif (videojs.getPlugin('wavesurfer') === undefined) {\n    videojs.registerPlugin('wavesurfer', Wavesurfer);\n}\n\nmodule.exports = {\n    Wavesurfer\n};\n","/**\n * @file log.js\n * @since 2.0.0\n */\n\nconst ERROR = 'error';\nconst WARN = 'warn';\n\n/**\n * Log message (if the debug option is enabled).\n *\n * @private\n * @param {Array} args - The arguments to be passed to the matching console\n *     method.\n * @param {string} logType - The name of the console method to use.\n * @param {boolean} debug - Whether or not the debug option is enabled or not.\n */\nconst log = function(args, logType, debug)\n{\n    if (debug === true) {\n        if (logType === ERROR) {\n            videojs.log.error(args);\n        } else if (logType === WARN) {\n            videojs.log.warn(args);\n        } else {\n            videojs.log(args);\n        }\n    }\n};\n\nexport default log;\n","/**\n * @file format-time.js\n * @since 2.0.0\n */\n\n/**\n * Format seconds as a time string, H:MM:SS, M:SS or M:SS:MMM.\n *\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide.\n *\n * @param {number} seconds - Number of seconds to be turned into a\n *     string.\n * @param {number} guide - Number (in seconds) to model the string\n *     after.\n * @param {number} msDisplayMax - Number (in milliseconds) to model the string\n *     after.\n * @return {string} Time formatted as H:MM:SS, M:SS or M:SS:MMM, e.g.\n *     0:00:12.\n * @private\n */\nconst formatTime = function(seconds, guide, msDisplayMax) {\n    // Default to using seconds as guide\n    seconds = seconds < 0 ? 0 : seconds;\n    guide = guide || seconds;\n    let s = Math.floor(seconds % 60),\n        m = Math.floor(seconds / 60 % 60),\n        h = Math.floor(seconds / 3600),\n        gm = Math.floor(guide / 60 % 60),\n        gh = Math.floor(guide / 3600),\n        ms = Math.floor((seconds - s) * 1000);\n\n    // handle invalid times\n    if (isNaN(seconds) || seconds === Infinity) {\n        // '-' is false for all relational operators (e.g. <, >=) so this\n        // setting will add the minimum number of fields specified by the\n        // guide\n        h = m = s = ms = '-';\n    }\n\n    // Check if we need to show milliseconds\n    if (guide > 0 && guide < msDisplayMax) {\n        if (ms < 100) {\n            if (ms < 10) {\n                ms = '00' + ms;\n            } else {\n                ms = '0' + ms;\n            }\n        }\n        ms = ':' + ms;\n    } else {\n        ms = '';\n    }\n\n    // Check if we need to show hours\n    h = (h > 0 || gh > 0) ? h + ':' : '';\n\n    // If hours are showing, we may need to add a leading zero.\n    // Always show at least one digit of minutes.\n    m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';\n\n    // Check if leading zero is need for seconds\n    s = ((s < 10) ? '0' + s : s);\n\n    return h + m + s + ms;\n};\n\nexport default formatTime;\n","/**\n * @file defaults.js\n * @since 2.0.0\n */\n\n// plugin defaults\nconst pluginDefaultOptions = {\n    // Display console log messages.\n    debug: false,\n    // msDisplayMax indicates the number of seconds that is\n    // considered the boundary value for displaying milliseconds\n    // in the time controls. An audio clip with a total length of\n    // 2 seconds and a msDisplayMax of 3 will use the format\n    // M:SS:MMM. Clips longer than msDisplayMax will be displayed\n    // as M:SS or HH:MM:SS.\n    msDisplayMax: 3\n};\n\nexport default pluginDefaultOptions;\n","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;"],"sourceRoot":""}