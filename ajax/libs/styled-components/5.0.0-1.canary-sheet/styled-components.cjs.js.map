{"version":3,"file":"styled-components.cjs.js","sources":["../src/constants.js","../src/sheet/Tag.js","../src/sheet/GroupIDAllocator.js","../src/sheet/Sheet.js","../src/utils/once.js","../src/models/ThemeProvider.js","../src/models/StyledComponent.js","../src/models/GlobalStyle.js","../src/constructors/createGlobalStyle.js","../src/models/ServerStyleSheet.js"],"sourcesContent":["// @flow\n\ndeclare var SC_DISABLE_SPEEDY: ?boolean;\ndeclare var __VERSION__: string;\n\nexport const SC_ATTR = (typeof process !== 'undefined' && process.env.SC_ATTR) || 'data-styled';\nexport const SC_ATTR_ACTIVE = 'active';\nexport const SC_VERSION_ATTR = 'data-styled-version';\nexport const SC_VERSION = __VERSION__;\n\nexport const IS_BROWSER = typeof window !== 'undefined' && 'HTMLElement' in window;\n\nexport const DISABLE_SPEEDY =\n  (typeof SC_DISABLE_SPEEDY === 'boolean' && SC_DISABLE_SPEEDY) ||\n  process.env.NODE_ENV !== 'production';\n\n// Shared empty execution context when generating static styles\nexport const STATIC_EXECUTION_CONTEXT = {};\n","// @flow\n/* eslint-disable no-use-before-define */\n\nimport { DISABLE_SPEEDY, IS_BROWSER } from '../constants';\nimport { makeStyleTag, getSheet } from './dom';\n\n/** CSSStyleSheet-like Tag abstraction for CSS rules */\nexport interface Tag {\n  constructor(target?: HTMLElement): void;\n  insertRule(index: number, rule: string): boolean;\n  deleteRule(index: number): void;\n  getRule(index: number): string;\n  length: number;\n}\n\n/** Create a CSSStyleSheet-like tag depending on the environment */\nexport const makeTag = (isServer: boolean, target?: HTMLElement): Tag => {\n  if (!IS_BROWSER) {\n    return new VirtualTag(target);\n  } else if (DISABLE_SPEEDY) {\n    return new TextTag(target);\n  } else {\n    return new SpeedyTag(target);\n  }\n};\n\n/** A Tag that wraps CSSOM's CSSStyleSheet API directly */\nclass SpeedyTag implements Tag {\n  element: HTMLStyleElement;\n\n  sheet: CSSStyleSheet;\n\n  length: number;\n\n  constructor(target?: HTMLElement) {\n    const element = (this.element = makeStyleTag(target));\n\n    // Avoid Edge bug where empty style elements don't create sheets\n    element.appendChild(document.createTextNode(''));\n\n    this.sheet = getSheet(element);\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    try {\n      this.sheet.insertRule(rule, index);\n      this.length++;\n      return true;\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.sheet.deleteRule(index);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.sheet.cssRules[index].cssText;\n    } else {\n      return '';\n    }\n  }\n}\n\n/** A Tag that emulates the CSSStyleSheet API but uses text nodes */\nclass TextTag implements Tag {\n  element: HTMLStyleElement;\n\n  nodes: NodeList<Node>;\n\n  length: number;\n\n  constructor(target?: HTMLElement) {\n    const element = (this.element = makeStyleTag(target));\n    this.nodes = element.childNodes;\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    if (index <= this.length && index >= 0) {\n      const node = document.createTextNode(rule);\n      const refNode = this.nodes[index];\n      this.element.insertBefore(node, refNode || null);\n      this.length++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.element.removeChild(this.nodes[index]);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.nodes[index].textContent;\n    } else {\n      return '';\n    }\n  }\n}\n\n/** A completely virtual (server-side) Tag that doesn't manipulate the DOM */\nclass VirtualTag implements Tag {\n  rules: string[];\n\n  length: number;\n\n  constructor(_target?: HTMLElement) {\n    this.rules = [];\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    if (index <= this.length) {\n      this.rules.splice(index, 0, rule);\n      this.length++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.rules.splice(index, 1);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.rules[index];\n    } else {\n      return '';\n    }\n  }\n}\n","// @flow\n\nlet groupIDRegister: Map<string, number> = new Map();\nlet reverseRegister: Map<number, string> = new Map();\nlet nextFreeGroup = 1;\n\nexport const resetGroupIds = () => {\n  groupIDRegister = new Map();\n  reverseRegister = new Map();\n  nextFreeGroup = 1;\n};\n\nexport const getGroupForId = (id: string): number => {\n  if (groupIDRegister.has(id)) {\n    return (groupIDRegister.get(id): any);\n  }\n\n  const group = nextFreeGroup++;\n  groupIDRegister.set(id, group);\n  reverseRegister.set(group, id);\n  return group;\n};\n\nexport const getIdForGroup = (group: number): void | string => {\n  return reverseRegister.get(group);\n};\n\nexport const setGroupForId = (id: string, group: number) => {\n  if (group >= nextFreeGroup) {\n    nextFreeGroup = group + 1;\n  }\n\n  groupIDRegister.set(id, group);\n  reverseRegister.set(group, id);\n};\n","// @flow\n\nimport { IS_BROWSER } from '../constants';\nimport type { Sheet } from './types';\nimport { makeTag } from './Tag';\nimport { type GroupedTag, makeGroupedTag } from './GroupedTag';\nimport { getGroupForId } from './GroupIDAllocator';\nimport { outputSheet, rehydrateSheet } from './Rehydration';\n\nlet SHOULD_REHYDRATE = IS_BROWSER;\n\n/** Contains the main stylesheet logic for stringification and caching */\nclass StyleSheet implements Sheet {\n  isServer: boolean;\n\n  target: void | HTMLElement;\n\n  tag: void | GroupedTag;\n\n  names: Map<string, Set<string>>;\n\n  /** Register a group ID to give it an index */\n  static registerId(id: string): number {\n    return getGroupForId(id);\n  }\n\n  constructor(isServer: boolean, target?: HTMLElement) {\n    this.names = new Map();\n    this.isServer = isServer;\n    this.target = target;\n\n    // We rehydrate only once and use the sheet that is\n    // created first\n    if (!isServer && IS_BROWSER && SHOULD_REHYDRATE) {\n      SHOULD_REHYDRATE = false;\n      rehydrateSheet(this);\n    }\n  }\n\n  /** Lazily initialises a GroupedTag for when it's actually needed */\n  getTag(): GroupedTag {\n    if (this.tag === undefined) {\n      const tag = makeTag(this.isServer, this.target);\n      this.tag = makeGroupedTag(tag);\n    }\n\n    return this.tag;\n  }\n\n  /** Check whether a name is known for caching */\n  hasNameForId(id: string, name: string): boolean {\n    return this.names.has(id) && (this.names.get(id): any).has(name);\n  }\n\n  /** Mark a group's name as known for caching */\n  registerName(id: string, name: string) {\n    getGroupForId(id);\n\n    if (!this.names.has(id)) {\n      const groupNames = new Set();\n      groupNames.add(name);\n      this.names.set(id, groupNames);\n    } else {\n      (this.names.get(id): any).add(name);\n    }\n  }\n\n  /** Insert new rules which also marks the name as known */\n  insertRules(id: string, name: string, rules: string[]) {\n    this.registerName(id, name);\n    this.getTag().insertRules(getGroupForId(id), rules);\n  }\n\n  /** Clears all cached names for a given group ID */\n  clearNames(id: string) {\n    if (this.names.has(id)) {\n      (this.names.get(id): any).clear();\n    }\n  }\n\n  /** Clears all rules for a given group ID */\n  clearRules(id: string) {\n    this.getTag().clearGroup(getGroupForId(id));\n    this.clearNames(id);\n  }\n\n  /** Clears the entire tag which deletes all rules but not its names */\n  clearTag() {\n    // NOTE: This does not clear the names, since it's only used during SSR\n    // so that we can continuously output only new rules\n    this.tag = undefined;\n  }\n\n  /** Outputs the current sheet as a CSS string with markers for SSR */\n  toString(): string {\n    return outputSheet(this);\n  }\n}\n\nexport default StyleSheet;\n","// @flow\n// Helper to call a given function, only once\nexport default <F: (...any[]) => void>(cb: F): F => {\n  let called = false;\n\n  // $FlowFixMe this works if F is \"(...any[]) => any\" but that would imply the return value si forwarded\n  return (...args) => {\n    if (!called) {\n      called = true;\n      cb(...args);\n    }\n  };\n};\n","// @flow\nimport React, { useContext, type Element, type Context } from 'react';\nimport StyledError from '../utils/error';\nimport isFunction from '../utils/isFunction';\n\nexport type Theme = { [key: string]: mixed };\n\ntype Props = {\n  children?: Element<any>,\n  theme: Theme | ((outerTheme: Theme) => void),\n};\n\nexport const ThemeContext: Context<Theme | void> = React.createContext();\n\nexport const ThemeConsumer = ThemeContext.Consumer;\n\nfunction useMergedTheme(theme: Theme | ((outerTheme?: Theme) => Theme), outerTheme?: Theme): Theme {\n  if (isFunction(theme)) {\n    const mergedTheme = theme(outerTheme);\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      (mergedTheme === null || Array.isArray(mergedTheme) || typeof mergedTheme !== 'object')\n    ) {\n      throw new StyledError(7);\n    }\n\n    return mergedTheme;\n  }\n\n  if (theme === null || Array.isArray(theme) || typeof theme !== 'object') {\n    throw new StyledError(8);\n  }\n\n  return outerTheme ? { ...outerTheme, ...theme } : theme;\n}\n\n/**\n * Provide a theme to an entire react component tree via context\n */\nexport default function ThemeProvider(props: Props) {\n  const outerTheme = useContext(ThemeContext);\n  // NOTE: can't really memoize with props.theme as that'd cause incorrect memoization when it's a function\n  const themeContext = useMergedTheme(props.theme, outerTheme);\n\n  if (!props.children) {\n    return null;\n  }\n\n  return (\n    <ThemeContext.Provider value={themeContext}>\n      {React.Children.only(props.children)}\n    </ThemeContext.Provider>\n  );\n}\n","// @flow\nimport validAttr from '@emotion/is-prop-valid';\nimport React, {\n  createElement,\n  useContext,\n  useState,\n  useDebugValue,\n  type AbstractComponent,\n  type Ref,\n} from 'react';\nimport ComponentStyle from './ComponentStyle';\nimport createWarnTooManyClasses from '../utils/createWarnTooManyClasses';\nimport determineTheme from '../utils/determineTheme';\nimport escape from '../utils/escape';\nimport generateDisplayName from '../utils/generateDisplayName';\nimport getComponentName from '../utils/getComponentName';\nimport hoist from '../utils/hoist';\nimport isFunction from '../utils/isFunction';\nimport isTag from '../utils/isTag';\nimport isDerivedReactComponent from '../utils/isDerivedReactComponent';\nimport isStyledComponent from '../utils/isStyledComponent';\nimport once from '../utils/once';\nimport hasher from '../utils/hasher';\nimport { ThemeContext } from './ThemeProvider';\nimport { useStyleSheet } from './StyleSheetManager';\nimport { EMPTY_ARRAY, EMPTY_OBJECT } from '../utils/empties';\n// import useCheckClassNameUsage from '../utils/useCheckClassNameUsage';\n\nimport type { Attrs, RuleSet, Target } from '../types';\n\n/* global $Call */\n\nconst identifiers = {};\n\n/* We depend on components having unique IDs */\nfunction generateId(displayName: string, parentComponentId: string) {\n  const name = typeof displayName !== 'string' ? 'sc' : escape(displayName);\n  // Ensure that no displayName can lead to duplicate componentIds\n  const nr = (identifiers[name] || 0) + 1;\n  identifiers[name] = nr;\n  const componentId = `${name}-${hasher(name + nr)}`;\n  return parentComponentId ? `${parentComponentId}-${componentId}` : componentId;\n}\n\nfunction useResolvedAttrs<Config>(theme: any = EMPTY_OBJECT, props: Config, attrs: Attrs, utils) {\n  // NOTE: can't memoize this\n  // returns [context, resolvedAttrs]\n  // where resolvedAttrs is only the things injected by the attrs themselves\n  const context = { ...props, theme };\n  const resolvedAttrs = {};\n  attrs.forEach(attrDef => {\n    let resolvedAttrDef = attrDef;\n    let attrDefWasFn = false;\n    let attr;\n    let key;\n\n    if (isFunction(resolvedAttrDef)) {\n      resolvedAttrDef = resolvedAttrDef(context);\n      attrDefWasFn = true;\n    }\n\n    /* eslint-disable guard-for-in */\n    for (key in resolvedAttrDef) {\n      attr = resolvedAttrDef[key];\n\n      if (!attrDefWasFn) {\n        if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {\n          if (process.env.NODE_ENV !== 'production') {\n            utils.warnAttrsFnObjectKeyDeprecated(key);\n          }\n\n          attr = attr(context);\n\n          if (process.env.NODE_ENV !== 'production' && React.isValidElement(attr)) {\n            utils.warnNonStyledComponentAttrsObjectKey(key);\n          }\n        }\n      }\n\n      resolvedAttrs[key] = attr;\n      context[key] = attr;\n    }\n    /* eslint-enable */\n  });\n\n  return [context, resolvedAttrs];\n}\n\ninterface StyledComponentWrapperProperties {\n  attrs: Attrs;\n  componentStyle: ComponentStyle;\n  foldedComponentIds: Array<string>;\n  target: Target;\n  styledComponentId: string;\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string>;\n}\n\ntype StyledComponentWrapper<Config, Instance> = AbstractComponent<Config, Instance> &\n  StyledComponentWrapperProperties;\n\nfunction useInjectedStyle<T>(\n  componentStyle: ComponentStyle,\n  hasAttrs: boolean,\n  resolvedAttrs: T,\n  utils,\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string>\n) {\n  const styleSheet = useStyleSheet();\n\n  // statically styled-components don't need to build an execution context object,\n  // and shouldn't be increasing the number of class names\n  const isStatic = componentStyle.isStatic && !hasAttrs;\n  const className = isStatic\n    ? componentStyle.generateAndInjectStyles(EMPTY_OBJECT, styleSheet)\n    : componentStyle.generateAndInjectStyles(resolvedAttrs, styleSheet);\n\n  if (process.env.NODE_ENV !== 'production' && !isStatic && warnTooManyClasses) {\n    warnTooManyClasses(className);\n  }\n\n  useDebugValue(className);\n\n  return className;\n}\n\n// TODO: convert these all to individual hooks, if possible\nfunction developmentDeprecationWarningsFactory(displayNameArg: ?string) {\n  const displayName = displayNameArg || 'Unknown';\n  return {\n    warnInnerRef: once(() =>\n      // eslint-disable-next-line no-console\n      console.warn(\n        `The \"innerRef\" API has been removed in styled-components v4 in favor of React 16 ref forwarding, use \"ref\" instead like a typical component. \"innerRef\" was detected on component \"${displayName}\".`\n      )\n    ),\n    warnAttrsFnObjectKeyDeprecated: once(\n      (key: string): void =>\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Functions as object-form attrs({}) keys are now deprecated and will be removed in a future version of styled-components. Switch to the new attrs(props => ({})) syntax instead for easier and more powerful composition. The attrs key in question is \"${key}\" on component \"${displayName}\".`\n        )\n    ),\n    warnNonStyledComponentAttrsObjectKey: once(\n      (key: string): void =>\n        // eslint-disable-next-line no-console\n        console.warn(\n          `It looks like you've used a non styled-component as the value for the \"${key}\" prop in an object-form attrs constructor of \"${displayName}\".\\n` +\n            'You should use the new function-form attrs constructor which avoids this issue: attrs(props => ({ yourStuff }))\\n' +\n            \"To continue using the deprecated object syntax, you'll need to wrap your component prop in a function to make it available inside the styled component (you'll still get the deprecation warning though.)\\n\" +\n            `For example, { ${key}: () => InnerComponent } instead of { ${key}: InnerComponent }`\n        )\n    ),\n  };\n}\n\nfunction useDevelopmentDeprecationWarnings(\n  displayName: ?string\n): $Call<typeof developmentDeprecationWarningsFactory, string> {\n  return useState(() => developmentDeprecationWarningsFactory(displayName))[0];\n}\n\nconst useDeprecationWarnings =\n  process.env.NODE_ENV !== 'production'\n    ? useDevelopmentDeprecationWarnings\n    : // NOTE: return value must only be accessed in non-production, of course\n      // $FlowFixMe\n      (() => {}: typeof useDevelopmentDeprecationWarnings);\n\nfunction useStyledComponentImpl<Config: {}, Instance>(\n  forwardedComponent: StyledComponentWrapper<Config, Instance>,\n  props: Config,\n  forwardedRef: Ref<any>\n) {\n  const {\n    attrs: componentAttrs,\n    componentStyle,\n    // $FlowFixMe\n    defaultProps,\n    displayName,\n    foldedComponentIds,\n    styledComponentId,\n    target,\n  } = forwardedComponent;\n\n  // NOTE: the non-hooks version only subscribes to this when !componentStyle.isStatic,\n  // but that'd be against the rules-of-hooks. We could be naughty and do it anyway as it\n  // should be an immutable value, but behave for now.\n  const theme = determineTheme((props: any), useContext(ThemeContext), defaultProps);\n\n  const utils = useDeprecationWarnings(displayName);\n  const [context, attrs] = useResolvedAttrs(theme, props, componentAttrs, utils);\n\n  const generatedClassName = useInjectedStyle(\n    componentStyle,\n    componentAttrs.length > 0,\n    context,\n    utils,\n    process.env.NODE_ENV !== 'production' ? forwardedComponent.warnTooManyClasses : (undefined: any)\n  );\n\n  // NOTE: this has to be called unconditionally due to the rules of hooks\n  // it will just do nothing if it's not an in-browser development build\n  // NOTE2: there is no (supported) way to know if the wrapped component actually can\n  // receive refs -- just passing refs will trigger warnings on any function component child :(\n  // -- this also means we can't keep doing this check unless StyledComponent is itself a class.\n  //\n  // const refToForward = useCheckClassNameUsage(\n  //   forwardedRef,\n  //   target,\n  //   generatedClassName,\n  //   attrs.suppressClassNameWarning\n  // );\n  const refToForward = forwardedRef;\n\n  const elementToBeCreated: Target =\n    // $FlowFixMe\n    props.as || // eslint-disable-line react/prop-types\n    attrs.as ||\n    target;\n  const isTargetTag = isTag(elementToBeCreated);\n\n  const computedProps = attrs !== props ? { ...attrs, ...props } : props;\n  const shouldFilterProps = 'as' in computedProps || isTargetTag;\n  const propsForElement = shouldFilterProps ? {} : { ...computedProps };\n\n  if (process.env.NODE_ENV !== 'production' && 'innerRef' in computedProps && isTargetTag) {\n    utils.warnInnerRef();\n  }\n  if (shouldFilterProps) {\n    // eslint-disable-next-line guard-for-in\n    for (const key in computedProps) {\n      if (key !== 'as' && (!isTargetTag || validAttr(key))) {\n        // Don't pass through non HTML tags through to HTML elements\n        propsForElement[key] = computedProps[key];\n      }\n    }\n  }\n\n  if (\n    // $FlowFixMe\n    props.style && // eslint-disable-line react/prop-types\n    attrs.style !== props.style // eslint-disable-line react/prop-types\n  ) {\n    // $FlowFixMe\n    propsForElement.style = { ...attrs.style, ...props.style }; // eslint-disable-line react/prop-types\n  }\n\n  // $FlowFixMe\n  propsForElement.className = Array.prototype\n    .concat(\n      foldedComponentIds,\n      // $FlowFixMe\n      props.className, // eslint-disable-line react/prop-types\n      styledComponentId,\n      attrs.className,\n      generatedClassName\n    )\n    .filter(Boolean)\n    .join(' ');\n  // $FlowFixMe\n  propsForElement.ref = refToForward;\n\n  useDebugValue(styledComponentId);\n\n  return createElement(elementToBeCreated, propsForElement);\n}\n\nexport default function createStyledComponent(\n  target: Target | StyledComponentWrapper<*, *>,\n  options: Object,\n  rules: RuleSet\n) {\n  const isTargetStyledComp = isStyledComponent(target);\n  const isCompositeComponent = !isTag(target);\n\n  const {\n    displayName = generateDisplayName(target),\n    componentId = generateId(options.displayName, options.parentComponentId),\n    attrs = EMPTY_ARRAY,\n  } = options;\n\n  const styledComponentId =\n    options.displayName && options.componentId\n      ? `${escape(options.displayName)}-${options.componentId}`\n      : options.componentId || componentId;\n\n  // fold the underlying StyledComponent attrs up (implicit extend)\n  const finalAttrs =\n    // $FlowFixMe\n    isTargetStyledComp && target.attrs\n      ? Array.prototype.concat(target.attrs, attrs).filter(Boolean)\n      : attrs;\n\n  const componentStyle = new ComponentStyle(\n    isTargetStyledComp\n      ? // fold the underlying StyledComponent rules up (implicit extend)\n        // $FlowFixMe\n        target.componentStyle.rules.concat(rules)\n      : rules,\n    finalAttrs,\n    styledComponentId\n  );\n\n  /**\n   * forwardRef creates a new interim component, which we'll take advantage of\n   * instead of extending ParentComponent to create _another_ interim class\n   */\n  // $FlowFixMe this is a forced cast to merge it StyledComponentWrapperProperties\n  const WrappedStyledComponent: StyledComponentWrapper<*, *> = React.forwardRef((props, ref) =>\n    useStyledComponentImpl(WrappedStyledComponent, props, ref)\n  );\n\n  WrappedStyledComponent.attrs = finalAttrs;\n  WrappedStyledComponent.componentStyle = componentStyle;\n  WrappedStyledComponent.displayName = displayName;\n\n  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp\n    ? // $FlowFixMe\n      Array.prototype.concat(target.foldedComponentIds, target.styledComponentId)\n    : EMPTY_ARRAY;\n\n  WrappedStyledComponent.styledComponentId = styledComponentId;\n\n  // fold the underlying StyledComponent target up since we folded the styles\n  WrappedStyledComponent.target = isTargetStyledComp\n    ? // $FlowFixMe\n      target.target\n    : target;\n\n  // $FlowFixMe\n  WrappedStyledComponent.withComponent = function withComponent(tag: Target) {\n    const { componentId: previousComponentId, ...optionsToCopy } = options;\n\n    const newComponentId =\n      previousComponentId &&\n      `${previousComponentId}-${isTag(tag) ? tag : escape(getComponentName(tag))}`;\n\n    const newOptions = {\n      ...optionsToCopy,\n      attrs: finalAttrs,\n      componentId: newComponentId,\n    };\n\n    return createStyledComponent(tag, newOptions, rules);\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName);\n  }\n\n  // $FlowFixMe\n  WrappedStyledComponent.toString = () => `.${WrappedStyledComponent.styledComponentId}`;\n\n  if (isCompositeComponent) {\n    hoist(WrappedStyledComponent, target, {\n      // all SC-specific things should not be hoisted\n      attrs: true,\n      componentStyle: true,\n      displayName: true,\n      foldedComponentIds: true,\n      styledComponentId: true,\n      target: true,\n      withComponent: true,\n    });\n  }\n\n  return WrappedStyledComponent;\n}\n","// @flow\nimport { EMPTY_ARRAY } from '../utils/empties';\nimport flatten from '../utils/flatten';\nimport isStaticRules from '../utils/isStaticRules';\nimport stringifyRules from '../utils/stringifyRules';\nimport StyleSheet from '../sheet';\n\nimport type { RuleSet } from '../types';\n\nexport default class GlobalStyle {\n  componentId: string;\n\n  isStatic: boolean;\n\n  rules: RuleSet;\n\n  constructor(rules: RuleSet, componentId: string) {\n    this.rules = rules;\n    this.componentId = componentId;\n    this.isStatic = isStaticRules(rules, EMPTY_ARRAY);\n    StyleSheet.registerId(componentId);\n  }\n\n  createStyles(executionContext: Object, styleSheet: StyleSheet) {\n    const flatCSS = flatten(this.rules, executionContext, styleSheet);\n    const css = stringifyRules(flatCSS.join(''), '');\n    const id = this.componentId;\n\n    // NOTE: We use the id as a name as well, since these rules never change\n    styleSheet.insertRules(id, id, css);\n  }\n\n  removeStyles(styleSheet: StyleSheet) {\n    styleSheet.clearRules(this.componentId);\n  }\n\n  renderStyles(executionContext: Object, styleSheet: StyleSheet) {\n    // NOTE: Remove old styles, then inject the new ones\n    this.removeStyles(styleSheet);\n    this.createStyles(executionContext, styleSheet);\n  }\n}\n","// @flow\nimport React, { useContext, useEffect } from 'react';\nimport { IS_BROWSER, STATIC_EXECUTION_CONTEXT } from '../constants';\nimport GlobalStyle from '../models/GlobalStyle';\nimport { useStyleSheet } from '../models/StyleSheetManager';\nimport determineTheme from '../utils/determineTheme';\nimport { ThemeContext } from '../models/ThemeProvider';\nimport hasher from '../utils/hasher';\nimport css from './css';\n\nimport type { Interpolation } from '../types';\n\ntype GlobalStyleComponentPropsType = Object;\n\n// place our cache into shared context so it'll persist between HMRs\nif (IS_BROWSER) {\n  window.scCGSHMRCache = {};\n}\n\nexport default function createGlobalStyle(\n  strings: Array<string>,\n  ...interpolations: Array<Interpolation>\n) {\n  const rules = css(strings, ...interpolations);\n  const styledComponentId = `sc-global-${hasher(JSON.stringify(rules))}`;\n  const globalStyle = new GlobalStyle(rules, styledComponentId);\n\n  function GlobalStyleComponent(props: GlobalStyleComponentPropsType) {\n    const styleSheet = useStyleSheet();\n    const theme = useContext(ThemeContext);\n\n    if (process.env.NODE_ENV !== 'production' && React.Children.count(props.children)) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `The global style component ${styledComponentId} was given child JSX. createGlobalStyle does not render children.`\n      );\n    }\n\n    if (globalStyle.isStatic) {\n      globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, styleSheet);\n    } else {\n      const context = {\n        ...props,\n      };\n\n      if (typeof theme !== 'undefined') {\n        context.theme = determineTheme(props, theme);\n      }\n\n      globalStyle.renderStyles(context, styleSheet);\n    }\n\n    useEffect(() => {\n      if (IS_BROWSER) {\n        window.scCGSHMRCache[styledComponentId] =\n          (window.scCGSHMRCache[styledComponentId] || 0) + 1;\n\n        return () => {\n          if (window.scCGSHMRCache[styledComponentId]) {\n            window.scCGSHMRCache[styledComponentId] -= 1;\n          }\n          /**\n           * Depending on the order \"render\" is called this can cause the styles to be lost\n           * until the next render pass of the remaining instance, which may\n           * not be immediate.\n           */\n          if (window.scCGSHMRCache[styledComponentId] === 0) {\n            globalStyle.removeStyles(styleSheet);\n          }\n        };\n      }\n      return undefined;\n    }, []);\n\n    return null;\n  }\n\n  return GlobalStyleComponent;\n}\n","// @flow\n/* eslint-disable no-underscore-dangle */\n\nimport React from 'react';\n\nimport {\n  IS_BROWSER,\n  SC_ATTR,\n  SC_VERSION_ATTR,\n  SC_VERSION\n} from '../constants';\n\nimport StyledError from '../utils/error';\nimport getNonce from '../utils/nonce';\nimport StyleSheet from '../sheet';\nimport StyleSheetManager from './StyleSheetManager';\n\ndeclare var __SERVER__: boolean;\n\nconst CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\n\nexport default class ServerStyleSheet {\n  sheet: StyleSheet;\n\n  sealed: boolean;\n\n  constructor() {\n    this.sheet = new StyleSheet(true);\n    this.sealed = false;\n  }\n\n  collectStyles(children: any) {\n    if (this.sealed) {\n      throw new StyledError(2);\n    }\n\n    this.sealed = true;\n    return <StyleSheetManager sheet={this.sheet}>{children}</StyleSheetManager>;\n  }\n\n  getStyleTags = (): string => {\n    const css = this.sheet.toString();\n    const nonce = getNonce();\n    const attrs = [\n      nonce && `nonce=\"${nonce}\"`,\n      SC_ATTR,\n      `${SC_VERSION_ATTR}=\"${SC_VERSION}\"`\n    ];\n\n    const htmlAttr = attrs.filter(Boolean).join(' ');\n    return `<style ${htmlAttr}>${css}</style>`;\n  }\n\n  getStyleElement = () => {\n    const props = {\n      [SC_ATTR]: '',\n      [SC_VERSION_ATTR]: SC_VERSION,\n      dangerouslySetInnerHTML: {\n        __html: this.sheet.toString()\n      }\n    };\n\n    const nonce = getNonce();\n    if (nonce) {\n      (props: any).nonce = nonce;\n    }\n\n    return <style {...props} />;\n  }\n\n  interleaveWithNodeStream(input: any) {\n    if (!__SERVER__ || IS_BROWSER) {\n      throw new StyledError(3);\n    }\n\n    // eslint-disable-next-line global-require\n    const { Readable, Transform } = require('stream');\n\n    const readableStream: Readable = input;\n    const { sheet, getStyleTags } = this;\n\n    const transformer = new Transform({\n      transform: function appendStyleChunks(chunk, /* encoding */ _, callback) {\n        // Get the chunk and retrieve the sheet's CSS as an HTML chunk,\n        // then reset its rules so we get only new ones for the next chunk\n        const renderedHtml = chunk.toString();\n        const html = getStyleTags();\n        sheet.clearTag();\n\n        // prepend style html to chunk, unless the start of the chunk is a\n        // closing tag in which case append right after that\n        if (CLOSING_TAG_R.test(renderedHtml)) {\n          const endOfClosingTag = renderedHtml.indexOf('>') + 1;\n          const before = renderedHtml.slice(0, endOfClosingTag);\n          const after = renderedHtml.slice(endOfClosingTag);\n\n          this.push(before + html + after);\n        } else {\n          this.push(html + renderedHtml);\n        }\n\n        callback();\n      },\n    });\n\n    readableStream.on('error', err => {\n      // forward the error to the transform stream\n      transformer.emit('error', err);\n    });\n\n    return readableStream.pipe(transformer);\n  }\n}\n"],"names":["target","nodes","insertRule","add","cb","isCompositeComponent"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BC2B9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAuCsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAyBEC;;;;;;;;;;;;;;;;;;;;;UAgBxBC,aAAA,yBAAA,MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBC5GiB;mBACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BCcjB,sBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAsCuBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBCrDVC;;;;;;;;;;;;;;;;2BCcuD,WAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC4P9DC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BChQN,aAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBCSiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBCyDK,aAAA;;;;;;;;;;;;;;;;;;;;;;KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}