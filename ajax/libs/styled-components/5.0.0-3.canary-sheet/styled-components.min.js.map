{"version":3,"file":"styled-components.min.js","sources":["../src/sheet/Tag.js","../src/sheet/Sheet.js","../src/models/StyledComponent.js"],"sourcesContent":["// @flow\n/* eslint-disable no-use-before-define */\n\nimport { DISABLE_SPEEDY, IS_BROWSER } from '../constants';\nimport { makeStyleTag, getSheet } from './dom';\n\n/** CSSStyleSheet-like Tag abstraction for CSS rules */\nexport interface Tag {\n  constructor(target?: HTMLElement): void;\n  insertRule(index: number, rule: string): boolean;\n  deleteRule(index: number): void;\n  getRule(index: number): string;\n  length: number;\n}\n\n/** Create a CSSStyleSheet-like tag depending on the environment */\nexport const makeTag = (isServer: boolean, target?: HTMLElement): Tag => {\n  if (!IS_BROWSER) {\n    return new VirtualTag(target);\n  } else if (DISABLE_SPEEDY) {\n    return new TextTag(target);\n  } else {\n    return new SpeedyTag(target);\n  }\n};\n\n/** A Tag that wraps CSSOM's CSSStyleSheet API directly */\nclass SpeedyTag implements Tag {\n  element: HTMLStyleElement;\n\n  sheet: CSSStyleSheet;\n\n  length: number;\n\n  constructor(target?: HTMLElement) {\n    const element = (this.element = makeStyleTag(target));\n\n    // Avoid Edge bug where empty style elements don't create sheets\n    element.appendChild(document.createTextNode(''));\n\n    this.sheet = getSheet(element);\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    try {\n      this.sheet.insertRule(rule, index);\n      this.length++;\n      return true;\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.sheet.deleteRule(index);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.sheet.cssRules[index].cssText;\n    } else {\n      return '';\n    }\n  }\n}\n\n/** A Tag that emulates the CSSStyleSheet API but uses text nodes */\nclass TextTag implements Tag {\n  element: HTMLStyleElement;\n\n  nodes: NodeList<Node>;\n\n  length: number;\n\n  constructor(target?: HTMLElement) {\n    const element = (this.element = makeStyleTag(target));\n    this.nodes = element.childNodes;\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    if (index <= this.length && index >= 0) {\n      const node = document.createTextNode(rule);\n      const refNode = this.nodes[index];\n      this.element.insertBefore(node, refNode || null);\n      this.length++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.element.removeChild(this.nodes[index]);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.nodes[index].textContent;\n    } else {\n      return '';\n    }\n  }\n}\n\n/** A completely virtual (server-side) Tag that doesn't manipulate the DOM */\nclass VirtualTag implements Tag {\n  rules: string[];\n\n  length: number;\n\n  constructor(_target?: HTMLElement) {\n    this.rules = [];\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    if (index <= this.length) {\n      this.rules.splice(index, 0, rule);\n      this.length++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.rules.splice(index, 1);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.rules[index];\n    } else {\n      return '';\n    }\n  }\n}\n","// @flow\n\nimport { IS_BROWSER } from '../constants';\nimport type { Sheet } from './types';\nimport { makeTag } from './Tag';\nimport { type GroupedTag, makeGroupedTag } from './GroupedTag';\nimport { getGroupForId } from './GroupIDAllocator';\nimport { outputSheet, rehydrateSheet } from './Rehydration';\n\nlet SHOULD_REHYDRATE = IS_BROWSER;\n\n/** Contains the main stylesheet logic for stringification and caching */\nclass StyleSheet implements Sheet {\n  isServer: boolean;\n\n  target: void | HTMLElement;\n\n  tag: void | GroupedTag;\n\n  names: Map<string, Set<string>>;\n\n  /** Register a group ID to give it an index */\n  static registerId(id: string): number {\n    return getGroupForId(id);\n  }\n\n  constructor(isServer: boolean, target?: HTMLElement) {\n    this.names = new Map();\n    this.isServer = isServer;\n    this.target = target;\n\n    // We rehydrate only once and use the sheet that is\n    // created first\n    if (!isServer && IS_BROWSER && SHOULD_REHYDRATE) {\n      SHOULD_REHYDRATE = false;\n      rehydrateSheet(this);\n    }\n  }\n\n  /** Lazily initialises a GroupedTag for when it's actually needed */\n  getTag(): GroupedTag {\n    if (this.tag === undefined) {\n      const tag = makeTag(this.isServer, this.target);\n      this.tag = makeGroupedTag(tag);\n    }\n\n    return this.tag;\n  }\n\n  /** Check whether a name is known for caching */\n  hasNameForId(id: string, name: string): boolean {\n    return this.names.has(id) && (this.names.get(id): any).has(name);\n  }\n\n  /** Mark a group's name as known for caching */\n  registerName(id: string, name: string) {\n    getGroupForId(id);\n\n    if (!this.names.has(id)) {\n      const groupNames = new Set();\n      groupNames.add(name);\n      this.names.set(id, groupNames);\n    } else {\n      (this.names.get(id): any).add(name);\n    }\n  }\n\n  /** Insert new rules which also marks the name as known */\n  insertRules(id: string, name: string, rules: string[]) {\n    this.registerName(id, name);\n    this.getTag().insertRules(getGroupForId(id), rules);\n  }\n\n  /** Clears all cached names for a given group ID */\n  clearNames(id: string) {\n    if (this.names.has(id)) {\n      (this.names.get(id): any).clear();\n    }\n  }\n\n  /** Clears all rules for a given group ID */\n  clearRules(id: string) {\n    this.getTag().clearGroup(getGroupForId(id));\n    this.clearNames(id);\n  }\n\n  /** Clears the entire tag which deletes all rules but not its names */\n  clearTag() {\n    // NOTE: This does not clear the names, since it's only used during SSR\n    // so that we can continuously output only new rules\n    this.tag = undefined;\n  }\n\n  /** Outputs the current sheet as a CSS string with markers for SSR */\n  toString(): string {\n    return outputSheet(this);\n  }\n}\n\nexport default StyleSheet;\n","// @flow\nimport validAttr from '@emotion/is-prop-valid';\nimport React, {\n  createElement,\n  useContext,\n  useState,\n  useDebugValue,\n  type AbstractComponent,\n  type Ref,\n} from 'react';\nimport ComponentStyle from './ComponentStyle';\nimport createWarnTooManyClasses from '../utils/createWarnTooManyClasses';\nimport determineTheme from '../utils/determineTheme';\nimport escape from '../utils/escape';\nimport generateDisplayName from '../utils/generateDisplayName';\nimport getComponentName from '../utils/getComponentName';\nimport hoist from '../utils/hoist';\nimport isFunction from '../utils/isFunction';\nimport isTag from '../utils/isTag';\nimport isDerivedReactComponent from '../utils/isDerivedReactComponent';\nimport isStyledComponent from '../utils/isStyledComponent';\nimport once from '../utils/once';\nimport hasher from '../utils/hasher';\nimport { ThemeContext } from './ThemeProvider';\nimport { useStyleSheet } from './StyleSheetManager';\nimport { EMPTY_ARRAY, EMPTY_OBJECT } from '../utils/empties';\n// import useCheckClassNameUsage from '../utils/useCheckClassNameUsage';\n\nimport type { Attrs, RuleSet, Target } from '../types';\n\n/* global $Call */\n\nconst identifiers = {};\n\n/* We depend on components having unique IDs */\nfunction generateId(displayName: string, parentComponentId: string) {\n  const name = typeof displayName !== 'string' ? 'sc' : escape(displayName);\n  // Ensure that no displayName can lead to duplicate componentIds\n  const nr = (identifiers[name] || 0) + 1;\n  identifiers[name] = nr;\n  const componentId = `${name}-${hasher(name + nr)}`;\n  return parentComponentId ? `${parentComponentId}-${componentId}` : componentId;\n}\n\nfunction useResolvedAttrs<Config>(theme: any = EMPTY_OBJECT, props: Config, attrs: Attrs, utils) {\n  // NOTE: can't memoize this\n  // returns [context, resolvedAttrs]\n  // where resolvedAttrs is only the things injected by the attrs themselves\n  const context = { ...props, theme };\n  const resolvedAttrs = {};\n  attrs.forEach(attrDef => {\n    let resolvedAttrDef = attrDef;\n    let attrDefWasFn = false;\n    let attr;\n    let key;\n\n    if (isFunction(resolvedAttrDef)) {\n      resolvedAttrDef = resolvedAttrDef(context);\n      attrDefWasFn = true;\n    }\n\n    /* eslint-disable guard-for-in */\n    for (key in resolvedAttrDef) {\n      attr = resolvedAttrDef[key];\n\n      if (!attrDefWasFn) {\n        if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {\n          if (process.env.NODE_ENV !== 'production') {\n            utils.warnAttrsFnObjectKeyDeprecated(key);\n          }\n\n          attr = attr(context);\n\n          if (process.env.NODE_ENV !== 'production' && React.isValidElement(attr)) {\n            utils.warnNonStyledComponentAttrsObjectKey(key);\n          }\n        }\n      }\n\n      resolvedAttrs[key] = attr;\n      context[key] = attr;\n    }\n    /* eslint-enable */\n  });\n\n  return [context, resolvedAttrs];\n}\n\ninterface StyledComponentWrapperProperties {\n  attrs: Attrs;\n  componentStyle: ComponentStyle;\n  foldedComponentIds: Array<string>;\n  target: Target;\n  styledComponentId: string;\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string>;\n}\n\ntype StyledComponentWrapper<Config, Instance> = AbstractComponent<Config, Instance> &\n  StyledComponentWrapperProperties;\n\nfunction useInjectedStyle<T>(\n  componentStyle: ComponentStyle,\n  hasAttrs: boolean,\n  resolvedAttrs: T,\n  utils,\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string>\n) {\n  const styleSheet = useStyleSheet();\n\n  // statically styled-components don't need to build an execution context object,\n  // and shouldn't be increasing the number of class names\n  const isStatic = componentStyle.isStatic && !hasAttrs;\n  const className = isStatic\n    ? componentStyle.generateAndInjectStyles(EMPTY_OBJECT, styleSheet)\n    : componentStyle.generateAndInjectStyles(resolvedAttrs, styleSheet);\n\n  if (process.env.NODE_ENV !== 'production' && !isStatic && warnTooManyClasses) {\n    warnTooManyClasses(className);\n  }\n\n  useDebugValue(className);\n\n  return className;\n}\n\n// TODO: convert these all to individual hooks, if possible\nfunction developmentDeprecationWarningsFactory(displayNameArg: ?string) {\n  const displayName = displayNameArg || 'Unknown';\n  return {\n    warnInnerRef: once(() =>\n      // eslint-disable-next-line no-console\n      console.warn(\n        `The \"innerRef\" API has been removed in styled-components v4 in favor of React 16 ref forwarding, use \"ref\" instead like a typical component. \"innerRef\" was detected on component \"${displayName}\".`\n      )\n    ),\n    warnAttrsFnObjectKeyDeprecated: once(\n      (key: string): void =>\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Functions as object-form attrs({}) keys are now deprecated and will be removed in a future version of styled-components. Switch to the new attrs(props => ({})) syntax instead for easier and more powerful composition. The attrs key in question is \"${key}\" on component \"${displayName}\".`\n        )\n    ),\n    warnNonStyledComponentAttrsObjectKey: once(\n      (key: string): void =>\n        // eslint-disable-next-line no-console\n        console.warn(\n          `It looks like you've used a non styled-component as the value for the \"${key}\" prop in an object-form attrs constructor of \"${displayName}\".\\n` +\n            'You should use the new function-form attrs constructor which avoids this issue: attrs(props => ({ yourStuff }))\\n' +\n            \"To continue using the deprecated object syntax, you'll need to wrap your component prop in a function to make it available inside the styled component (you'll still get the deprecation warning though.)\\n\" +\n            `For example, { ${key}: () => InnerComponent } instead of { ${key}: InnerComponent }`\n        )\n    ),\n  };\n}\n\nfunction useDevelopmentDeprecationWarnings(\n  displayName: ?string\n): $Call<typeof developmentDeprecationWarningsFactory, string> {\n  return useState(() => developmentDeprecationWarningsFactory(displayName))[0];\n}\n\nconst useDeprecationWarnings =\n  process.env.NODE_ENV !== 'production'\n    ? useDevelopmentDeprecationWarnings\n    : // NOTE: return value must only be accessed in non-production, of course\n      // $FlowFixMe\n      (() => {}: typeof useDevelopmentDeprecationWarnings);\n\nfunction useStyledComponentImpl<Config: {}, Instance>(\n  forwardedComponent: StyledComponentWrapper<Config, Instance>,\n  props: Config,\n  forwardedRef: Ref<any>\n) {\n  const {\n    attrs: componentAttrs,\n    componentStyle,\n    // $FlowFixMe\n    defaultProps,\n    displayName,\n    foldedComponentIds,\n    styledComponentId,\n    target,\n  } = forwardedComponent;\n\n  // NOTE: the non-hooks version only subscribes to this when !componentStyle.isStatic,\n  // but that'd be against the rules-of-hooks. We could be naughty and do it anyway as it\n  // should be an immutable value, but behave for now.\n  const theme = determineTheme((props: any), useContext(ThemeContext), defaultProps);\n\n  const utils = useDeprecationWarnings(displayName);\n  const [context, attrs] = useResolvedAttrs(theme, props, componentAttrs, utils);\n\n  const generatedClassName = useInjectedStyle(\n    componentStyle,\n    componentAttrs.length > 0,\n    context,\n    utils,\n    process.env.NODE_ENV !== 'production' ? forwardedComponent.warnTooManyClasses : (undefined: any)\n  );\n\n  // NOTE: this has to be called unconditionally due to the rules of hooks\n  // it will just do nothing if it's not an in-browser development build\n  // NOTE2: there is no (supported) way to know if the wrapped component actually can\n  // receive refs -- just passing refs will trigger warnings on any function component child :(\n  // -- this also means we can't keep doing this check unless StyledComponent is itself a class.\n  //\n  // const refToForward = useCheckClassNameUsage(\n  //   forwardedRef,\n  //   target,\n  //   generatedClassName,\n  //   attrs.suppressClassNameWarning\n  // );\n  const refToForward = forwardedRef;\n\n  const elementToBeCreated: Target =\n    // $FlowFixMe\n    props.as || // eslint-disable-line react/prop-types\n    attrs.as ||\n    target;\n  const isTargetTag = isTag(elementToBeCreated);\n\n  const computedProps = attrs !== props ? { ...attrs, ...props } : props;\n  const shouldFilterProps = 'as' in computedProps || isTargetTag;\n  const propsForElement = shouldFilterProps ? {} : { ...computedProps };\n\n  if (process.env.NODE_ENV !== 'production' && 'innerRef' in computedProps && isTargetTag) {\n    utils.warnInnerRef();\n  }\n  if (shouldFilterProps) {\n    // eslint-disable-next-line guard-for-in\n    for (const key in computedProps) {\n      if (key !== 'as' && (!isTargetTag || validAttr(key))) {\n        // Don't pass through non HTML tags through to HTML elements\n        propsForElement[key] = computedProps[key];\n      }\n    }\n  }\n\n  if (\n    // $FlowFixMe\n    props.style && // eslint-disable-line react/prop-types\n    attrs.style !== props.style // eslint-disable-line react/prop-types\n  ) {\n    // $FlowFixMe\n    propsForElement.style = { ...attrs.style, ...props.style }; // eslint-disable-line react/prop-types\n  }\n\n  // $FlowFixMe\n  propsForElement.className = Array.prototype\n    .concat(\n      foldedComponentIds,\n      // $FlowFixMe\n      props.className, // eslint-disable-line react/prop-types\n      styledComponentId,\n      attrs.className,\n      generatedClassName\n    )\n    .filter(Boolean)\n    .join(' ');\n  // $FlowFixMe\n  propsForElement.ref = refToForward;\n\n  useDebugValue(styledComponentId);\n\n  return createElement(elementToBeCreated, propsForElement);\n}\n\nexport default function createStyledComponent(\n  target: Target | StyledComponentWrapper<*, *>,\n  options: Object,\n  rules: RuleSet\n) {\n  const isTargetStyledComp = isStyledComponent(target);\n  const isCompositeComponent = !isTag(target);\n\n  const {\n    displayName = generateDisplayName(target),\n    componentId = generateId(options.displayName, options.parentComponentId),\n    attrs = EMPTY_ARRAY,\n  } = options;\n\n  const styledComponentId =\n    options.displayName && options.componentId\n      ? `${escape(options.displayName)}-${options.componentId}`\n      : options.componentId || componentId;\n\n  // fold the underlying StyledComponent attrs up (implicit extend)\n  const finalAttrs =\n    // $FlowFixMe\n    isTargetStyledComp && target.attrs\n      ? Array.prototype.concat(target.attrs, attrs).filter(Boolean)\n      : attrs;\n\n  const componentStyle = new ComponentStyle(\n    isTargetStyledComp\n      ? // fold the underlying StyledComponent rules up (implicit extend)\n        // $FlowFixMe\n        target.componentStyle.rules.concat(rules)\n      : rules,\n    finalAttrs,\n    styledComponentId\n  );\n\n  /**\n   * forwardRef creates a new interim component, which we'll take advantage of\n   * instead of extending ParentComponent to create _another_ interim class\n   */\n  // $FlowFixMe this is a forced cast to merge it StyledComponentWrapperProperties\n  const WrappedStyledComponent: StyledComponentWrapper<*, *> = React.forwardRef((props, ref) =>\n    useStyledComponentImpl(WrappedStyledComponent, props, ref)\n  );\n\n  WrappedStyledComponent.attrs = finalAttrs;\n  WrappedStyledComponent.componentStyle = componentStyle;\n  WrappedStyledComponent.displayName = displayName;\n\n  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp\n    ? // $FlowFixMe\n      Array.prototype.concat(target.foldedComponentIds, target.styledComponentId)\n    : EMPTY_ARRAY;\n\n  WrappedStyledComponent.styledComponentId = styledComponentId;\n\n  // fold the underlying StyledComponent target up since we folded the styles\n  WrappedStyledComponent.target = isTargetStyledComp\n    ? // $FlowFixMe\n      target.target\n    : target;\n\n  // $FlowFixMe\n  WrappedStyledComponent.withComponent = function withComponent(tag: Target) {\n    const { componentId: previousComponentId, ...optionsToCopy } = options;\n\n    const newComponentId =\n      previousComponentId &&\n      `${previousComponentId}-${isTag(tag) ? tag : escape(getComponentName(tag))}`;\n\n    const newOptions = {\n      ...optionsToCopy,\n      attrs: finalAttrs,\n      componentId: newComponentId,\n    };\n\n    return createStyledComponent(tag, newOptions, rules);\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName);\n  }\n\n  // $FlowFixMe\n  WrappedStyledComponent.toString = () => `.${WrappedStyledComponent.styledComponentId}`;\n\n  if (isCompositeComponent) {\n    hoist(WrappedStyledComponent, target, {\n      // all SC-specific things should not be hoisted\n      attrs: true,\n      componentStyle: true,\n      displayName: true,\n      foldedComponentIds: true,\n      styledComponentId: true,\n      target: true,\n      withComponent: true,\n    });\n  }\n\n  return WrappedStyledComponent;\n}\n"],"names":["target","nodes","insertRule","add","isCompositeComponent"],"mappings":"knJAqEwBA,sYAyBEC,gHAgBxBC,WAAA,8iEC7FA,qZAsCuBC,oz9BCqNjBC"}