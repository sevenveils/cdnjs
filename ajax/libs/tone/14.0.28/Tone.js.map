{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/Connect.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/event/ToneEvent.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/source/buffer/BufferSource.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/event/Part.ts","webpack://Tone/./Tone/component/envelope/Envelope.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OscillatorNode.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/version.ts","webpack://Tone/./Tone/event/Sequence.ts","webpack://Tone/./Tone/event/index.ts","webpack://Tone/./Tone/instrument/Instrument.ts","webpack://Tone/./Tone/instrument/Monophonic.ts","webpack://Tone/./Tone/component/envelope/AmplitudeEnvelope.ts","webpack://Tone/./Tone/instrument/Synth.ts","webpack://Tone/./Tone/instrument/index.ts","webpack://Tone/./Tone/source/buffer/Player.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/source/index.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/index.ts","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/(webpack)/buildin/global.js","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","TypeCheck_1","deepMerge","target","sources","_i","arguments","length","source","shift","isObject","key","assign","_a","_b","apply","concat","optionsFromArguments","defaults","argsArray","keys","objKey","opts","args","Array","from","Reflect","has","some","splice","indexOf","isDefined","getDefaultsFromInstance","instance","constructor","getDefaults","defaultArg","given","fallback","isUndef","omitFromObject","obj","omit","forEach","prop","readOnly","isArray","str","writable","noOp","arg","isString","isFunction","isNumber","toString","isBoolean","isNote","test","ToneWithContext_1","ToneAudioNode","_super","options","_this","numberOfInputs","numberOfOutputs","__extends","ToneWithContext","channelCount","channelCountMode","channelInterpretation","createInsOuts","input","context","createGain","output","_setChannelProperties","_internalChannels","node","_getChannelProperties","props","connect","destination","outputNum","inputNum","toDestination","toMaster","disconnect","chain","nodes","connectSeries","fan","dispose","AudioNode","first","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber","AudioParam","assert","dst","e","Volume_1","ToneAudioNode_1","Defaults_1","Interface_1","StateTimeline_1","Source","_volume","Volume","undefined","volume","_state","StateTimeline","_synced","_scheduled","_syncedStart","_syncedStop","memory","setValueAtTime","mute","transport","state","getValueAtTime","seconds","now","start","time","offset","duration","toSeconds","cancel","setStateAtTime","restart","event_1","sched","schedule","t","_start","push","stop","_stop","bind","sync","stateEvent","startOffset","getSecondsAtTime","Math","max","sampleTime","on","unsync","off","id","clear","Param_1","Gain","_gainNode","gain","Param","convert","param","units","ToneAudioNode_2","Signal","override","_constantSource","createConstantSource","_param","connectSignal","setRampPoint","linearRampToValueAtTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","startTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","setTargetAtTime","timeConstant","setValueCurveAtTime","values","scaling","cancelScheduledValues","cancelAndHoldAtTime","rampTo","overridden","maxValue","minValue","signal","globalContext","version_1","Context_1","setContext","initialize","window","TONE_CONTEXT","getContext","Context","resume","TONE_SILENCE_LOGGING","prefix","version","printString","console","log","Tone_1","Timeline","_timeline","Infinity","add","event","valueOf","index","_search","diff","remove","peek","getAfter","getBefore","len","after","slice","cancelBefore","previousEvent","beginning","end","midPoint","floor","nextEvent","_iterate","callback","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","endTime","forEachFrom","forEachAtTime","Tone","Signal_1","Source_1","OscillatorNode_1","Oscillator","_oscillator","frequency","detune","_partials","partials","_partialCount","partialCount","_phase","phase","_type","type","baseType","oscillator","ToneOscillatorNode","_wave","setPeriodicWave","cancelStop","syncFrequency","syncSignal","unsyncFrequency","unsyncSignal","isBasicType","_getRealImaginary","real","imag","periodicWave","createPeriodicWave","replace","partial","exec","periodicWaveSize","fftSize","Float32Array","parseInt","piFactor","PI","b","TypeError","sin","cos","_inverseFFT","sum","_getInitialValue","twoPi","Global_1","Frequency_1","Time_1","TransportTime_1","defaultContext","currentTime","lookAhead","immediate","sampleRate","TimeClass","toFrequency","freq","FrequencyClass","toTicks","TransportTimeClass","attribute","member","set","debug","_wasDisposed","global","TONE_DEBUG_CLASS","unshift","statement","error","Error","TicksClass","defaultUnits","_now","ticks","_beatsToUnits","beats","_getPPQ","_secondsToUnits","_getBpm","_ticksToUnits","Ticks","initial","_initial","getLastState","getNextState","event_2","Conversions_1","Timeline_1","_minOutput","_events","_initialValue","_fromType","_is","val","dbToGain","min","_toType","gainToDb","computedTime","numericValue","isFinite","JSON","stringify","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","constant","_exponentialApproach","currentVal","startingValue","segTime","valueAtTime","t0","v0","v1","exp","t1","pow","TransportTime","_getExpressions","method","capture","regexp","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","round","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","abs","toBarsBeatsSixteenths","quarterTime","quarters","parseFloat","toFixed","measures","_getTimeSignature","sixteenths","sixteenthString","join","toMidi","ftom","TimeBaseClass","Time","ToneAudioBuffer","onload","reverse","url","AudioBuffer","load","catch","onerror","_buffer","buffer","loaded","_reversed","_reverse","promise","downloads","audioBuffer","sent","e_1","fromArray","array","isMultidimensional","channels","createBuffer","multiChannelArray","copyToChannel","toMono","chanNum","toArray","outputArray","numChannels_1","numberOfChannels","channel","channelArray","map","sample","getChannelData","ret","startSamples","endSamples","replacementArray","rev","fromUrl","matches","match","extensions","split","extension","extensions_1","ext","supportsType","fetch","baseUrl","response","ok","arrayBuffer","decodeAudioData","document","createElement","canPlayType","equalPowerScale","db","LN10","intervalToFrequencyRatio","interval","A4","getA4","setA4","log2","mtof","midi","Emitter","eventName","once","boundCallback","eventList","emit","mixin","constr","getOwnPropertyDescriptor","Ticks_1","ToneEvent","_startOffset","_loop","loop","_loopStart","loopStart","_loopEnd","loopEnd","_playbackRate","playbackRate","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","scheduleRepeat","_tick","prob","variation","reschedulTime","getTicksAtTime","random","rate","lastEvent","loopDuration","Gain_1","WaveShaper_1","Oscillator_1","PulseOscillator","width","_widthGate","_sawtooth","_thresh","WaveShaper","mapping","Multiply","_mult","factor","Connect_1","ToneAudioBuffer_1","OneShotSource_1","ToneBufferSource","_source","createBufferSource","_sourceStarted","_sourceStopped","onended","_stopSource","OneShotSource","_fadeIn","_fadeOut","_curve","_startGain","computedDur","_onended","_unmutedVolume","Conversions_2","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","tr","q","total","transpose","harmonize","intervals","toNote","scaleIndexToNote","_noArg","_frequencyToUnits","cbb","cb","c#","cx","dbb","d#","dx","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a","a#","ax","bbb","bb","b#","bx","Frequency","notifyNewContext","onContextInit","initializeContext","ctx","notifyCloseContext","onContextClose","closeContext","Ticker_1","Emitter_1","AudioContext_1","ContextInitialization_1","_constants","Map","_timeouts","_timeoutIds","_initialized","_context","_latencyHint","latencyHint","_ticker","Ticker","clockSource","updateInterval","_timeoutLoop","addEventListener","getAudioContext","createAnalyser","createOscillator","createBiquadFilter","createChannelMerger","createChannelSplitter","createConvolver","createDelay","maxDelayTime","createDynamicsCompressor","createIIRFilter","feedforward","feedback","createPanner","constraints","createStereoPanner","createWaveShaper","audioData","listener","_transport","_destination","hint","lookAheadValue","AudioContext","Promise","resolve","close","getConstant","arr","firstEvent","setTimeout","fn","timeout","clearTimeout","ToneEvent_1","Part","Set","events","computedOffset_1","_forEach","_startNote","at","timeInTicks","tickTime","iterator","result","next","done","_restartEvent","delete","_setAll","attr","_testLoopBoundries","size","Envelope","_sig","attack","decay","sustain","release","attackCurve","releaseCurve","decayCurve","_getCurve","curve","direction","curveName","EnvelopeCurves","_setCurve","curveDef","_attackCurve","_releaseCurve","_decayCurve","triggerAttack","velocity","currentValue","decayValue","decayStart","triggerRelease","triggerAttackRelease","k","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","ceil","sineCurve","bounceCurve","invertCurve","out","j","bounce","In","Out","cosine","exponential","linear","ripple","sine","step","AMOscillator_1","FatOscillator_1","FMOscillator_1","PulseOscillator_1","PWMOscillator_1","OmniOscillatorSourceMap","am","AMOscillator","fat","FatOscillator","fm","FMOscillator","pulse","pwm","PWMOscillator","OmniOscillator","_sourceType","substr","_createNewOscillator","_getOscType","oscType","oscConstructor","oldOsc_1","blockTime","sType","osc","sourceType","count","spread","modulationType","mType","modulationIndex","harmonicity","modulationFrequency","Multiply_1","_pulse","_modulator","_scale","_oscillators","_spread","start_1","step_1","_carrier","_modulationNode","_shaper","setMap","normalized","oversample","oversampling","isOverSampleType","includes","SignalOperator","AudioToGain_1","_modulationScale","AudioToGain","_startTime","_stopTime","_timeout","getStateAtTime","fadeIn","fadeOut","fadeInTime","_stopGain","fadeOutTime","additionalTail","TransportEvent","_eventId","_once","invoke","IntervalTimeline_1","Clock_1","TransportEvent_1","TransportRepeatEvent_1","Transport","_scheduledEvents","_repeatedEvents","IntervalTimeline","_syncedSignals","_swingAmount","_ppq","ppq","_clock","Clock","_processTick","_bindClockEvents","bpm","multiplier","_timeSignature","timeSignature","_swingTicks","swing","swingSubdivision","progress","amount","setTicksAtTime","_addEvent","TransportRepeatEvent","scheduleOnce","eventId","item","timeline","computedAfter","offsetTicks","pause","toggle","timeSig","startPosition","endPosition","setLoopPoints","timeToTicks","remainingTicks","nextTickTime","ratio","computedFreq","PPQ","ratioSignal","syncedSignal","_root","_length","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","results","search","results_1","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes_1","traverse","searchAfter","high","_left","_right","height","point","TickSource_1","_lastUpdate","_boundLoop","_tickSource","TickSource","when","currentTick","getTimeOfTick","forEachTickBetween","Part_1","Sequence","_part","_seqCallback","_eventsArray","_subdivision","_createSequence","_eventsUpdated","_indexTime","Proxy","_rescheduleSequence","sequence","eventOffset","Sequence_1","Instrument","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","computedDuration","Instrument_1","Monophonic","portamento","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","getLevelAtTime","envelope","computedFrequency","portTime","AmplitudeEnvelope","AmplitudeEnvelope_1","Envelope_1","OmniOscillator_1","Monophonic_1","Synth","computedAttack","computedDecay","Synth_1","BufferSource_1","Player","_activeSources","_onload","autostart","_onSourceEnd","implicitEnd","seek","comptuedOffset","stopEvent","SignalOperator_1","_norm","x","Noise","_noiseBuffers","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","Noise_1","Player_1","_currentId","_nextId","_nextTick","_boundRestart","_restart","_interval","_createEvents","Destination","rawContext","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","TickSignal","_multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getDurationOfTicks","tick","delta","sqrt","sol1","ticksToTime","startTicks","TickSignal_1","_tickOffset","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","elapsedSeconds","absoluteTicks","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","Delay","maxDelay","delayTime","_delayNode","OfflineContext","OfflineAudioContext","_currentTime","_duration","render","startRendering","_val","_units","_expressions","hz","dot","scalar","number","samples","fromType","trim","typeName","quantity","expr","matching","toSamples","toMilliseconds","OfflineContext_1","Delay_1","Draw_1","Destination_1","Transport_1","setAudioContext","TONE_AUDIO_CONTEXT","Function","eval","_callback","_updateInterval","_createClock","_createWorker","blob","Blob","blobUrl","URL","createObjectURL","worker","Worker","onmessage","_worker","_createTimeout","_disposeClock","terminate","postMessage","__export","Global_2"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 69);\n","// import { BaseToneOptions } from \"../Tone\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T, ...sources: T[]): T {\n\tif (!sources.length) { return target; }\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\t// values with the key 'value' are an exception\n\t\t\t// they don't get deep merged\n\t\t\tif (key === \"value\") {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) { Object.assign(target, { [key]: {} }); }\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: string[] = [],\n\tobjKey?: string,\n): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, {[objKey] : args[0]});\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n *  Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n *  Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\tT[P] extends object ? RecursivePartial<T[P]> :\n\tT[P];\n};\n","/**\n *  Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n *  Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n *  Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n *  Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n *  Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n *  Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n *  Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isDefined, isNumber } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport type InputNode = ToneAudioNode | AudioNode | AudioParam | Param<Unit>;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\nexport interface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport interface ToneAudioNodeOptions extends ToneWithContextOptions {\n\tnumberOfInputs: number;\n\tnumberOfOutputs: number;\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n *  ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\nextends ToneWithContext<Options> {\n\n\tabstract name = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | InputNode[] | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | OutputNode[] | undefined;\n\n\t/**\n\t *  The number of inputs feeding into the AudioNode.\n\t *  For source nodes, this will be 0.\n\t */\n\treadonly numberOfInputs: number;\n\n\t/**\n\t *  The number of outputs of the AudioNode.\n\t */\n\treadonly numberOfOutputs: number;\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected abstract _internalChannels: OutputNode[];\n\n\tstatic getDefaults(): ToneAudioNodeOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tchannelCount: 2,\n\t\t\tchannelCountMode: \"max\" as ChannelCountMode,\n\t\t\tchannelInterpretation: \"speakers\" as ChannelInterpretation,\n\t\t\tnumberOfInputs: 0,\n\t\t\tnumberOfOutputs: 0,\n\t\t});\n\t}\n\n\tconstructor(options: ToneAudioNodeOptions) {\n\t\tsuper(options);\n\t\tthis.numberOfInputs = options.numberOfInputs;\n\t\tthis.numberOfOutputs = options.numberOfOutputs;\n\t}\n\n\tprotected createInsOuts(numberOfInputs: number = 0, numberOfOutputs: number = 0): void {\n\t\tif (numberOfInputs === 1) {\n\t\t\tthis.input = this.context.createGain();\n\t\t} else if (numberOfInputs > 1) {\n\t\t\tthis.input = [];\n\t\t\tfor (let i = 0; i < numberOfInputs; i++) {\n\t\t\t\tthis.input[i] = this.context.createGain();\n\t\t\t}\n\t\t}\n\n\t\tif (numberOfOutputs === 1) {\n\t\t\tthis.output = this.context.createGain();\n\t\t} else if (numberOfOutputs > 1) {\n\t\t\tthis.output = [];\n\t\t\tfor (let o = 0; o < numberOfOutputs; o++) {\n\t\t\t\tthis.output[o] = this.context.createGain();\n\t\t\t}\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// AUDIO PROPERTIES\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tif (this._internalChannels.length) {\n\t\t\tthis._internalChannels.forEach(node => {\n\t\t\t\tnode.channelCount = options.channelCount;\n\t\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tif (this._internalChannels.length) {\n\t\t\tconst node = this._internalChannels[0];\n\t\t\treturn {\n\t\t\t\tchannelCount: node.channelCount,\n\t\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t\t};\n\t\t} else {\n\t\t\t// return the defaults\n\t\t\treturn {\n\t\t\t\tchannelCount: 2,\n\t\t\t\tchannelCountMode: \"max\",\n\t\t\t\tchannelInterpretation: \"speakers\",\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t *  channelCount is the number of channels used when up-mixing and down-mixing\n\t *  connections to any inputs to the node. The default value is 2 except for\n\t *  specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount: number) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t *  channelCountMode determines how channels will be counted when up-mixing and\n\t *  down-mixing connections to any inputs to the node.\n\t *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode: ChannelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t *  channelInterpretation determines how individual channels will be treated\n\t *  when up-mixing and down-mixing connections to any inputs to the node.\n\t *  The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation: ChannelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONNECTIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t */\n\ttoMaster(): this {\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t *  disconnect the output\n\t *  @param output Either the output index to disconnect if the output is an array, or the node to disconnect from.\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Connect the output of this node to the rest of the nodes in series.\n\t *  @param nodes\n\t *  @example\n\t *  //connect a node to an effect, panVol and then to the master output\n\t *  node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  connect the output of this node to the rest of the nodes in parallel.\n\t *  @param nodes\n\t *  @returns this\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isArray(this.input)) {\n\t\t\t\tthis.input.forEach(input => {\n\t\t\t\t\tif (input instanceof ToneAudioNode) {\n\t\t\t\t\t\tinput.dispose();\n\t\t\t\t\t} else if (input instanceof AudioNode) {\n\t\t\t\t\t\tinput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (this.input instanceof AudioNode) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (isArray(this.output)) {\n\t\t\t\tthis.output.forEach(output => {\n\t\t\t\t\tif (output instanceof ToneAudioNode) {\n\t\t\t\t\t\toutput.dispose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (this.output instanceof AudioNode) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONNECTIONS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n *  connect together all of the arguments in series\n *  @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (prev instanceof AudioNode) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\t// resolve the input of the dstNode\n\twhile (!(dstNode instanceof AudioNode || dstNode instanceof AudioParam)) {\n\t\tif (isArray(dstNode.input)) {\n\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t} else if (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t\tinputNumber = 0;\n\t}\n\n\tif (srcNode instanceof ToneAudioNode) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\t// make the connection\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.connect(dstNode, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (isArray(dstNode.input)) {\n\t\t\t\tif (isNumber(inputNumber)) {\n\t\t\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the input number is greater than the number of inputs\");\n\t\t\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t\t\t} else {\n\t\t\t\t\t// disconnect from all of the nodes\n\t\t\t\t\t// since we don't know which one was connected\n\t\t\t\t\tdstNode.input.forEach(dst => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// catch errors from disconnecting from nodes that are not connected\n\t\t\t\t\t\t\tdisconnect(srcNode, dst, outputNumber);\n\t\t\t\t\t\t\t// tslint:disable-next-line: no-empty\n\t\t\t\t\t\t} catch (e) { }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tinputNumber = 0;\n\t\t\t} else if (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(srcNode instanceof AudioNode)) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (dstNode instanceof AudioNode) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class  Base class for sources. Sources have start/stop methods\n *          and the ability to be synced to the\n *          start/stop of this.context.transport.\n *\n *  @constructor\n *  @extends {Tone.AudioNode}\n *  @example\n * //Multiple state change events can be chained together,\n * //but must be set in the correct order and with ascending times\n *\n * // OK\n * state.start().stop(\"+0.2\");\n * // AND\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n *\n * // BAD\n * state.stop(\"+0.2\").start();\n * // OR\n * state.start(\"+0.3\").stop(\"+0.2\");\n *\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output volume node\n\t *  @type  {Tone.Volume}\n\t *  @private\n\t */\n\tprivate _volume: Volume = new Volume({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * The output note\n\t */\n\toutput = this._volume;\n\tprotected _internalChannels = [this.output];\n\n\t/**\n\t * There is no input\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume = this._volume.volume;\n\n\t/**\n\t * \tKeep track of the scheduled state.\n\t *  @type {Tone.StateTimeline}\n\t *  @private\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The synced `start` callback function from the transport\n\t *  @type {Function}\n\t *  @private\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t *  Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\treadOnly(this, \"volume\");\n\t\tthis._state.memory = 100;\n\t\tthis.volume.setValueAtTime(options.volume, 0);\n\t\t// set mute initially\n\t\tthis.mute = options.mute;\n\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t *  Start the source at the specified time. If no time is given,\n\t *  start the source now.\n\t *  @param  time When the source should be started.\n\t *  @returns {Source} this\n\t *  @example\n\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration: Time = 0): this {\n\t\tif (isUndef(time) && this._synced) {\n\t\t\ttime = this.context.transport.seconds;\n\t\t} else {\n\t\t\ttime = this.toSeconds(time);\n\t\t}\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._state.setStateAtTime(\"started\", time);\n\t\t\tthis.restart(time, offset, duration);\n\t\t} else {\n\t\t\tthis._state.setStateAtTime(\"started\", time);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(time);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = this.toSeconds(duration);\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, time);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the source at the specified time. If no time is given,\n\t *  stop the source now.\n\t *  @param  {Time} [time=now] When the source should be stopped.\n\t *  @returns {Source} this\n\t *  @example\n\t * source.stop(); // stops the source immediately\n\t */\n\tstop(time?: Time): this {\n\t\tif (isUndef(time) && this._synced) {\n\t\t\ttime = this.context.transport.seconds;\n\t\t} else {\n\t\t\ttime = this.toSeconds(time);\n\t\t}\n\t\tif (!this._synced) {\n\t\t\tthis._stop.apply(this, arguments);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), time);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(time);\n\t\tthis._state.setStateAtTime(\"stopped\", time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the source to the Transport so that all subsequent\n\t *  calls to `start` and `stop` are synced to the TransportTime\n\t *  instead of the AudioContext time.\n\t *\n\t * @example\n\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * source.sync().start(0).stop(0.3);\n\t * //start the transport.\n\t * this.context.transport.start();\n\t *\n\t * @example\n\t * //start the transport with an offset and the sync'ed sources\n\t * //will start in the correct position\n\t * source.sync().start(0.1);\n\t * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)\n\t * this.context.transport.start(\"+0.5\", 0.5);\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @param  gain The initial gain of the GainNode\n * @param units The units of the gain parameter.\n */\nexport class Gain<Type extends Unit = GainFactor> extends ToneAudioNode<GainOptions> {\n\n\tname = \"Gain\";\n\n\t/**\n\t *  The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * Add all of the gain nodes\n\t */\n\tprotected _internalChannels: AudioNode[] = [this._gainNode];\n\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext : this.context,\n\t\t\tconvert : options.convert,\n\t\t\tparam : this._gainNode.gain,\n\t\t\tunits : options.units,\n\t\t\tvalue : options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert : true,\n\t\t\tgain : 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits : \"gain\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface SignalOptions<Type> extends ToneAudioNodeOptions {\n\tvalue: Type;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *  @param value Initial value of the signal\n *  @param units unit The units the signal is in.\n * @example\n * const signal = new Tone.Signal(10);\n */\nexport class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>>\nimplements AbstractParam<Type> {\n\n\tname = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ConstantSourceNode = this.context.createConstantSource();\n\treadonly output: OutputNode = this._constantSource;\n\tprotected _param: Param<Type>;\n\treadonly input: InputNode;\n\tprotected _internalChannels = [this._constantSource];\n\n\tconstructor(value?: Type, units?: UnitName);\n\tconstructor(options?: Partial<SignalOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<Type>;\n\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannelCount: 1,\n\t\t\tchannelCountMode: \"explicit\",\n\t\t\tchannelInterpretation: \"discrete\",\n\t\t\tconvert: true,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t}) as SignalOptions<any>;\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): Type {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): Type {\n\t\treturn this._param.value;\n\t}\n\tset value(value: Type) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || destination instanceof AudioParam ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { version } from \"../version\";\nimport { Context } from \"./context/Context\";\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context;\n\n// @ts-ignore\nglobalContext = window.TONE_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getContext(): Context {\n\tif (!globalContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setContext(context: Context): void {\n\tglobalContext = context;\n\tcontext.initialize();\n\t// @ts-ignore\n\twindow.TONE_CONTEXT = context;\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (!this.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\t// @ts-ignore\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// tslint:disable-next-line: no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n *  @class A Timeline class for scheduling and maintaining state\n *         along a timeline. All events must have a \"time\" property.\n *         Internally, events are stored in time order for fast\n *         retrieval.\n *  @param memory The number of previous events that are retained.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\tname = \"Timeline\";\n\n\t/**\n\t *  The memory of the timeline, i.e.\n\t *  how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\tconstructor(options?: Partial<TimelineOptions>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(memory?: number);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t};\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t *  @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): Timeline<GenericEvent> {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tconst index = this._search(event.time);\n\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  {Object}  event  The event object to remove from the list.\n\t *  @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): Timeline<GenericEvent> {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the nearest event whose time is less than or equal to the given time.\n\t *  @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the first event in the timeline without removing it\n\t *  @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t *  Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t *  Get the event which is scheduled after the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Get the event before the event at the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Cancel events at and after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): Timeline<GenericEvent> {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events before or equal to the given time.\n\t *  @param  {Number}  time  The time to cancel before.\n\t *  @returns {Timeline} this\n\t */\n\tcancelBefore(time): Timeline<GenericEvent> {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  {Object} event The event to find the previous one of\n\t * @return {Object}       The event right before the given event\n\t */\n\tpreviousEvent(event): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Does a binary search on the timeline array and returns the\n\t *  nearest event index whose time is after or equal to the given time.\n\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t *  If the time is after the end, the index of the last item is returned.\n\t *  @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (event[param] === time) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (testEvent[param] === time) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] < time && nextEvent[param] > time) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] > time) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t *  Internal iterator. Applies extra safety checks for\n\t *  removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t *  Iterate over everything in the array\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or before the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array after the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array between the startTime and endTime.\n\t *  The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t *  range = [startTime, endTime).\n\t *  @param  startTime The time to check if items are before\n\t *  @param  endTime The end of the test interval.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or after the given time. Similar to\n\t *  forEachAfter, but includes the item(s) at the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at the given time\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./OscillatorNode\";\n\n/**\n *  Oscillator supports a number of features including\n *  phase rotation, multiple oscillator types (see Oscillator.type),\n *  and Transport syncing (see Oscillator.syncFrequency).\n *\n *  @param frequency Starting frequency\n *  @param type The oscillator type. Read more about type below.\n *  @example\n * //make and start a 440hz sine tone\n * var osc = new Oscillator(440, \"sine\").toMaster().start();\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"Oscillator\";\n\n\t/**\n\t *  the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t *  the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t *  The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t *  the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase: Radians;\n\n\t/**\n\t *  the type of the oscillator\n\t *  @type {string}\n\t *  @private\n\t */\n\tprivate _type;\n\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<Frequency>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<Cents>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._phase = options.phase;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString();\n\t\t}\n\t\tthis.phase = this._phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t}) as ToneOscillatorOptions;\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tthis.log(\"start\", time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\ttime = this.toSeconds(time);\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tthis.log(\"stop\", time);\n\t\tif (this._oscillator) {\n\t\t\ttime = this.toSeconds(time);\n\t\t\tthis._oscillator.stop(time);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t *  will also affect the oscillators frequency.\n\t *  @example\n\t * Tone.Transport.bpm.value = 120;\n\t * osc.frequency.value = 440;\n\t * //the ration between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * Tone.Transport.bpm.value = 240;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the oscillator's frequency from the Transport.\n\t *  See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/* tslint:disable */\n\t/**\n\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t * 8 partials of the triangle wave.\n\t * <br><br>\n\t * Uses PeriodicWave internally even for native types so that it can set the phase.\n\t * PeriodicWave equations are from the\n\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t *\n\t * @memberOf Oscillator#\n\t * @type {string}\n\t * @name type\n\t * @example\n\t * //set it to a square wave\n\t * osc.type = \"square\";\n\t * @example\n\t * //set the first 6 partials of a sawtooth wave\n\t * osc.type = \"sawtooth6\";\n\t */\n\t/* tslint:enable */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\tthis._wave = periodicWave;\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t}\n\t\t}\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._type.replace(this.partialCount, \"\");\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @example\n\t * osc.type = 'sine'\n\t * osc.partialCount = 3\n\t * //is equivalent to\n\t * osc.type = 'sine3'\n\t */\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p: number) {\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1];\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get the object's attributes. Given no arguments get\n\t *  will return all available object properties and their corresponding\n\t *  values.\n\t */\n\tget(): ToneOscillatorOptions {\n\t\tconst values = super.get();\n\t\tif (values.type !== \"custom\") {\n\t\t\tdelete values.partials;\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t *  Returns the real and imaginary components based\n\t *  on the oscillator type.\n\t *  @returns [real: Float32Array, imaginary: Float32Array]\n\t *  @private\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\t// tslint:disable: no-bitwise\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t *  Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t *  Returns the initial value of the oscillator.\n\t */\n\tprotected _getInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\t// check for peaks in 8 places\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / 8) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t * @example\n\t * osc.phase = 180; //flips the phase of the oscillator\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\t/**\n\t *  Dispose and disconnect.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport \"../type/Units\";\nimport { getDefaultsFromInstance, omitFromObject, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor\n\t */\n\treadonly defaultContext?: Context;\n\n\tconstructor(context?: Context | Partial<ToneWithContextOptions>) {\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tsuper();\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tGET/SET\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member.get();\n\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\n// import { getContext } from \"./Global\";\nimport \"./type/Units\";\n\n///////////////////////////////////////////////////////////////////////////\n// \tTONE\n///////////////////////////////////////////////////////////////////////////\n\n// tslint:disable-next-line: no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n *  @class  Tone is the base class of all other classes.\n *  @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Takes a partial options an returns the completed options by filling in the defaults\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEBUGGING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @param args\n\t *  @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\t// @ts-ignore\n\t\tif (this.debug || this.toString() === global.TONE_DEBUG_CLASS) {\n\t\t\targs.unshift(this.toString() + \":\");\n\t\t\t// tslint:disable-next-line: no-console\n\t\t\tconsole.log(...args);\n\t\t}\n\t}\n\n\t/**\n\t *  Assert that the statement is true, otherwise invoke the error.\n\t *  @param {Boolean} statement\n\t *  @param {String} error The message which is passed into an Error\n\t *  @private\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tif (!statement) {\n\t\t\tthrow new Error(error);\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDISPOSING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed: boolean = false;\n\n\t/**\n\t *  disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEFAULTS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  If the `given` parameter is undefined, use the `fallback`.\n\t *  If both `given` and `fallback` are object literals, it will\n\t *  return a deep copy which includes all of the parameters from both\n\t *  objects. If a parameter is undefined in given, it will return\n\t *  the fallback property.\n\t *  <br><br>\n\t *  WARNING: if object is self referential, it will go into an an\n\t *  infinite recursive loop.\n\t *  @memberOf Tone\n\t *  @param  {*} given\n\t *  @param  {*} fallback\n\t *  @return {*}\n\t */\n\t// static defaultArg(given, fallback) {\n\t\t// if (isObject(given) && isObject(fallback)) {\n\t\t// \tconst ret = {};\n\t\t// \t// make a deep copy of the given object\n\t\t// \tfor (const givenProp in given) {\n\t\t// \t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t// \t}\n\t\t// \tfor (const fallbackProp in fallback) {\n\t\t// \t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t// \t}\n\t\t// \treturn ret;\n\t\t// } else {\n\t\t// \treturn isUndef(given) ? fallback : given;\n\t\t// }\n\t// }\n\n\t// protected options(argsArray: IArguments, keys: string[]): object {\n\t// \tlet options: any = {};\n\t// \tconst args = Array.from(argsArray);\n\t// \tif (args[0] instanceof BaseAudioContext) {\n\t// \t\toptions.context = args.shift();\n\t// \t}\n\t// \tif (args.length === 1 && isObject(args[0])) {\n\t// \t\toptions = Object.assign(options, args[0]);\n\t// \t} else {\n\t// \t\tfor (let i = 0; i < keys.length; i++) {\n\t// \t\t\tif (isDefined(args[i])) {\n\t// \t\t\t\toptions[keys[i]] = args[i];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn deepMerge(this.getDefaults(), options);\n\t// }\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tSTATIC\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// static get context(): import(\"./context/Context\").Context {\n\t// \treturn getContext();\n\t// }\n\n\t// static now(): Seconds {\n\t// \treturn Tone.context.now();\n\t// }\n}\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\tname = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t *  Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t *  Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","// import \"../type/Type\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n *  A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n *  @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\t/**\n\t *  The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t *  Returns the scheduled state scheduled before or at\n\t *  the given time.\n\t *  @param  time  The time to query.\n\t *  @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\t// all state changes need to be >= the previous state time\n\t\t// TODO throw error if time < the previous event time\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the event before the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check before\n\t *  @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Return the event after the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check from\n\t *  @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isNumber } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions extends ToneWithContextOptions {\n\tunits: UnitName;\n\tvalue?: any;\n\tparam: AudioParam;\n\tconvert: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linear\" | \"exponential\" | \"setValue\" | \"setTarget\" | \"cancel\";\n\n/**\n * The events on the automation\n */\nexport interface AutomationEvent {\n\ttype: AutomationType;\n\ttime: number;\n\tvalue: number;\n\tconstant?: number;\n}\n\n/**\n *  Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<Type extends Unit = number>\nextends ToneWithContext<ParamOptions>\nimplements AbstractParam<Type> {\n\n\tname = \"Param\";\n\n\tstatic getDefaults(): ParamOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions);\n\t}\n\n\t/**\n\t * The input connection\n\t */\n\treadonly input: AudioParam;\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t *  The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t *  The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t *  The minimum output value\n\t */\n\tprivate _minOutput = 1e-5;\n\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) && options.param instanceof AudioParam, \"param must be an AudioParam\");\n\n\t\t// initialize\n\t\tthis._param = this.input = options.param;\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.value;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tget value(): Type {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: Type) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\tif (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t *  Convert the given value from the type specified by Param.units\n\t *  into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as Type;\n\t\t} else {\n\t\t\treturn val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setValue\", value, computedTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): Type {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTarget\" && (after === null || after.type === \"setValue\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (isDefined(before.constant)) {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linear\" || after.type === \"exponential\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTarget\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linear\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"linear\", value, computedTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponential\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"exponential\", value, computedTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tconst timeConstant = Math.log(this.toSeconds(rampTime) + 1) / Math.log(200);\n\t\ttime = this.toSeconds(time);\n\t\treturn this.setTargetAtTime(value, time, timeConstant);\n\t}\n\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTarget\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setTarget\", value, computedTime, timeConstant);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._events.cancel(computedTime);\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(\"cancel\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\tthis.log(\"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\n\t\t// remove the schedule events\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && before.time === computedTime) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponential\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: Type, rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\tname = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\nextends TimeBaseClass<Type, Unit> {\n\n\tname = \"Time\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: number | Subdivision | TimeObject, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\t/**\n\t *  Convert a Time to Notation. The notation values are will be the\n\t *  closest representation between 1m to 128th note.\n\t *  @return {Notation}\n\t *  @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t *  Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t *  Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","export { connect, disconnect, connectSeries } from \"./context/ToneAudioNode\";\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n *\n * @param url The url to load, or the audio buffer to set.\n * @param onload A callback which is invoked after the buffer is loaded.\n *                            It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n *                            since it will give you a callback when _all_ buffers are loaded.\n * @param onerror The callback to invoke if there is an error\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n */\nexport class ToneAudioBuffer extends Tone {\n\n\tname = \"ToneAudioBuffer\";\n\n\t/**\n\t *  stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t *  indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && options.url instanceof AudioBuffer || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t *  Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * \tInvokes the callback once the audio buffer loads.\n\t *  @param url The url of the buffer to load. filetype support depends on the browser.\n\t *  @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tSums multiple channels into 1 channel\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t *  @param  channel  The channel number to return\n\t *  @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t *  Cut a subsection of the array and return a buffer of the\n\t *  subsection. Does not modify the original buffer\n\t *  @param start The time to start the slice\n\t *  @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tconst replacementArray: Float32Array[] = [];\n\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\treplacementArray[i] = this.toArray(i).slice(startSamples, endSamples) as Float32Array;\n\t\t}\n\t\tconst retBuffer = new ToneAudioBuffer().fromArray(replacementArray);\n\t\treturn retBuffer;\n\t}\n\n\t/**\n\t *  Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tArray.prototype.reverse.call(this.getChannelData(i));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// STATIC METHODS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t *  Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t *  pass in a multidimensional array.\n\t *  @param array The array to fill the audio buffer\n\t *  @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t *  Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t *  Checks a url's extension to see if the current browser can play that file type.\n\t *  @param url The url/extension to test\n\t *  @return If the file extension can be played\n\t *  @static\n\t *  @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","import \"./Units\";\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n *  @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n *  Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n *  Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn 69 + Math.round(12 * Math.log2(frequency / A4));\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\tname = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t *  Bind a callback to a specific event.\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Bind a callback which is only invoked once\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[])  => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove the event listener.\n\t *  @param  event     The event to stop listening to.\n\t *  @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                    If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Invoke all of the callbacks bound to the event\n\t *  with any arguments passed in.\n\t *  @param  event  The name of the event.\n\t *  @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { TransportTimeClass } from \"Tone/core/type/TransportTime\";\nimport \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isDefined, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback = (time: Seconds, value: any) => void;\n\nexport interface ToneEventOptions extends ToneWithContextOptions {\n\tcallback: ToneEventCallback;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: any;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @extends {Tone}\n * @param callback The callback to invoke at the time.\n * @param value The value or values which should be passed to the callback function on invocation.\n * @example\n * var chord = new ToneEvent(function(time, chord){\n * \t//the chord as well as the exact time of the event\n * \t//are passed in as arguments to the callback function\n * }, [\"D4\", \"E4\", \"F4\"]);\n * //start the chord at the beginning of the transport timeline\n * chord.start();\n * //loop it every measure for 8 measures\n * chord.loop = 8;\n * chord.loopEnd = \"1m\";\n */\nexport class ToneEvent extends ToneWithContext<ToneEventOptions> {\n\n\tname = \"ToneEvent\";\n\n\t/**\n\t *  Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t *  The callback to invoke.\n\t */\n\tcallback: ToneEventCallback;\n\n\t/**\n\t *  The value which is passed to the\n\t *  callback function.\n\t */\n\tvalue: any;\n\n\t/**\n\t *  When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t *  When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t *  Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number,\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The playback speed of the note. A speed of 1\n\t *  is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t *  A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t *  private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t *  the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t *  If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\tconstructor(options?: Partial<ToneEventOptions>);\n\tconstructor(callback?: ToneEventCallback, value?: any);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): ToneEventOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback : noOp,\n\t\t\thumanize : false,\n\t\t\tloop : false,\n\t\t\tloopEnd : \"1m\",\n\t\t\tloopStart : 0,\n\t\t\tmute : false,\n\t\t\tplaybackRate : 1,\n\t\t\tprobability : 1,\n\t\t\tvalue : null,\n\t\t});\n\t}\n\n\t/**\n\t *  Reschedule all of the events along the timeline\n\t *  with the updated values.\n\t *  @param after Only reschedules events after the given time.\n\t *  @private\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id : -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t *  The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t *  If set to true, will apply small random variation\n\t *  to the callback time. If the value is given as a time, it will randomize\n\t *  by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t *  Start the note at the given time.\n\t *  @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(time) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid : -1,\n\t\t\t\tstate : \"started\",\n\t\t\t\ttime,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the Event at the given time.\n\t *  @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\ttime = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", time, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(time);\n\t\t\tlet reschedulTime = time;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel all scheduled events greater than or equal to the given time\n\t *  @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\ttime = this.toTicks(time);\n\t\tthis._state.forEachFrom(time, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The callback function invoker. Also\n\t *  checks if the Event is done playing\n\t *  @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t *  Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t *  If the note should loop or not\n\t *  between ToneEvent.loopStart and\n\t *  ToneEvent.loopEnd. If set to true,\n\t *  the event will loop indefinitely,\n\t *  if set to a number greater than 1\n\t *  it will play a specific number of\n\t *  times, if set to false, 0 or 1, the\n\t *  part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * \tThe playback rate of the note. Defaults to 1.\n\t *  @example\n\t * note.loop = true;\n\t * //repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t *  The loopEnd point is the time the event will loop\n\t *  if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t *  The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t *  The current progress of the loop interval.\n\t *  Returns 0 if the event is not started yet or\n\t *  it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\tthis.value = null;\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @param frequency The frequency of the oscillator\n * @param width The width of the pulse\n * @example\n * var pulse = new PulseOscillator(\"E5\", 0.4).toMaster().start();\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"PulseOscillator\";\n\n\t/**\n\t *  The width of the pulse.\n\t */\n\twidth: Signal<AudioRange> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"audioRange\",\n\t});\n\n\t/**\n\t *  gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t *  the sawtooth oscillator\n\t */\n\tprivate _sawtooth: Oscillator = new Oscillator({\n\t\tcontext: this.context,\n\t\ttype : \"sawtooth\",\n\t});\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency> = this._sawtooth.frequency;\n\n\t/**\n\t *  The detune in cents.\n\t */\n\tdetune: Signal<Cents> = this._sawtooth.detune;\n\n\t/**\n\t *  Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width.setValueAtTime(options.width, 0);\n\t\tthis._sawtooth.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis._sawtooth.detune.setValueAtTime(options.detune, 0);\n\t\tthis._sawtooth.phase = options.phase;\n\n\t\t// connections\n\t\tthis._sawtooth.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\t/**\n\t *  Restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._sawtooth.restart(computedTime);\n\t\tthis._widthGate.gain.cancelScheduledValues(computedTime);\n\t\tthis._widthGate.gain.setValueAtTime(1, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._sawtooth.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._sawtooth.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t *  Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sawtooth.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @param {number=} value Constant value to multiple\n * @example\n * const mult = new Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * //output of mult is 12.\n *  @example\n * const mult = new Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * //the output of mult is 20.\n */\nexport class Multiply extends Signal<number> {\n\n\tname = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The multiplcant input.\n\t */\n\tinput = this._mult;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput = this._mult;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<number>;\n\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(value?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<number>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\ninterface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n *  Wrapper around the native BufferSourceNode.\n *  @param  buffer   The buffer to play\n *  @param  onended  The callback to invoke when the buffer is done playing.\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\tname = \"ToneBufferSource\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._gainNode, this._source];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<Positive>;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t *  The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._source.playbackRate,\n\t\t\tunits : \"positive\",\n\t\t\tvalue : options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t *  Start the buffer\n\t *  @param  time When the player should start.\n\t *  @param  offset The offset from the beginning of the sample to start at.\n\t *  @param  duration How long the sample should play. If no duration\n\t *                   is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t *  @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\ttime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(time, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\toffset = this.toSeconds(offset);\n\t\t// make sure the offset is not less than 0\n\t\toffset = Math.max(offset, 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (offset >= loopEnd) {\n\t\t\t\toffset = ((offset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (offset < this.buffer.duration) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(time, offset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(time + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class Volume is a simple volume node, useful for creating a volume fader.\n *\n *  @extends {Tone.AudioNode}\n *  @constructor\n *  @param {Decibels} [volume=0] the initial volume\n *  @example\n * var vol = new Volume(-12);\n * instrument.chain(vol, Tone.Master);\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\tname = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<Decibels> = new Gain({\n\t\tcontext: this.context,\n\t\tunits: \"decibels\",\n\t});\n\tprotected _internalChannels = [this.output];\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput = this.output;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t *  The volume control in decibels.\n\t */\n\tvolume: Param<Decibels> = this.output.gain;\n\n\tconstructor(options?: Decibels | Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.volume.value = options.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * volume.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\tname = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUGMENT BASE EXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote : {\n\t\t\t\tregexp : /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tEXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t *  @return  A new transposed frequency\n\t *  @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t *  Takes an array of semitone intervals and returns\n\t *  an array of frequencies transposed by those intervals.\n\t *  @return  Returns an array of Frequencies\n\t *  @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t *  @return  {MIDI}\n\t *  @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t *  Return the value of the frequency in Scientific Pitch Notation\n\t *  @return  {Note}\n\t *  @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS HELPERS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tFREQUENCY CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Note to scale index\n *  @type  {Object}\n *  @private\n */\nconst noteToScaleIndex = {\n\t// tslint:disable-next-line\n\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n};\n\n/**\n *  scale index to note (sharps)\n *  @type  {Array}\n *  @private\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","///////////////////////////////////////////////////////////////////////////\n// INITIALIZING NEW CONTEXT\n///////////////////////////////////////////////////////////////////////////\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isString } from \"../util/TypeCheck\";\nimport { getAudioContext } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"createScriptProcessor\" | \"onstatechange\" | \"addEventListener\"\n\t| \"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\";\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: BaseAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\tname = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: BaseAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t *  The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t *  An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t *  All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t *  The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\tconstructor(context?: BaseAudioContext);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.addEventListener(\"statechange\", () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tinitialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// BASE AUDIO CONTEXT METHODS\n\t///////////////////////////////////////////////////////////////////////\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode {\n\t\treturn this._context.createIIRFilter(feedforward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t *  The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t *  There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t *  A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TICKER\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  How often the interval callback is invoked.\n\t *  This number corresponds to how responsive the scheduling\n\t *  can be. context.updateInterval + context.lookAhead gives you the\n\t *  total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t *  What the source of the clock is, either \"worker\" (default),\n\t *  \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t *  The unwrapped AudioContext.\n\t */\n\tget rawContext(): BaseAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short {@link lookAhead}.\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t *  Starts the audio context from a suspended state. This is required\n\t *  to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && this._context instanceof AudioContext) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t *  Promise which is invoked when the context is running.\n\t *  Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<Context> {\n\t\tif (this._context instanceof AudioContext) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TIMEOUTS\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The private loop which keeps track of the context scheduled timeouts\n\t *  Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void  {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t *  A setTimeout which is guarented by the clock source.\n\t *  Also runs in the offline context.\n\t *  @param  fn       The callback to invoke\n\t *  @param  timeout  The timeout in seconds\n\t *  @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback : fn,\n\t\t\tid : this._timeoutIds,\n\t\t\ttime : now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t *  Clears a previously scheduled timeout with Tone.context.setTimeout\n\t *  @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): Context {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype PartEventDescription = Time | [Time, any] | {\n\ttime: Time,\n\t[key: string]: any;\n};\n\ninterface PartOptions extends ToneEventOptions {\n\tevents: PartEventDescription[];\n}\n\n/**\n *  Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n *  @param callback The callback to invoke on each event\n *  @param events the array of events\n *  @example\n * var part = new Part(function(time, note){\n * \t//the notes given as the second element in the array\n * \t//will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }, [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n *  @example\n * //use an array of objects as long as the object has a \"time\" attribute\n * var part = new Part(function(time, value){\n * \t//the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }, [{\"time\" : 0, \"note\" : \"C3\", \"velocity\": 0.9},\n * \t   {\"time\" : \"0:2\", \"note\" : \"C4\", \"velocity\": 0.5}\n * ]).start(0);\n */\nexport class Part extends ToneEvent {\n\n\tname = \"Part\";\n\n\t/**\n\t *  Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number,\n\t\toffset: number,\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\tconstructor(callback?: ToneEventCallback, value?: any);\n\tconstructor(options?: Partial<PartOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t *  Start the part at the given time.\n\t *  @param  time    When to start the part.\n\t *  @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid : -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate : \"started\",\n\t\t\t\ttime : ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Start the event in the given event at the correct time given\n\t *  the ticks and offset and looping.\n\t *  @param  event\n\t *  @param  ticks\n\t *  @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t *  Stop the part at the given time.\n\t *  @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * part.at(\"1m\"); //returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); //set the value at \"2m\" to C2.\n\t * //if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a an event to the part.\n\t *  @param time The time the note should start. If an object is passed in, it should\n\t *  \t\t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t *  @param  value\n\t * @example\n\t * part.add(\"1m\", \"C#+11\");\n\t * @example\n\t * part.add({\n\t * \ttime: \"1m\",\n\t * \tnote: \"C#11\"\n\t * });\n\t */\n\tadd(obj: {\n\t\ttime: Time,\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback : this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = time;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize : this.humanize,\n\t\t\tloop : this.loop,\n\t\t\tloopEnd : this.loopEnd,\n\t\t\tloopStart : this.loopStart,\n\t\t\tplaybackRate : this.playbackRate,\n\t\t\tprobability : this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Remove an event from the part. If the event at that time is a Part,\n\t *  it will remove the entire part.\n\t *  @param time The time of the event\n\t *  @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time,\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t *  @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the attribute of all of the events\n\t *  @param  attr  the attribute to set\n\t *  @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t *  Internal tick method\n\t *  @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t *  Determine if the event should be currently looping\n\t *  given the loop boundries of this Part.\n\t *  @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\t/**\n\t *  The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * //loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t *  The loopEnd point determines when it will\n\t *  loop if Part.loop is true.\n\t *  @memberOf Part#\n\t *  @type {Time}\n\t *  @name loopEnd\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t *  The loopStart point determines when it will\n\t *  loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * \tThe playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * \tThe number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"Tone/core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n *  Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n *  envelope generator. Envelope outputs a signal which\n *  can be connected to an AudioParam or Tone.Signal.\n *  <img src=\"https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg\">\n *\n *  @param attack The amount of time it takes for the envelope to go from\n *                         0 to it's maximum value.\n *  @param decay\tThe period of time after the attack that it takes for the envelope\n *                       \tto fall to the sustain value. Value must be greater than 0.\n *  @param sustain\tThe percent of the maximum value that the envelope rests at until\n *                                \tthe release is triggered.\n *  @param release\tThe amount of time after the release is triggered it takes to reach 0.\n *                         \tValue must be greater than 0.\n *  @example\n * //an amplitude envelope\n * var gainNode = Tone.context.createGain();\n * var env = new Envelope({\n * \t\"attack\" : 0.1,\n * \t\"decay\" : 0.2,\n * \t\"sustain\" : 1,\n * \t\"release\" : 0.8,\n * });\n * env.connect(gainNode.gain);\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\tname = \"Envelope\";\n\n\t/**\n\t *  When triggerAttack is called, the attack time is the amount of\n\t *  time it takes for the envelope to reach it's maximum value.\n\t */\n\tattack: Time;\n\n\t/**\n\t *  After the attack portion of the envelope, the value will fall\n\t *  over the duration of the decay time to it's sustain value.\n\t */\n\tdecay: Time;\n\n\t/**\n\t * \tThe sustain value is the value\n\t * \twhich the envelope rests at after triggerAttack is\n\t * \tcalled, but before triggerRelease is invoked.\n\t */\n\tsustain: NormalRange;\n\n\t/**\n\t *  After triggerRelease is called, the envelope's\n\t *  value will fall to it's miminum value over the\n\t *  duration of the release time.\n\t */\n\trelease: Time;\n\n\t/**\n\t *  The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t *  The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t *  The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t *  the signal which is output.\n\t */\n\tprotected _sig: Signal<NormalRange> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\tprotected _internalChannels = [this._sig];\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack : 0.01,\n\t\t\tattackCurve : \"linear\" as EnvelopeCurveName,\n\t\t\tdecay : 0.1,\n\t\t\tdecayCurve : \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease : 1,\n\t\t\treleaseCurve : \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain : 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * syncronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Get the curve\n\t *  @param  curve\n\t *  @param  direction  In/Out\n\t *  @return  {String}  The curve name\n\t *  @private\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t *  Assign a the curve to the given name using the direction\n\t *  @param  name\n\t *  @param  direction In/Out\n\t *  @param  curve\n\t *  @private\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * linear\n\t * * exponential\n\t * * sine\n\t * * cosine\n\t * * bounce\n\t * * ripple\n\t * * step\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @memberOf Envelope#\n\t * @type {String|Array}\n\t * @name attackCurve\n\t * @example\n\t * env.attackCurve = \"linear\";\n\t * @example\n\t * //can also be an array\n\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @memberOf Envelope#\n\t * @type {String|Array}\n\t * @name releaseCurve\n\t * @example\n\t * env.releaseCurve = \"linear\";\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @memberOf Envelope#\n\t * @type {String}\n\t * @name decayCurve\n\t * @example\n\t * env.decayCurve = \"linear\";\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tthis.assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                              number between 0-1\n\t * @example\n\t * //trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack === 0) {\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else if (attack > 0) {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(decayValue, decay, decayStart + this.sampleTime);\n\t\t\t} else if (this._decayCurve === \"exponential\") {\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Triggers the release of the envelope.\n\t *  @param  time When the release portion of the envelope should start.\n\t *  @example\n\t *  //trigger release immediately\n\t *  env.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tif (isArray(this._releaseCurve)) {\n\t\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the scheduled value at the given time. This will\n\t *  return the unconverted (raw) value.\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t *  triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t *  some duration, then triggerRelease.\n\t *  @param duration The duration of the sustain.\n\t *  @param time When the attack should be triggered.\n\t *  @param velocity The velocity of the envelope.\n\t *  @example\n\t * //trigger the attack and then the release after 0.6 seconds.\n\t * env.triggerAttackRelease(0.6);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(after);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber: number = 0, inputNumber: number = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName =  keyof EnvelopeCurveMap;\n\n/**\n *  Generate some complex envelope curves.\n */\n// tslint:disable-next-line: variable-name\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t *  Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t *  reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t *  attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce : {\n\t\t\tIn : invertCurve(bounceCurve),\n\t\t\tOut : bounceCurve,\n\t\t},\n\t\tcosine : {\n\t\t\tIn : cosineCurve,\n\t\t\tOut : reverseCurve(cosineCurve),\n\t\t},\n\t\texponential : \"exponential\" as \"exponential\",\n\t\tlinear : \"linear\" as \"linear\",\n\t\tripple : {\n\t\t\tIn : rippleCurve,\n\t\t\tOut : invertCurve(rippleCurve),\n\t\t},\n\t\tsine : {\n\t\t\tIn : sineCurve,\n\t\t\tOut : invertCurve(sineCurve),\n\t\t},\n\t\tstep : {\n\t\t\tIn : stairsCurve,\n\t\t\tOut : invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { AMOscillatorOptions, FatOscillatorOptions,\n\tFMOscillatorOptions, OmniOscillatorConstructorOptions,\n\tOmniOscillatorOptions, OmniOscillatorType,\n\tPulseOscillatorOptions, PWMOscillatorOptions,\n\tToneOscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * The constructor of each of the OmniOscillator types\n */\ntype TypeofAnyOscillator = typeof Oscillator | typeof PWMOscillator |\n\ttypeof PulseOscillator | typeof FatOscillator |\n\ttypeof AMOscillator | typeof FMOscillator;\n\n/**\n * Select the Oscillator's Options depending on the generic type.\n */\ntype ConditionalOptions<Osc extends AnyOscillator> =\n\tOsc extends FMOscillator ? FMOscillatorOptions :\n\tOsc extends Oscillator ? ToneOscillatorOptions :\n\tOsc extends AMOscillator ? AMOscillatorOptions :\n\tOsc extends FatOscillator ? FatOscillatorOptions :\n\tOsc extends PulseOscillator ? PulseOscillatorOptions :\n\tOsc extends PWMOscillator ? PWMOscillatorOptions :\n\tToneOscillatorOptions;\n\n/**\n * The aggregate options of all of the oscillators\n */\n// export type OmniOscillatorOptions = ConditionalOptions<AnyOscillator>;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\n// tslint:disable-next-line: variable-name\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType] : TypeofAnyOscillator\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n * into one class. The oscillator class can be changed by setting the `type`.\n * `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n * any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n * will use the FMOscillator, AMOscillator or FatOscillator respectively.\n * For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n * to a FatOscillator of type \"sawtooth\".\n *\n * @param frequency The initial frequency of the oscillator.\n * @param type The type of the oscillator.\n * @example\n * var omniOsc = new OmniOscillator(\"C#4\", \"pwm\");\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\nextends Source<OmniOscillatorConstructorOptions>\nimplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\tname = \"OmniOscillator\";\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"frequency\",\n\t});\n\n\t/**\n\t *  The detune control.\n\t */\n\treadonly detune: Signal<Cents> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"cents\",\n\t});\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t *  the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\tconstructor(options?: Partial<OmniOscillatorConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t\t// return Oscillator.getDefaults() as OmniOscillatorConstructorOptions;\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\trestart(time?: Time): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not.\n\t * @example\n\t * omniOsc.type = \"pwm\";\n\t * //modulationFrequency is parameter which is available\n\t * //only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t * @example\n\t * //an square wave frequency modulated by a sawtooth\n\t * omniOsc.type = \"fmsquare\";\n\t * omniOsc.modulationType = \"sawtooth\";\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2)  as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3)  as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\t/**\n\t * The partial count of the oscillator. This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * //set the maximum number of partials\n\t * osc.partialCount = 0;\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: Partial<OmniOscillatorConstructorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t\t// delete props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\tget(): OmniOscillatorConstructorOptions {\n\t\tconst options = this._oscillator.get();\n\t\t// @ts-ignore\n\t\toptions.type = this.type;\n\t\treturn options as OmniOscillatorOptions;\n\t}\n\n\t/**\n\t *  connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst oscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\t// @ts-ignore\n\t\t\tthis._oscillator = new oscConstructor({\n\t\t\t\tcontext : this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare\");\n\t * omniOsc.sourceType // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare4\");\n\t * omniOsc.sourceType // 'fm'\n\t * omniOsc.baseType //'square'\n\t * omniOsc.partialCount //4\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pulse\");\n\t * //can access the width attribute only if type === \"pulse\"\n\t * omniOsc.width.value = 0.2;\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<AudioRange>> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators, when sourceType === \"fat\".\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t * for more info.\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator\n\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t * for more info.\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t * See Tone.FMOscillator for more info.\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t *  for more info.\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator\n\t * (only if the oscillator type is set to pwm). See\n\t * Tone.PWMOscillator for more info.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pwm\");\n\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t * omniOsc.modulationFrequency.value = 0.2;\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<Frequency>> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n *\n * @param {Frequency} frequency The starting frequency of the oscillator.\n * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n * @example\n *  var pwm = new PWMOscillator(\"Ab3\", 0.3).toMaster().start();\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t *  the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator = new PulseOscillator({ context: this.context });\n\t/**\n\t *  the modulator\n\t *  @type {Tone.Oscillator}\n\t *  @private\n\t */\n\tprivate _modulator: Oscillator = new Oscillator({ context: this.context });\n\n\t/**\n\t *  Scale the oscillator so it doesn't go silent\n\t *  at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency> = this._modulator.frequency;\n\n\t/**\n\t *  The detune of the oscillator.\n\t */\n\treadonly detune: Signal<Cents> = this._modulator.detune;\n\n\t/**\n\t *  The modulation rate of the oscillator.\n\t */\n\treadonly modulationFrequency: Signal<Frequency> = this._pulse.frequency;\n\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\t// change the pulse oscillator type\n\t\t// @ts-ignore\n\t\tthis._pulse._sawtooth.type = \"sine\";\n\n\t\tthis._pulse.frequency.setValueAtTime(options.modulationFrequency, 0);\n\t\tthis._modulator.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis._modulator.detune.setValueAtTime(options.detune, 0);\n\t\tthis._modulator.phase = options.phase;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FatConstructorOptions, FatOscillatorOptions,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n *  FatOscillator is an array of oscillators with detune spread between the oscillators\n *  @param frequency The oscillator's frequency.\n *  @param type The type of the oscillator.\n *  @param spread The detune spread between the oscillators.\n *  @example\n * var fatOsc = new FatOscillator(\"Ab3\", \"sine\", 40).toMaster().start();\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"FatOscillator\";\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"frequency\",\n\t});\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"cents\",\n\t});\n\n\t/**\n\t *  The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t *  The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t *  The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t *  The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t *  The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount : 3,\n\t\t\tspread : 20,\n\t\t\ttype : \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.restart(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Should be an integer greater than 1.\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\n\tset count(count: number) {\n\t\tcount = Math.max(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext : this.context,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t} else {\n\t\t\t\t\tosc.type = this._type;\n\t\t\t\t}\n\t\t\t\tosc.partialCount = this._partialCount;\n\t\t\t\tosc.phase = this._phase + (i / count) * 360;\n\t\t\t\tosc.volume.value = -6 - count * 1.1;\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @memberOf FatOscillator#\n\t * @type {Array}\n\t * @name partials\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @memberOf FatOscillator#\n\t * @type {Number}\n\t * @name partialCount\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FMConstructorOptions, FMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @param frequency The starting frequency of the oscillator.\n * @param type The type of the carrier oscillator.\n * @param modulationType The type of the modulator oscillator.\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new FMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"FMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator = new Oscillator({\n\t\tcontext : this.context,\n\t\tfrequency: 0,\n\t});\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"frequency\",\n\t});\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents> = this._carrier.detune;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator = new Oscillator({ context : this.context });\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t *  @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive> = new Multiply({\n\t\tcontext: this.context,\n\t\tunits: \"positive\",\n\t});\n\n\t/**\n\t *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t *  modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<Positive> = new Multiply({\n\t\tcontext: this.context,\n\t\tunits: \"positive\",\n\t});\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier.type = options.type;\n\t\tthis._modulator.type = options.modulationType;\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\t\tthis.harmonicity.setValueAtTime(options.harmonicity, 0);\n\t\tthis.modulationIndex.setValueAtTime(options.modulationIndex, 0);\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\tthis.phase = options.phase;\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  stop and restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction, isUndef } from \"../core/util/TypeCheck\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\ntype WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping =  WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n *  @param mapping The function used to define the values.\n *                 The mapping function should take two arguments:\n *                 the first is the value at the current position\n *                 and the second is the array position.\n *                 If the argument is an array, that array will be\n *                 set as the wave shaping function. The input\n *                 signal is an AudioRange [-1, 1] value and the output\n *                 signal can take on any numerical values.\n *\n *  @param bufferLen The length of the WaveShaperNode buffer.\n *  @example\n * var timesTwo = new WaveShaper(function(val){\n * \treturn val * 2;\n * }, 2048);\n *  @example\n * //a waveshaper can also be constructed with an array of values\n * var invert = new WaveShaper([1, -1]);\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\tname = \"WaveShaper\";\n\n\t/**\n\t *  the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\tprotected _internalChannels = [this._shaper];\n\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor(mapping?: WaveShaperMapping , length?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t *  Uses a mapping function to set the value of the curve.\n\t *  @param mapping The function used to define the values.\n\t *                 The mapping function take two arguments:\n\t *                 the first is the value at the current position\n\t *                 which goes from -1 to 1 over the number of elements\n\t *                 in the curve array. The second argument is the array position.\n\t * @example\n\t * //map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap(function(val, index){\n\t * \treturn (val + 1) * 5;\n\t * })\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length: number = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tthis.assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"..//core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { AMConstructorOptions, AMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface,\n\tToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n *\n * @param frequency The starting frequency of the oscillator.\n * @param type The type of the carrier oscillator.\n * @param modulationType The type of the modulator oscillator.\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new AMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"AMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator = new Oscillator({context : this.context });\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency> = this._carrier.frequency;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents> = this._carrier.detune;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator = new Oscillator({ context : this.context });\n\n\t/**\n\t *  convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t *  @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive> = new Multiply({\n\t\tcontext: this.context,\n\t\tunits: \"positive\",\n\t});\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier.type = options.type;\n\t\tthis._modulator.type = options.modulationType;\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\t\tthis.harmonicity.setValueAtTime(options.harmonicity, 0);\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\tthis.phase = options.phase;\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[Tone.Oscillator](Oscillator) is better for most use-cases***\n *  @extends {Tone.AudioNode}\n *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n *  @param  {Function}  onload  The callback to invoke when the\n *                               buffer is done playing.\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\tname = \"ToneOscillatorNode\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._gainNode, this._oscillator];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t *  The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.frequency,\n\t\t\tunits : \"frequency\",\n\t\t\tvalue : this.toFrequency(options.frequency),\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.detune,\n\t\t\tunits : \"cents\",\n\t\t\tvalue : options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tthis.log(\"start\", time);\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: () => void;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The callback to invoke after the\n\t *  source is done playing.\n\t */\n\tonended: () => void = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t *  The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t *  The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain : 0,\n\t});\n\n\t/**\n\t *  The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn : 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended();\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection\n\t\t\tsetTimeout(() => this.dispose(), 1000);\n\t\t}\n\t}\n\n\t/**\n\t *  Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t *  Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n","import { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by (Tone.Transport)[Transport]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n * @param Transport The transport object which the event belongs to\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { Time, TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { Param } from \"../context/Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * //repeated event every 8th note\n * Transport.scheduleRepeat(function(time){\n * \t//do something with the time\n * }, \"8n\");\n * @example\n * //schedule an event on the 16th measure\n * Transport.schedule(function(time){\n * \t//do something with the time\n * }, \"16:0:0\");\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\tname = \"Transport\";\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tLOOPING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * \tIf the transport loops or not.\n\t */\n\tloop: boolean = false;\n\n\t/**\n\t * \tThe loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * \tThe loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tCLOCK/TEMPO\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t *  watches the main oscillator for timing ticks\n\t *  initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<BPM>;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * Transport.bpm.value = 80;\n\t * //ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: Param<BPM>;\n\n\t/**\n\t *  The time signature, or more accurately the numerator\n\t *  of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tTIMELINE EVENTS\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * \tThe scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t *  Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t *  All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tSWING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t *  The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback : this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency : 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tTICKS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  called on every tick\n\t *  @param  tickTime clock relative tick time\n\t *  @private\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this.loop) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSCHEDULABLE EVENTS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * //trigger the callback when the Transport reaches the desired time\n\t * Transport.schedule(function(time){\n\t * \tenvelope.triggerAttack(time);\n\t * }, \"128i\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * //a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration : new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime : new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t *  Schedule an event that will be removed after it is invoked.\n\t *  @param callback The callback to invoke once.\n\t *  @param time The time the callback should be invoked.\n\t *  @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce : true,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSTART/STOP/PAUSE\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * //start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSETTERS/GETTERS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * //common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * //this will be reduced to a single number\n\t * Transport.timeSignature; //returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn Time(this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn Time(this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * //loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's position in seconds\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's loop position as a normalized value. Always\n\t *  returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t *  Pulses Per Quarter note. This is the smallest resolution\n\t *  the Transport timing supports. This should be set once\n\t *  on initialization and not set again. Changing this value\n\t *  after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSYNCING\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * Transport.start(); //the transport must be started\n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t *  Attaches the signal to the tempo control signal so that\n\t *  any changes in the tempo will change the signal in the same\n\t *  ratio.\n\t *\n\t *  @param signal\n\t *  @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial : signal.value,\n\t\t\tratio : ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsyncs a previously synced signal from the transport's control.\n\t *  See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n///////////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\tname = \"IntervalTimeline\";\n\n\t/**\n\t *  The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t *  Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t *  The event to add to the timeline. All events must\n\t *  have a time and duration value\n\t *  @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t *  @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t *  Remove events whose time time is after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Replace the references to the node in the node's parent\n\t *  with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t *  Remove the node from the tree and replace it with\n\t *  a successor which follows the schema.\n\t */\n\tprivate _removeNode(node): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t *  Rotate the tree to the left\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateLeft(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tnode.right = pivotNode.left;\n\t\tpivotNode.left = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Rotate the tree to the right\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateRight(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tnode.left = pivotNode.right;\n\t\tpivotNode.right = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get an event whose time and duration span the give time. Will\n\t *  return the match whose \"time\" value is closest to the given time.\n\t *  @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *  Iterate over everything in the timeline.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the given time\n\t *  overlaps with the time and duration time of the event.\n\t *  @param  time The time to check if items are overlapping\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the time is greater\n\t *  than or equal to the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time, callback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINTERVAL NODE HELPER\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Represents a node in the binary search tree, with the addition\n *  of a \"high\" value which keeps track of the highest value of\n *  its children.\n *  References:\n *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n *  @param low\n *  @param high\n */\n// tslint:disable-next-line: max-classes-per-file\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low, high, event) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t *  Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which overlap\n\t *  with the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which are less\n\t *  than the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Invoke the callback on this element and both it's branches\n\t *  @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t *  The balance is how the leafs are distributed on the node\n\t *  @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t *  @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t *  get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter, EmitterEventObject } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n *\n * @param callback The callback to be invoked with the time of the audio event\n * @param frequency The rate of the callback\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n */\nexport class Clock<Type extends BPM | Hertz = Hertz>\nextends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\tname = \"Clock\";\n\n\t/**\n\t *  The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t *  The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t *  The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t *  Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t *  The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\tthis.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t *  @param time The time when the clock should stop.\n\t *  @returns {Clock} this\n\t *  @example\n\t * clock.stop();\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t *  The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","export const version = \"14.0.28\";\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription = Array<any | any[]>;\n\ninterface SequenceOptions extends Omit<ToneEventOptions, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @param  callback  The callback to invoke with every note\n * @param  sequence  The sequence\n * @param  subdivision  The subdivision between which events are placed.\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //straight quater notes\n * }, [\"C4\", \"E4\", \"G4\", \"A4\"], \"4n\");\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]);\n */\nexport class Sequence extends ToneEvent {\n\n\tname = \"Sequence\";\n\n\t/**\n\t *  The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: any[] = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: any[] = [];\n\n\tconstructor(\n\t\tcallback?: ToneEventCallback,\n\t\tevents?: SequenceEventDescription,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions {\n\t\treturn Object.assign( omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t *  Start the part at the given time.\n\t *  @param  time    When to start the part.\n\t *  @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the part at the given time.\n\t *  @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The subdivision of the sequence. This can only be\n\t *  set in the constructor. The subdivision is the\n\t *  interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tconst index = parseInt(property, 10);\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Get the time of the index given the Sequence's subdivision\n\t *  @param  index\n\t *  @return The time of that index\n\t *  @private\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// PROXY CALLS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tif (this._part) {\n\t\t\tthis._part.loop = l;\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tif (this._part) {\n\t\t\tthis._part.loopStart = this._indexTime(index);\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (this._part) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t\t} else {\n\t\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t\t}\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tif (this._part) {\n\t\t\tthis._part.startOffset = start;\n\t\t}\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tif (this._part) {\n\t\t\tthis._part.playbackRate = rate;\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tif (this._part) {\n\t\t\tthis._part.probability = prob;\n\t\t}\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tif (this._part) {\n\t\t\tthis._part.humanize = variation;\n\t\t}\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","export { Part } from \"./Part\";\nexport { Sequence } from \"./Sequence\";\nexport { ToneEvent } from \"./ToneEvent\";\n","import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n *  Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced: boolean = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\tthis.output = this._volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnumberOfOutputs: 1,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n\t * will be scheduled along the transport.\n\t * @example\n\t * instrument.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * instrument.triggerAttackRelease('C4', '8n', 0)\n\t * instrument.triggerAttackRelease('E4', '8n', '8n')\n\t * instrument.triggerAttackRelease('G4', '8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Instrument} this\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Trigger the attack and then the release after the duration.\n\t *  @param  note     The note to trigger.\n\t *  @param  duration How long the note should be held for before\n\t *                          triggering the release. This value must be greater than 0.\n\t *  @param time  When the note should be triggered.\n\t *  @param  velocity The velocity the note should be triggered at.\n\t *  @example\n\t * //trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\t// tslint:disable-next-line: variable-name\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t *  @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\t// tslint:disable-next-line: variable-name\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t *  clean up\n\t *  @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t *  The glide time between notes.\n\t */\n\tportamento: Seconds;\n\n\t/**\n\t * The instrument's envelope\n\t */\n\tabstract envelope: any;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<Cents>;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Trigger the attack of the note optionally with a given velocity.\n\t *\n\t *\n\t *  @param  note The note to trigger.\n\t *  @param  time When the note should start.\n\t *  @param  velocity The velocity scaler determines how \"loud\" the note\n\t *                   will be triggered.\n\t *  @example\n\t * synth.triggerAttack(\"C4\");\n\t *  @example\n\t * //trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(time, velocity);\n\t\tthis.setNote(note, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Trigger the release portion of the envelope\n\t *  @param  {Time} [time=now] If no time is given, the release happens immediatly\n\t *  @returns {Monophonic} this\n\t *  @example\n\t * synth.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t *  Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t *  Get the level of the output at the given time. Measures\n\t *  the envelope(s) value at the time.\n\t *  @param time The time to query the envelope value\n\t *  @return The output level between 0-1\n\t */\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t *  Set the note at the given time. If no time is given, the note\n\t *  will set immediately.\n\t *  @param note The note to change to.\n\t *  @param  time The time when the note should be set.\n\t * @example\n\t * //change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t * @example\n\t * //change to Bb4 right now\n\t * synth.setNote(\"Bb4\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(time) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, time);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, time);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n * @param decay\tThe period of time after the attack that it takes for the envelope\n *                       \tto fall to the sustain value. Value must be greater than 0.\n * @param sustain\tThe percent of the maximum value that the envelope rests at until\n *                                \tthe release is triggered.\n * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n *                         \tValue must be greater than 0.\n *  @example\n * var ampEnv = new AmplitudeEnvelope({\n * \t\"attack\": 0.1,\n * \t\"decay\": 0.2,\n * \t\"sustain\": 1.0,\n * \t\"release\": 0.8\n * }).toMaster();\n * //create an oscillator and connect it\n * var osc = new Tone.Oscillator().connect(ampEnv).start();\n * //trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\tname = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorConstructorOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorConstructorOptions;\n\tenvelope: EnvelopeOptions;\n}\n\n/**\n *  Synth is composed simply of a Tone.OmniOscillator routed through a Tone.AmplitudeEnvelope.\n * ```\n * +----------------+     +-------------------+\n * | OmniOscillator +>----> AmplitudeEnvelope +>-->Output\n * +----------------+     +-------------------+\n * ```\n *  @constructor\n *  @param options the options available for the synth.\n *  @example\n * var synth = new Synth().toMaster();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n */\nexport class Synth extends Monophonic<SynthOptions> {\n\n\tname = \"Synth\";\n\n\t/**\n\t *  The oscillator.\n\t */\n\treadonly oscillator = new OmniOscillator({ context: this.context });\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency = this.oscillator.frequency;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune = this.oscillator.detune;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope = new AmplitudeEnvelope({ context: this.context });\n\n\tprotected _internalChannels = [this.oscillator, this.envelope, this.output];\n\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator.set(options.oscillator);\n\t\tthis.envelope.set(options.envelope);\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack : 0.005,\n\t\t\t\t\tdecay : 0.1,\n\t\t\t\t\trelease : 1,\n\t\t\t\t\tsustain : 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t *  start the attack portion of the envelope\n\t *  @param time the time the attack should start\n\t *  @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time?: Time, velocity: number = 1): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(computedTime, velocity);\n\t\tthis.oscillator.start(computedTime);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(computedTime + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t *  start the release portion of the envelope\n\t *  @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","export { Synth } from \"./Synth\";\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./BufferSource\";\n\ninterface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n *\n * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n * @param onload The function to invoke when the buffer is loaded.\n *                            Recommended to use Tone.Buffer.on('load') instead.\n * @example\n * var player = new Player(\"./path/to/sample.mp3\").toMaster();\n * //play as soon as the buffer is loaded\n * player.autostart = true;\n */\nexport class Player extends Source<PlayerOptions> {\n\n\tname = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t * @example\n\t * //will play as soon as it's loaded\n\t * var player = new Player({\n\t * \t\"url\" : \"./path/to/sample.mp3\",\n\t * \t\"autostart\" : true,\n\t * }).toMaster();\n\t */\n\tautostart: boolean;\n\n\t/**\n\t *  The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t *  if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t *  if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t *  if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t *  the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t *  All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tfadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tfadeOut: Time;\n\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart : false,\n\t\t\tfadeIn : 0,\n\t\t\tfadeOut : 0,\n\t\t\tloop : false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload : noOp,\n\t\t\tplaybackRate : 1,\n\t\t\treverse : false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced) {\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t *  Play the buffer at the given startTime. Optionally add an offset\n\t *  and/or duration which will play the buffer from a position\n\t *  within the buffer for the given duration.\n\t *\n\t *  @param  time When the player should start.\n\t *  @param  offset The offset from the beginning of the sample\n\t *                                 to start at.\n\t *  @param  duration How long the sample should play. If no duration is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\toffset = this.toSeconds(offset);\n\n\t\t// if it's synced, it should factor in the playback rate for computing the offset\n\t\tif (this._synced) {\n\t\t\toffset *= this._playbackRate;\n\t\t}\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tlet computedDuration = defaultArg(duration, Math.max(this._buffer.duration - offset, 0));\n\t\tcomputedDuration = this.toSeconds(computedDuration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\tbuffer : this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn : this.fadeIn,\n\t\t\tfadeOut : this.fadeOut,\n\t\t\tloop : this._loop,\n\t\t\tloopEnd : this._loopEnd,\n\t\t\tloopStart : this._loopStart,\n\t\t\tonended : this._onSourceEnd.bind(this),\n\t\t\tplaybackRate : this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(duration)) {\n\t\t\tsource.start(startTime, offset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, offset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t *  Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given,\n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Seek to a specific time in the player's buffer. If the\n\t *  source is no longer playing at that time, it will stop.\n\t *  If you seek to a time that\n\t *  @param {Time} offset The time to seek to.\n\t *  @param {Time=} time The time for the seek event to occur.\n\t *  @return {Player} this\n\t *  @example\n\t * source.start(0.2);\n\t * source.stop(0.4);\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst comptuedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, comptuedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop end time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * //loop 0.1 seconds of the file.\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback speed. 1 is normal speed. This is not a signal because\n\t * Safari and iOS currently don't support playbackRate as a signal.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n *\n * @example\n * var a2g = new AudioToGain();\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\tprotected _internalChannels = [this._norm];\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/BufferSource\";\n\ntype NoiseType = \"white\" | \"brown\" | \"pink\";\n\ninterface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @param type the noise type (white|pink|brown)\n * @example\n * //initialize the noise and start\n * var noise = new Noise(\"pink\").start();\n *\n * //make an autofilter to shape the noise\n * var autoFilter = new Tone.AutoFilter({\n * \t\"frequency\" : \"8m\",\n * \t\"min\" : 800,\n * \t\"max\" : 15000\n * }).connect(Tone.Master);\n *\n * //connect the noise\n * noise.connect(autoFilter);\n * //start the autofilter LFO\n * autoFilter.start()\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\tname = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\tconstructor(options?: NoiseType | Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * noise.type = \"white\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t *  internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource(buffer).connect(this.output);\n\t\tthis._source.loop = true;\n\t\tthis._source.playbackRate.value = this._playbackRate;\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t *  internal stop method\n\t *\n\t *  @param {Time} time\n\t *  @private\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// THE NOISE BUFFERS\n///////////////////////////////////////////////////////////////////////////\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\t// tslint:disable-next-line: one-variable-per-declaration\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","export { Noise } from \"./Noise\";\nexport { Oscillator } from \"./oscillator/Oscillator\";\nexport { AMOscillator } from \"./oscillator/AMOscillator\";\nexport { FMOscillator } from \"./oscillator/FMOscillator\";\nexport { PulseOscillator } from \"./oscillator/PulseOscillator\";\nexport { FatOscillator } from \"./oscillator/FatOscillator\";\nexport { PWMOscillator } from \"./oscillator/PWMOscillator\";\nexport { OmniOscillator } from \"./oscillator/OmniOscillator\";\nexport { ToneOscillatorNode } from \"./oscillator/OscillatorNode\";\nexport { ToneBufferSource } from \"./buffer/BufferSource\";\nexport { Player } from \"./buffer/Player\";\n","import { Context } from \"../context/Context\";\nimport { Ticks, TicksClass } from \"../type/Ticks\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: Context;\n\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = Ticks(options.duration).valueOf();\n\t\tthis._interval = Ticks(options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  A single master output which is connected to the\n *  AudioDestinationNode (aka your speakers).\n *  It provides useful conveniences such as the ability\n *  to set the volume and mute the entire application.\n *  It also gives you the ability to apply master effects to your application.\n *\n *  @example\n * //the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * //a convenience for connecting to the master output is also provided:\n * oscillator.toMaster();\n * //the above two examples are equivalent.\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\tname = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<Decibels> = this.input.volume;\n\t_internalChannels = [this.input, this.output];\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.volume.value = options.volume;\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t *  chained in the master effects chain.\n\t *  @param nodes All arguments will be connected in a row and the Master will be routed through it.\n\t *  @return  {Destination}  this\n\t *  @example\n\t * //some overall compression to keep the levels in check\n\t * var masterCompressor = new Tone.Compressor({\n\t * \t\"threshold\" : -6,\n\t * \t\"ratio\" : 3,\n\t * \t\"attack\" : 0.5,\n\t * \t\"release\" : 0.1\n\t * });\n\t * //give a little boost to the lows\n\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t * //route everything through the filter\n\t * //and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\tname = \"Draw\";\n\n\t/**\n\t *  The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t *  The amount of time before the scheduled time\n\t *  that the callback can be invoked. Default is\n\t *  half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t *  All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t *  Schedule a function at the given time to be invoked\n\t *  on the nearest animation frame.\n\t *  @param  callback  Callback is invoked at the given time.\n\t *  @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime : this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events scheduled after the given time\n\t *  @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../Connect\";\nimport { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { getContext } from \"../Global\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ninterface TickAutomationEvent extends AutomationEvent {\n\tticks: number;\n}\n\ninterface TickSignalOptions extends ParamOptions {\n\tvalue: Hertz | BPM;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n *\n * @param value The initial value of the signal\n */\nexport class TickSignal<Type extends Hertz | BPM> extends Param<Type> {\n\n\tname = \"TickSignal\";\n\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\tprivate _sig: ConstantSourceNode = this.context.createConstantSource();\n\n\tprotected _param = this._sig.offset;\n\n\tprivate _multiplier: number = 1;\n\n\tconstructor(options: Partial<TickSignalOptions>);\n\tconstructor(value?: number);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._sig = this.context.createConstantSource();\n\t\tthis._sig.start(0);\n\t\tthis._param = this._sig.offset;\n\n\t\t// set the multiplier\n\t\tthis.multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis.cancelScheduledValues(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime : 0,\n\t\t\ttype : \"setValue\",\n\t\t\tvalue: this._fromType(options.value as Type),\n\t\t});\n\t\tthis.setValueAtTime(options.value as Type, 0);\n\t}\n\n\tstatic getDefaults(): TickSignalOptions {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tparam: getContext().createConstantSource().offset,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: Type, time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks : 0,\n\t\t\t\ttime : 0,\n\t\t\t\ttype: \"setValue\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValue\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linear\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as Type;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multipler\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n\n\t/**\n\t * Connect the output signal\n\t */\n\tconnect(dstNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnect(this._sig, dstNode, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n *  Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n *\n *  @param frequency The initial frequency that the signal ticks at\n */\nexport class TickSource<Type extends BPM | Hertz> extends ToneWithContext<TickSourceOptions> {\n\n\tname = \"TickSource\";\n\n\t/**\n\t *  The frequency the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t *  The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\tconstructor(frequency?: Frequency);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: this.toFrequency(options.frequency),\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t *  @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the TickSource has been running. Accounts\n\t *  for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state : \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds : this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Returns the scheduled state at the given time.\n\t *  @param  time  The time to query.\n\t *  @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t *  Invoke the callback event at all scheduled ticks between the\n\t *  start time and the end time\n\t *  @param  startTime  The beginning of the search range\n\t *  @param  endTime    The end of the search range\n\t *  @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: number;\n\tmaxDelay: number;\n}\n\n/**\n *  Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n *  @param delayTime The delay applied to the incoming signal.\n *  @param maxDelay The maximum delay time.\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\tname = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t *  The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * The internal channels for channel routing changes\n\t */\n\tprotected _internalChannels: AudioNode[];\n\n\tconstructor(options?: Partial<DelayOptions>)\n\tconstructor(delayTime?: Time, maxDelay?: Time)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tthis.maxDelay = Math.max(this.toSeconds(options.maxDelay), this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(options.maxDelay);\n\t\tthis._internalChannels = [this._delayNode];\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._delayNode.delayTime,\n\t\t\tunits : \"time\",\n\t\t\tvalue : options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime : 0,\n\t\t\tmaxDelay: 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\n\n/**\n *  Wrapper around the OfflineAudioContext\n *  @param  channels  The number of channels to render\n *  @param  duration  The duration to render in samples\n *  @param sampleRate the sample rate to render at\n */\nexport class OfflineContext extends Context {\n\n\tname = \"OfflineContext\";\n\n\t/**\n\t *  A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t *  An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\tconstructor(channels: number | OfflineAudioContext, duration: Seconds, sampleRate: number) {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: channels instanceof OfflineAudioContext ?\n\t\t\t\tchannels : new OfflineAudioContext(channels, duration * sampleRate, sampleRate),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: channels instanceof OfflineAudioContext ?\n\t\t\t\t\t128 / channels.sampleRate : 128 / sampleRate,\n\t\t});\n\n\t\tthis._duration = channels instanceof OfflineAudioContext ?\n\t\t\tchannels.length / channels.sampleRate : duration;\n\t}\n\n\t/**\n\t *  Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t *  Render the output of the OfflineContext\n\t */\n\trender(): Promise<AudioBuffer> {\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t// increment the clock in 5ms chunks\n\t\t\tthis._currentTime += 0.005;\n\t\t}\n\n\t\treturn this._context.startRendering();\n\t}\n\n\t/**\n\t *  Close the context\n\t */\n\tclose(): Promise<OfflineContext> {\n\t\treturn Promise.resolve(this);\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject , isString, isUndef } from \"../util/TypeCheck\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @param  val    The time value as a number, string or object\n * @param  units  Unit values\n * @example\n * new TimeBase(4, \"n\")\n * new TimeBase(2, \"t\")\n * new TimeBase(\"2t\")\n * new TimeBase({\"2t\" : 2})\n * new TimeBase(\"2t\") + new TimeBase(\"4n\");\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\tconstructor(context: Context, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tVALUE OF\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t *  @private\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t *  With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tTEMPO CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tCONVERSION INTERFACE\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t *  Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t *  Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t *  Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t *  Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","export { Gain } from \"./context/Gain\";\nexport { Context } from \"./context/Context\";\nexport { OfflineContext } from \"./context/OfflineContext\";\nexport { ToneAudioBuffer } from \"./context/ToneAudioBuffer\";\nexport { Delay } from \"./context/Delay\";\nexport { Clock } from \"./clock/Clock\";\nexport { Frequency } from \"./type/Frequency\";\nexport { Time } from \"./type/Time\";\nexport { Ticks } from \"./type/Ticks\";\nexport { TransportTime } from \"./type/TransportTime\";\nexport { Draw } from \"./util/Draw\";\nexport { StateTimeline } from \"./util/StateTimeline\";\nexport { IntervalTimeline } from \"./util/IntervalTimeline\";\nexport { Timeline } from \"./util/Timeline\";\nexport { Emitter } from \"./util/Emitter\";\nexport { Tone } from \"./Tone\";\nexport { Destination } from \"./context/Destination\";\nexport { Transport } from \"./clock/Transport\";\n","/**\n * The global audio context which is getable and assignable through\n * getAudioContext and setAudioContext\n */\nlet globalContext: BaseAudioContext;\n\n// @ts-ignore\nglobalContext = window.TONE_AUDIO_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): BaseAudioContext {\n\tif (!globalContext) {\n\t\tsetAudioContext(new AudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: BaseAudioContext): void {\n\tglobalContext = context;\n\t// @ts-ignore\n\twindow.TONE_AUDIO_CONTEXT = globalContext;\n}\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t *  Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t// the initial timeout time\n\t\t\t`var timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();`,\n\t\t]);\n\t\tconst blobUrl = window.URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = window.setTimeout(()  => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./core/index\";\nexport * from \"./source/index\";\nexport * from \"./instrument/index\";\nexport * from \"./event/index\";\n\nimport { getContext } from \"./core/Global\";\n/**\n *  The current audio context time\n */\nexport function now(): Seconds {\n\treturn getContext().now();\n}\n"],"sourceRoot":""}