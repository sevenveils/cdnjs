{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/Connect.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OscillatorNode.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/source/buffer/BufferSource.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/version.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/source/index.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/index.ts","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","TypeCheck_1","deepMerge","target","sources","_i","arguments","length","source","shift","isObject","key","assign","_a","_b","apply","concat","optionsFromArguments","defaults","argsArray","keys","opts","args","Array","from","isDefined","getDefaultsFromInstance","instance","constructor","getDefaults","defaultArg","given","fallback","isUndef","omitFromObject","obj","omit","prop","Reflect","has","readOnly","isArray","forEach","str","writable","noOp","arg","isString","isFunction","isNumber","toString","isBoolean","isNote","test","Defaults_1","ToneWithContext_1","ToneAudioNode","_super","_this","options","numberOfInputs","numberOfOutputs","__extends","ToneWithContext","channelCount","channelCountMode","channelInterpretation","createInsOuts","input","context","createGain","output","_setChannelProperties","_internalChannels","node","_getChannelProperties","props","connect","destination","outputNum","inputNum","toDestination","toMaster","disconnect","chain","nodes","connectSeries","fan","dispose","AudioNode","first","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber","AudioParam","assert","dst","e","Param_1","Interface_1","ToneAudioNode_1","Gain","_gainNode","gain","Param","convert","param","units","globalContext","version_1","Context_1","setContext","initialize","window","TONE_CONTEXT","getContext","Context","start","resume","TONE_SILENCE_LOGGING","prefix","version","printString","console","log","ToneAudioNode_2","Signal","override","_constantSource","createConstantSource","_param","offset","connectSignal","setValueAtTime","time","getValueAtTime","setRampPoint","linearRampToValueAtTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","startTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","setTargetAtTime","timeConstant","setValueCurveAtTime","values","duration","scaling","cancelScheduledValues","cancelAndHoldAtTime","rampTo","overridden","maxValue","minValue","signal","Volume_1","StateTimeline_1","Source","Volume","_volume","undefined","volume","_state","StateTimeline","_synced","_scheduled","_syncedStart","_syncedStop","memory","mute","transport","state","seconds","now","toSeconds","Math","max","currentTime","cancel","setStateAtTime","restart","event_1","sched","schedule","t","_start","push","stop","_stop","bind","sync","stateEvent","startOffset","getSecondsAtTime","sampleTime","on","unsync","off","id","clear","Tone_1","Timeline","_timeline","Infinity","add","event","valueOf","index","_search","splice","diff","remove","indexOf","peek","getAfter","getBefore","len","after","slice","cancelBefore","previousEvent","beginning","end","midPoint","floor","nextEvent","_iterate","callback","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","endTime","forEachFrom","forEachAtTime","Tone","Signal_1","Source_1","OscillatorNode_1","Oscillator","_oscillator","frequency","detune","_partials","partials","_partialCount","partialCount","_phase","phase","_type","type","baseType","oscillator","ToneOscillatorNode","_wave","setPeriodicWave","onended","setTimeout","cancelStop","syncFrequency","syncSignal","unsyncFrequency","unsyncSignal","isBasicType","_getRealImaginary","real","imag","periodicWave","createPeriodicWave","replace","partial","exec","periodicWaveSize","fftSize","Float32Array","parseInt","piFactor","PI","b","TypeError","sin","cos","_inverseFFT","sum","_getInitialValue","twoPi","debug","statement","error","Error","Global_1","Frequency_1","Time_1","TransportTime_1","defaultContext","lookAhead","immediate","sampleRate","TimeClass","toFrequency","freq","FrequencyClass","toTicks","TransportTimeClass","attribute","member","attributes_1","set","Conversions_1","Timeline_1","_minOutput","_events","_initialValue","_fromType","_is","val","dbToGain","min","_toType","gainToDb","numericValue","computedTime","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","constant","_exponentialApproach","currentVal","startingValue","segTime","valueAtTime","t0","v0","v1","exp","t1","pow","_getExpressions","method","capture","_now","regexp","quantize","quantTo","_secondsToUnits","nextSubdivision","subdiv","percent","subdivision","round","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","abs","toBarsBeatsSixteenths","quarterTime","_beatsToUnits","quarters","parseFloat","toFixed","measures","_getTimeSignature","sixteenths","sixteenthString","join","_getPPQ","toMidi","ftom","TimeBaseClass","Time","initial","_initial","getLastState","getNextState","event_2","TransportTime","equalPowerScale","db","LN10","intervalToFrequencyRatio","interval","A4","getA4","setA4","log2","mtof","midi","Emitter","split","eventName","once","boundCallback","eventList","emit","mixin","constr","getOwnPropertyDescriptor","Gain_1","WaveShaper_1","Oscillator_1","PulseOscillator","width","_widthGate","_sawtooth","_thresh","WaveShaper","mapping","Multiply","_mult","factor","TicksClass","defaultUnits","ticks","beats","_getBpm","_ticksToUnits","Ticks","ToneAudioBuffer","onload","reverse","url","AudioBuffer","load","catch","onerror","_buffer","buffer","loaded","_reversed","_reverse","promise","downloads","audioBuffer","sent","e_1","fromArray","array","isMultidimensional","channels","createBuffer","multiChannelArray","copyToChannel","toMono","chanNum","toArray","outputArray","numChannels_1","numberOfChannels","channel","channelArray","map","sample","getChannelData","ret","startSamples","endSamples","replacementArray","rev","fromUrl","matches","match","extensions","extension","extensions_1","ext","supportsType","fetch","baseUrl","response","ok","arrayBuffer","decodeAudioData","document","createElement","canPlayType","notifyNewContext","onContextInit","cb","initializeContext","ctx","notifyCloseContext","onContextClose","closeContext","Ticker_1","Emitter_1","AudioContext_1","ContextInitialization_1","_constants","Map","_timeouts","_timeoutIds","_initialized","_context","_latencyHint","latencyHint","_ticker","Ticker","clockSource","updateInterval","_timeoutLoop","addEventListener","getAudioContext","createAnalyser","createOscillator","createBufferSource","createBiquadFilter","createChannelMerger","createChannelSplitter","createConvolver","createDelay","maxDelayTime","createDynamicsCompressor","createIIRFilter","feedforward","feedback","createPanner","constraints","createStereoPanner","createWaveShaper","audioData","listener","_transport","_destination","hint","lookAheadValue","AudioContext","Promise","resolve","close","getConstant","arr","loop","firstEvent","fn","timeout","clearTimeout","Multiply_1","PulseOscillator_1","PWMOscillator","sourceType","_pulse","_modulator","_scale","modulationFrequency","FatOscillator","_oscillators","_spread","spread","count","_forEach","osc","iterator","start_1","step_1","FMOscillator","_carrier","harmonicity","modulationIndex","_modulationNode","modulationType","_shaper","curve","setMap","normalized","oversample","oversampling","isOverSampleType","some","includes","SignalOperator","AudioToGain_1","AMOscillator","_modulationScale","AudioToGain","Connect_1","OneShotSource_1","OneShotSource","_startGain","_stopSource","_startTime","_stopTime","_timeout","_fadeIn","_fadeOut","_curve","getStateAtTime","fadeInTime","_stopGain","fadeOutTime","ToneAudioBuffer_1","ToneBufferSource","_source","_sourceStarted","_sourceStopped","playbackRate","loopStart","loopEnd","fadeIn","fadeOut","computedDur","additionalTail","TransportEvent","_eventId","_once","invoke","_unmutedVolume","IntervalTimeline","_root","_length","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","results","search","results_1","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes_1","traverse","searchAfter","high","_left","_right","height","point","TickSource_1","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","TickSource","pause","ceil","getTicksAtTime","setTicksAtTime","nextTickTime","when","currentTick","getTimeOfTick","forEachTickBetween","Conversions_2","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","tr","q","total","transpose","harmonize","intervals","toNote","scaleIndexToNote","_noArg","_frequencyToUnits","cbb","c#","cx","dbb","d#","dx","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a","a#","ax","bbb","bb","b#","bx","Frequency","AMOscillator_1","FatOscillator_1","FMOscillator_1","PWMOscillator_1","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","OmniOscillator","_sourceType","substr","_createNewOscillator","_getOscType","oscType","oscConstructor","oldOsc_1","blockTime","sType","mType","SignalOperator_1","_norm","x","BufferSource_1","Noise","_playbackRate","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","Noise_1","OmniOscillator_1","Ticks_1","TransportEvent_1","TransportRepeatEvent","_currentId","_nextId","_nextTick","_boundRestart","_restart","_interval","_createEvents","scheduleOnce","IntervalTimeline_1","Clock_1","TransportRepeatEvent_1","Transport","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","bpm","multiplier","_timeSignature","timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","timeToTicks","remainingTicks","ratio","computedFreq","PPQ","ratioSignal","syncedSignal","Destination","rawContext","unshift","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","TickSignal","_sig","_multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getDurationOfTicks","tick","delta","k","sqrt","sol1","ticksToTime","computedDuration","startTicks","TickSignal_1","_tickOffset","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","elapsedSeconds","absoluteTicks","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","Delay","maxDelay","delayTime","_delayNode","OfflineContext","OfflineAudioContext","_currentTime","_duration","render","startRendering","_val","_units","_expressions","hz","dot","scalar","number","samples","fromType","trim","typeName","quantity","expr","matching","toSamples","toMilliseconds","OfflineContext_1","Delay_1","Draw_1","Destination_1","Transport_1","setAudioContext","TONE_AUDIO_CONTEXT","_callback","_updateInterval","_createClock","_createWorker","blob","Blob","blobUrl","URL","createObjectURL","worker","Worker","onmessage","_worker","_createTimeout","_disposeClock","terminate","postMessage","__export","Global_2"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 57);\n","// import { BaseToneOptions } from \"../Tone\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T, ...sources: T[]): T {\n\tif (!sources.length) { return target; }\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (isObject(source[key])) {\n\t\t\t\tif (!target[key]) { Object.assign(target, { [key]: {} }); }\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T>(defaults: T, argsArray: IArguments, keys: string[] = []): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends object>(obj: T, omit: O): Omit<T, keyof O> {\n\tfor (const prop in omit) {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\t// @ts-ignore\n\t\t\tdelete obj[prop];\n\t\t}\n\t}\n\treturn obj;\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n *  Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n *  Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\tT[P] extends object ? RecursivePartial<T[P]> :\n\tT[P];\n};\n","/**\n *  Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n *  Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n *  Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n *  Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n *  Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n *  Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n *  Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isDefined, isNumber } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport type InputNode = ToneAudioNode | AudioNode | AudioParam | Param<Unit>;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\nexport interface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport interface ToneAudioNodeOptions extends ToneWithContextOptions {\n\tnumberOfInputs: number;\n\tnumberOfOutputs: number;\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n *  ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\nextends ToneWithContext<Options> {\n\n\tabstract name = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | InputNode[] | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | OutputNode[] | undefined;\n\n\t/**\n\t *  The number of inputs feeding into the AudioNode.\n\t *  For source nodes, this will be 0.\n\t */\n\treadonly numberOfInputs: number;\n\n\t/**\n\t *  The number of outputs of the AudioNode.\n\t */\n\treadonly numberOfOutputs: number;\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected abstract _internalChannels: OutputNode[];\n\n\tstatic getDefaults(): ToneAudioNodeOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tchannelCount: 2,\n\t\t\tchannelCountMode: \"max\" as ChannelCountMode,\n\t\t\tchannelInterpretation: \"speakers\" as ChannelInterpretation,\n\t\t\tnumberOfInputs: 0,\n\t\t\tnumberOfOutputs: 0,\n\t\t});\n\t}\n\n\tconstructor(options: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(ToneAudioNode.getDefaults(), arguments, [\"context\"]));\n\n\t\tconst options = optionsFromArguments(ToneAudioNode.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis.numberOfInputs = options.numberOfInputs;\n\t\tthis.numberOfOutputs = options.numberOfOutputs;\n\t}\n\n\tprotected createInsOuts(numberOfInputs: number = 0, numberOfOutputs: number = 0): void {\n\t\tif (numberOfInputs === 1) {\n\t\t\tthis.input = this.context.createGain();\n\t\t} else if (numberOfInputs > 1) {\n\t\t\tthis.input = [];\n\t\t\tfor (let i = 0; i < numberOfInputs; i++) {\n\t\t\t\tthis.input[i] = this.context.createGain();\n\t\t\t}\n\t\t}\n\n\t\tif (numberOfOutputs === 1) {\n\t\t\tthis.output = this.context.createGain();\n\t\t} else if (numberOfOutputs > 1) {\n\t\t\tthis.output = [];\n\t\t\tfor (let o = 0; o < numberOfOutputs; o++) {\n\t\t\t\tthis.output[o] = this.context.createGain();\n\t\t\t}\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// AUDIO PROPERTIES\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tif (this._internalChannels.length) {\n\t\t\tthis._internalChannels.forEach(node => {\n\t\t\t\tnode.channelCount = options.channelCount;\n\t\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tif (this._internalChannels.length) {\n\t\t\tconst node = this._internalChannels[0];\n\t\t\treturn {\n\t\t\t\tchannelCount: node.channelCount,\n\t\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t\t};\n\t\t} else {\n\t\t\t// return the defaults\n\t\t\treturn {\n\t\t\t\tchannelCount: 2,\n\t\t\t\tchannelCountMode: \"max\",\n\t\t\t\tchannelInterpretation: \"speakers\",\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t *  channelCount is the number of channels used when up-mixing and down-mixing\n\t *  connections to any inputs to the node. The default value is 2 except for\n\t *  specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount: number) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t *  channelCountMode determines how channels will be counted when up-mixing and\n\t *  down-mixing connections to any inputs to the node.\n\t *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode: ChannelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t *  channelInterpretation determines how individual channels will be treated\n\t *  when up-mixing and down-mixing connections to any inputs to the node.\n\t *  The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation: ChannelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONNECTIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t */\n\ttoMaster(): this {\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t *  disconnect the output\n\t *  @param output Either the output index to disconnect if the output is an array, or the node to disconnect from.\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Connect the output of this node to the rest of the nodes in series.\n\t *  @param nodes\n\t *  @example\n\t *  //connect a node to an effect, panVol and then to the master output\n\t *  node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  connect the output of this node to the rest of the nodes in parallel.\n\t *  @param nodes\n\t *  @returns this\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isArray(this.input)) {\n\t\t\t\tthis.input.forEach(input => {\n\t\t\t\t\tif (input instanceof ToneAudioNode) {\n\t\t\t\t\t\tinput.dispose();\n\t\t\t\t\t} else if (input instanceof AudioNode) {\n\t\t\t\t\t\tinput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this.input instanceof AudioNode) {\n\t\t\t\t\tthis.input.disconnect();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (isArray(this.output)) {\n\t\t\t\tthis.output.forEach(output => {\n\t\t\t\t\tif (output instanceof ToneAudioNode) {\n\t\t\t\t\t\toutput.dispose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONNECTIONS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n *  connect together all of the arguments in series\n *  @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (prev instanceof AudioNode) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\t// resolve the input of the dstNode\n\twhile (!(dstNode instanceof AudioNode || dstNode instanceof AudioParam)) {\n\t\tif (isArray(dstNode.input)) {\n\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t} else if (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t\tinputNumber = 0;\n\t}\n\n\tif (srcNode instanceof ToneAudioNode) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\t// make the connection\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.connect(dstNode, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (isArray(dstNode.input)) {\n\t\t\t\tif (isNumber(inputNumber)) {\n\t\t\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the input number is greater than the number of inputs\");\n\t\t\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t\t\t} else {\n\t\t\t\t\t// disconnect from all of the nodes\n\t\t\t\t\t// since we don't know which one was connected\n\t\t\t\t\tdstNode.input.forEach(dst => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// catch errors from disconnecting from nodes that are not connected\n\t\t\t\t\t\t\tdisconnect(srcNode, dst, outputNumber);\n\t\t\t\t\t\t\t// tslint:disable-next-line: no-empty\n\t\t\t\t\t\t} catch (e) { }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tinputNumber = 0;\n\t\t\t} else if (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(srcNode instanceof AudioNode)) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (dstNode instanceof AudioNode) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @param  gain The initial gain of the GainNode\n * @param units The units of the gain parameter.\n */\nexport class Gain<Type extends Unit = GainFactor> extends ToneAudioNode<GainOptions> {\n\n\tname = \"Gain\";\n\n\t/**\n\t *  The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * Add all of the gain nodes\n\t */\n\tprotected _internalChannels: AudioNode[] = [this._gainNode];\n\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext : this.context,\n\t\t\tconvert : options.convert,\n\t\t\tparam : this._gainNode.gain,\n\t\t\tunits : options.units,\n\t\t\tvalue : options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert : true,\n\t\t\tgain : 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits : \"gain\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { version } from \"../version\";\nimport { Context } from \"./context/Context\";\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context;\n\n// @ts-ignore\nglobalContext = window.TONE_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getContext(): Context {\n\tif (!globalContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setContext(context: Context): void {\n\tglobalContext = context;\n\tcontext.initialize();\n\t// @ts-ignore\n\twindow.TONE_CONTEXT = context;\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (!this.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\t// @ts-ignore\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// tslint:disable-next-line: no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface SignalOptions<Type> extends ToneAudioNodeOptions {\n\tvalue: Type;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *  @param value Initial value of the signal\n *  @param units unit The units the signal is in.\n * @example\n * const signal = new Tone.Signal(10);\n */\nexport class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>>\nimplements AbstractParam<Type> {\n\n\tname = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprivate _constantSource: ConstantSourceNode = this.context.createConstantSource();\n\treadonly output: OutputNode = this._constantSource;\n\tprotected _param: Param<Type>;\n\treadonly input: InputNode;\n\tprotected _internalChannels = [this._constantSource];\n\n\tconstructor(value?: Type, units?: UnitName);\n\tconstructor(options?: Partial<SignalOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<Type>;\n\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannelCount: 1,\n\t\t\tchannelCountMode: \"explicit\",\n\t\t\tchannelInterpretation: \"discrete\",\n\t\t\tconvert: true,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t}) as SignalOptions<any>;\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): Type {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): Type {\n\t\treturn this._param.value;\n\t}\n\tset value(value: Type) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || destination instanceof AudioParam ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class  Base class for sources. Sources have start/stop methods\n *          and the ability to be synced to the\n *          start/stop of this.context.transport.\n *\n *  @constructor\n *  @extends {Tone.AudioNode}\n *  @example\n * //Multiple state change events can be chained together,\n * //but must be set in the correct order and with ascending times\n *\n * // OK\n * state.start().stop(\"+0.2\");\n * // AND\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n *\n * // BAD\n * state.stop(\"+0.2\").start();\n * // OR\n * state.start(\"+0.3\").stop(\"+0.2\");\n *\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output volume node\n\t *  @type  {Tone.Volume}\n\t *  @private\n\t */\n\tprivate _volume: Volume = new Volume({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * The output note\n\t */\n\toutput = this._volume;\n\tprotected _internalChannels = [this.output];\n\n\t/**\n\t * There is no input\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume = this._volume.volume;\n\n\t/**\n\t * \tKeep track of the scheduled state.\n\t *  @type {Tone.StateTimeline}\n\t *  @private\n\t */\n\tprotected _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The synced `start` callback function from the transport\n\t *  @type {Function}\n\t *  @private\n\t */\n\tprivate _synced = false;\n\n\t/**\n\t *  Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: Partial<SourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\treadOnly(this, \"volume\");\n\t\tthis._state.memory = 100;\n\t\tthis.volume.value = options.volume;\n\t\t// set mute initially\n\t\tthis.mute = options.mute;\n\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds);\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t *  Start the source at the specified time. If no time is given,\n\t *  start the source now.\n\t *  @param  {Time} [time=now] When the source should be started.\n\t *  @returns {Source} this\n\t *  @example\n\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tif (isUndef(time) && this._synced) {\n\t\t\ttime = this.context.transport.seconds;\n\t\t} else {\n\t\t\ttime = this.toSeconds(time);\n\t\t\ttime = Math.max(time, this.context.currentTime);\n\t\t}\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._state.setStateAtTime(\"started\", time);\n\t\t\tthis.restart(time, offset, duration);\n\t\t} else {\n\t\t\tthis._state.setStateAtTime(\"started\", time);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(time);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = this.toSeconds(duration);\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, time);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the source at the specified time. If no time is given,\n\t *  stop the source now.\n\t *  @param  {Time} [time=now] When the source should be stopped.\n\t *  @returns {Source} this\n\t *  @example\n\t * source.stop(); // stops the source immediately\n\t */\n\tstop(time?: Time): this {\n\t\tif (isUndef(time) && this._synced) {\n\t\t\ttime = this.context.transport.seconds;\n\t\t} else {\n\t\t\ttime = this.toSeconds(time);\n\t\t\ttime = Math.max(time, this.context.currentTime);\n\t\t}\n\t\tif (!this._synced) {\n\t\t\tthis._stop.apply(this, arguments);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), time);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(time);\n\t\tthis._state.setStateAtTime(\"stopped\", time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the source to the Transport so that all subsequent\n\t *  calls to `start` and `stop` are synced to the TransportTime\n\t *  instead of the AudioContext time.\n\t *\n\t * @example\n\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * source.sync().start(0).stop(0.3);\n\t * //start the transport.\n\t * this.context.transport.start();\n\t *\n\t * @example\n\t * //start the transport with an offset and the sync'ed sources\n\t * //will start in the correct position\n\t * source.sync().start(0.1);\n\t * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)\n\t * this.context.transport.start(\"+0.5\", 0.5);\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n *  @class A Timeline class for scheduling and maintaining state\n *         along a timeline. All events must have a \"time\" property.\n *         Internally, events are stored in time order for fast\n *         retrieval.\n *  @param memory The number of previous events that are retained.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\tname = \"Timeline\";\n\n\t/**\n\t *  The memory of the timeline, i.e.\n\t *  how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\tconstructor(options?: Partial<TimelineOptions>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(memory?: number);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t};\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t *  @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): Timeline<GenericEvent> {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tconst index = this._search(event.time);\n\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  {Object}  event  The event object to remove from the list.\n\t *  @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): Timeline<GenericEvent> {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the nearest event whose time is less than or equal to the given time.\n\t *  @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the first event in the timeline without removing it\n\t *  @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t *  Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t *  Get the event which is scheduled after the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Get the event before the event at the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Cancel events at and after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): Timeline<GenericEvent> {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events before or equal to the given time.\n\t *  @param  {Number}  time  The time to cancel before.\n\t *  @returns {Timeline} this\n\t */\n\tcancelBefore(time): Timeline<GenericEvent> {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  {Object} event The event to find the previous one of\n\t * @return {Object}       The event right before the given event\n\t */\n\tpreviousEvent(event): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Does a binary search on the timeline array and returns the\n\t *  nearest event index whose time is after or equal to the given time.\n\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t *  If the time is after the end, the index of the last item is returned.\n\t *  @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (event[param] === time) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (testEvent[param] === time) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] < time && nextEvent[param] > time) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] > time) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t *  Internal iterator. Applies extra safety checks for\n\t *  removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t *  Iterate over everything in the array\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or before the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array after the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array between the startTime and endTime.\n\t *  The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t *  range = [startTime, endTime).\n\t *  @param  startTime The time to check if items are before\n\t *  @param  endTime The end of the test interval.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or after the given time. Similar to\n\t *  forEachAfter, but includes the item(s) at the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at the given time\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneOscillatorNode } from \"./OscillatorNode\";\n// type OmniOscillatorSourceType = import(\"./OmniOscillator\").OmniOscillatorSourceType;\n\nexport type ToneOscillatorBaseType = OscillatorType | \"pulse\" | \"pwm\";\n\nexport type ToneOscillatorType = ToneOscillatorBaseType | string;\n\nexport interface ToneOscillatorOptions extends SourceOptions {\n\ttype: ToneOscillatorType;\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tphase: Degrees;\n\tpartials: number[];\n\tpartialCount: number;\n}\n\n/**\n * All Oscillators share this interface\n */\nexport interface OscillatorInterface {\n\tpartials: number[];\n\tpartialCount: number;\n\tphase: Degrees;\n\treadonly frequency: Signal<Frequency>;\n\treadonly detune: Signal<Cents>;\n\ttype: ToneOscillatorType;\n\tbaseType: ToneOscillatorBaseType;\n\t// sourceType: OmniOscillatorSourceType;\n}\n\n/**\n *  Oscillator supports a number of features including\n *  phase rotation, multiple oscillator types (see Oscillator.type),\n *  and Transport syncing (see Oscillator.syncFrequency).\n *\n *  @param frequency Starting frequency\n *  @param type The oscillator type. Read more about type below.\n *  @example\n * //make and start a 440hz sine tone\n * var osc = new Oscillator(440, \"sine\").toMaster().start();\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"Oscillator\";\n\n\t/**\n\t *  the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t *  the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t *  The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t *  the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase: Radians;\n\n\t/**\n\t *  the type of the oscillator\n\t *  @type {string}\n\t *  @private\n\t */\n\tprivate _type;\n\n\tconstructor(options?: Partial<ToneOscillatorOptions>)\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<Frequency>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<Cents>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._phase = options.phase;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString();\n\t\t}\n\t\tthis.phase = this._phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tthis.log(\"start\", time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// disconnect onended\n\t\toscillator.onended = () => {\n\t\t\t// defer the callback for the offline context rendering\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.frequency.disconnect(oscillator.frequency);\n\t\t\t\tthis.detune.disconnect(oscillator.detune);\n\t\t\t}, 100);\n\t\t};\n\n\t\t// start the oscillator\n\t\ttime = this.toSeconds(time);\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tthis.log(\"stop\", time);\n\t\tif (this._oscillator) {\n\t\t\ttime = this.toSeconds(time);\n\t\t\tthis._oscillator.stop(time);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t *  will also affect the oscillators frequency.\n\t *  @example\n\t * Tone.Transport.bpm.value = 120;\n\t * osc.frequency.value = 440;\n\t * //the ration between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * Tone.Transport.bpm.value = 240;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the oscillator's frequency from the Transport.\n\t *  See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/* tslint:disable */\n\t/**\n\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t * 8 partials of the triangle wave.\n\t * <br><br>\n\t * Uses PeriodicWave internally even for native types so that it can set the phase.\n\t * PeriodicWave equations are from the\n\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t *\n\t * @memberOf Oscillator#\n\t * @type {string}\n\t * @name type\n\t * @example\n\t * //set it to a square wave\n\t * osc.type = \"square\";\n\t * @example\n\t * //set the first 6 partials of a sawtooth wave\n\t * osc.type = \"sawtooth6\";\n\t */\n\t/* tslint:enable */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\tthis._wave = periodicWave;\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t}\n\t\t}\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._type.replace(this.partialCount, \"\");\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @example\n\t * osc.type = 'sine'\n\t * osc.partialCount = 3\n\t * //is equivalent to\n\t * osc.type = 'sine3'\n\t */\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p: number) {\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1];\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get the object's attributes. Given no arguments get\n\t *  will return all available object properties and their corresponding\n\t *  values.\n\t */\n\tget(): ToneOscillatorOptions {\n\t\tconst values = super.get();\n\t\tif (values.type !== \"custom\") {\n\t\t\tdelete values.partials;\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t *  Returns the real and imaginary components based\n\t *  on the oscillator type.\n\t *  @returns [real: Float32Array, imaginary: Float32Array]\n\t *  @private\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1];\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\t// tslint:disable: no-bitwise\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t *  Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t *  Returns the initial value of the oscillator.\n\t */\n\tprotected _getInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\t// check for peaks in 8 places\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / 8) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t * @example\n\t * osc.phase = 180; //flips the phase of the oscillator\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\t/**\n\t *  Dispose and disconnect.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\n// import { getContext } from \"./Global\";\nimport \"./type/Units\";\n\n///////////////////////////////////////////////////////////////////////////\n// \tTONE\n///////////////////////////////////////////////////////////////////////////\n\n// tslint:disable-next-line: no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n *  @class  Tone is the base class of all other classes.\n *  @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t *  disconnect and dispose.\n\t */\n\tabstract dispose(): this;\n\n\t/**\n\t * Takes a partial options an returns the completed options by filling in the defaults\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEBUGGING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tprotected debug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @param args\n\t *  @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\t// if (this.debug || this.toString() === global.TONE_DEBUG_CLASS) {\n\t\t// \targs.unshift(this.toString() + \":\");\n\t\t// \t// eslint-disable-next-line no-console\n\t\t// \tconsole.log(...args);\n\t\t// }\n\t}\n\n\t/**\n\t *  Assert that the statement is true, otherwise invoke the error.\n\t *  @param {Boolean} statement\n\t *  @param {String} error The message which is passed into an Error\n\t *  @private\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tif (!statement) {\n\t\t\tthrow new Error(error);\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEFAULTS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  If the `given` parameter is undefined, use the `fallback`.\n\t *  If both `given` and `fallback` are object literals, it will\n\t *  return a deep copy which includes all of the parameters from both\n\t *  objects. If a parameter is undefined in given, it will return\n\t *  the fallback property.\n\t *  <br><br>\n\t *  WARNING: if object is self referential, it will go into an an\n\t *  infinite recursive loop.\n\t *  @memberOf Tone\n\t *  @param  {*} given\n\t *  @param  {*} fallback\n\t *  @return {*}\n\t */\n\t// static defaultArg(given, fallback) {\n\t\t// if (isObject(given) && isObject(fallback)) {\n\t\t// \tconst ret = {};\n\t\t// \t// make a deep copy of the given object\n\t\t// \tfor (const givenProp in given) {\n\t\t// \t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t// \t}\n\t\t// \tfor (const fallbackProp in fallback) {\n\t\t// \t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t// \t}\n\t\t// \treturn ret;\n\t\t// } else {\n\t\t// \treturn isUndef(given) ? fallback : given;\n\t\t// }\n\t// }\n\n\t// protected options(argsArray: IArguments, keys: string[]): object {\n\t// \tlet options: any = {};\n\t// \tconst args = Array.from(argsArray);\n\t// \tif (args[0] instanceof BaseAudioContext) {\n\t// \t\toptions.context = args.shift();\n\t// \t}\n\t// \tif (args.length === 1 && isObject(args[0])) {\n\t// \t\toptions = Object.assign(options, args[0]);\n\t// \t} else {\n\t// \t\tfor (let i = 0; i < keys.length; i++) {\n\t// \t\t\tif (isDefined(args[i])) {\n\t// \t\t\t\toptions[keys[i]] = args[i];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn deepMerge(this.getDefaults(), options);\n\t// }\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tSTATIC\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// static get context(): import(\"./context/Context\").Context {\n\t// \treturn getContext();\n\t// }\n\n\t// static now(): Seconds {\n\t// \treturn Tone.context.now();\n\t// }\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport \"../type/Units\";\nimport { getDefaultsFromInstance, omitFromObject, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isDefined, isUndef } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor\n\t */\n\treadonly defaultContext?: Context;\n\n\tconstructor(context?: Context | Partial<ToneWithContextOptions>) {\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tsuper();\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time: Time): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tGET/SET\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Get the object's attributes. Given no arguments get\n\t * will return all available object properties and their corresponding\n\t * values. Pass in a single attribute to retrieve or an array\n\t * of attributes. The attribute strings can also include a \".\"\n\t * to access deeper properties.\n\t * @param params the parameters to get, otherwise will return all available.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t * @example\n\t * osc.get(\"type\");\n\t * //returns { \"type\" : \"sine\"}\n\t * @example\n\t * //use dot notation to access deep properties\n\t * synth.get([\"envelope.attack\", \"envelope.release\"]);\n\t * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tconst attributes = member.get();\n\t\t\t\t\t// merge only the attributes that are in the defaults\n\t\t\t\t\tObject.keys(defaults[attribute]).forEach(key => {\n\t\t\t\t\t\tdefaults[attribute][key] = attributes[key];\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions extends ToneWithContextOptions {\n\tunits: UnitName;\n\tvalue?: any;\n\tparam: AudioParam;\n\tconvert: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linear\" | \"exponential\" | \"setValue\" | \"setTarget\" | \"cancel\";\n\n/**\n * The events on the automation\n */\nexport interface AutomationEvent {\n\ttype: AutomationType;\n\ttime: number;\n\tvalue: number;\n\tconstant?: number;\n}\n\n/**\n *  Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<Type extends Unit = number>\nextends ToneWithContext<ParamOptions>\nimplements AbstractParam<Type> {\n\n\tname = \"Param\";\n\n\tstatic getDefaults(): ParamOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions);\n\t}\n\n\t/**\n\t * The input connection\n\t */\n\treadonly input: AudioParam;\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t *  The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t *  The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t *  The minimum output value\n\t */\n\tprivate _minOutput = 1e-5;\n\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) && options.param instanceof AudioParam, \"param must be an AudioParam\");\n\n\t\t// initialize\n\t\tthis._param = this.input = options.param;\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.value;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tget value(): Type {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: Type) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\tif (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t *  Convert the given value from the type specified by Param.units\n\t *  into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as Type;\n\t\t} else {\n\t\t\treturn val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis._events.add({\n\t\t\ttime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setValue\", value, time);\n\t\tthis._param.setValueAtTime(numericValue, time);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): Type {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTarget\" && (after === null || after.type === \"setValue\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (isDefined(before.constant)) {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linear\" || after.type === \"exponential\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTarget\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tendTime = this.toSeconds(endTime);\n\t\tthis._events.add({\n\t\t\ttime: endTime,\n\t\t\ttype: \"linear\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"linear\", value, endTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, endTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tendTime = this.toSeconds(endTime);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: endTime,\n\t\t\ttype: \"exponential\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"exponential\", value, endTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, endTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tconst timeConstant = Math.log(this.toSeconds(rampTime) + 1) / Math.log(200);\n\t\ttime = this.toSeconds(time);\n\t\treturn this.setTargetAtTime(value, time, timeConstant);\n\t}\n\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(timeConstant > 0, \"timeConstant must be greater than 0\");\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: startTime,\n\t\t\ttype: \"setTarget\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setTarget\", value, startTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, startTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._events.cancel(time);\n\t\tthis._param.cancelScheduledValues(time);\n\t\tthis.log(\"cancel\", time);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(time));\n\t\tthis.log(\"cancelAndHoldAtTime\", time, \"value=\" + valueAtTime);\n\n\t\t// remove the schedule events\n\t\tthis._param.cancelScheduledValues(time);\n\n\t\t// if there is an event at the given time\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(time);\n\t\tconst after = this._events.getAfter(time);\n\t\tif (before && before.time === time) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(time + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), time);\n\t\t\t} else if (after.type === \"exponential\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), time);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, time);\n\t\treturn this;\n\t}\n\n\trampTo(value: Type, rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\nextends TimeBaseClass<Type, Unit> {\n\n\tname = \"Time\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: number | Subdivision | TimeObject, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\t/**\n\t *  Convert a Time to Notation. The notation values are will be the\n\t *  closest representation between 1m to 128th note.\n\t *  @return {Notation}\n\t *  @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t *  Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t *  Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","export { connect, disconnect, connectSeries } from \"./context/ToneAudioNode\";\n","// import \"../type/Type\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type PlaybackState = \"started\" | \"stopped\" | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\tduration?: Seconds;\n\toffset?: Seconds;\n}\n\n/**\n *  A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n *  @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline extends Timeline<StateTimelineEvent> {\n\n\t/**\n\t *  The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t *  Returns the scheduled state scheduled before or at\n\t *  the given time.\n\t *  @param  time  The time to query.\n\t *  @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a state to the timeline.\n\t *  @param  state The name of the state to set.\n\t *  @param  time  The time to query.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds): this {\n\t\t// all state changes need to be >= the previous state time\n\t\t// TODO throw error if time < the previous event time\n\t\tthis.add({\n\t\t\tstate,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the event before the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check before\n\t *  @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Return the event after the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check from\n\t *  @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\tname = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import \"./Units\";\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n *  @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n *  Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n *  Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn 69 + Math.round(12 * Math.log2(frequency / A4));\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\tname = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t *  Bind a callback to a specific event.\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Bind a callback which is only invoked once\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[])  => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove the event listener.\n\t *  @param  event     The event to stop listening to.\n\t *  @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                    If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Invoke all of the callbacks bound to the event\n\t *  with any arguments passed in.\n\t *  @param  event  The name of the event.\n\t *  @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator, OscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from \"./Oscillator\";\n\ntype PulseOscillatorType = \"pulse\";\n\nexport interface PulseOscillatorOptions extends ToneOscillatorOptions {\n\twidth: NormalRange;\n}\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @param frequency The frequency of the oscillator\n * @param width The width of the pulse\n * @example\n * var pulse = new PulseOscillator(\"E5\", 0.4).toMaster().start();\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"PulseOscillator\";\n\n\t/**\n\t *  The width of the pulse.\n\t */\n\twidth: Signal<AudioRange> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"audioRange\",\n\t});\n\n\t/**\n\t *  gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t *  the sawtooth oscillator\n\t */\n\tprivate _sawtooth: Oscillator = new Oscillator({\n\t\tcontext: this.context,\n\t\ttype : \"sawtooth\",\n\t});\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency> = this._sawtooth.frequency;\n\n\t/**\n\t *  The detune in cents.\n\t */\n\tdetune: Signal<Cents> = this._sawtooth.detune;\n\n\t/**\n\t *  Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width.setValueAtTime(options.width, 0);\n\t\tthis._sawtooth.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis._sawtooth.detune.setValueAtTime(options.detune, 0);\n\t\tthis._sawtooth.phase = options.phase;\n\n\t\t// connections\n\t\tthis._sawtooth.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\t/**\n\t *  Restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._sawtooth.restart(time);\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._sawtooth.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._sawtooth.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): PulseOscillatorType {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): PulseOscillatorType {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t *  Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sawtooth.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @param {number=} value Constant value to multiple\n * @example\n * const mult = new Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * //output of mult is 12.\n *  @example\n * const mult = new Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * //the output of mult is 20.\n */\nexport class Multiply extends Signal<number> {\n\n\tname = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The multiplcant input.\n\t */\n\tinput = this._mult;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput = this._mult;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<number>;\n\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(value?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<number>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\tname = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t *  Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t *  Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n *\n * @param url The url to load, or the audio buffer to set.\n * @param onload A callback which is invoked after the buffer is loaded.\n *                            It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n *                            since it will give you a callback when _all_ buffers are loaded.\n * @param onerror The callback to invoke if there is an error\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n */\nexport class ToneAudioBuffer extends Tone {\n\n\tname = \"ToneAudioBuffer\";\n\n\t/**\n\t *  stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t *  indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && options.url instanceof AudioBuffer || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t *  Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * \tInvokes the callback once the audio buffer loads.\n\t *  @param url The url of the buffer to load. filetype support depends on the browser.\n\t *  @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tSums multiple channels into 1 channel\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t *  @param  channel  The channel number to return\n\t *  @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t *  Cut a subsection of the array and return a buffer of the\n\t *  subsection. Does not modify the original buffer\n\t *  @param start The time to start the slice\n\t *  @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tconst replacementArray: Float32Array[] = [];\n\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\treplacementArray[i] = this.toArray(i).slice(startSamples, endSamples) as Float32Array;\n\t\t}\n\t\tconst retBuffer = new ToneAudioBuffer().fromArray(replacementArray);\n\t\treturn retBuffer;\n\t}\n\n\t/**\n\t *  Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tArray.prototype.reverse.call(this.getChannelData(i));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// STATIC METHODS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t *  Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t *  pass in a multidimensional array.\n\t *  @param array The array to fill the audio buffer\n\t *  @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t *  Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t *  Checks a url's extension to see if the current browser can play that file type.\n\t *  @param url The url/extension to test\n\t *  @return If the file extension can be played\n\t *  @static\n\t *  @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","///////////////////////////////////////////////////////////////////////////\n// INITIALIZING NEW CONTEXT\n///////////////////////////////////////////////////////////////////////////\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isString } from \"../util/TypeCheck\";\nimport { getAudioContext } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"createScriptProcessor\" | \"onstatechange\" | \"addEventListener\"\n\t| \"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\";\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: BaseAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\tname = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: BaseAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t *  The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t *  An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t *  All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t *  The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\tconstructor(context?: BaseAudioContext);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.addEventListener(\"statechange\", () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tinitialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// BASE AUDIO CONTEXT METHODS\n\t///////////////////////////////////////////////////////////////////////\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode {\n\t\treturn this._context.createIIRFilter(feedforward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t *  The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t *  There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t *  A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TICKER\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  How often the interval callback is invoked.\n\t *  This number corresponds to how responsive the scheduling\n\t *  can be. context.updateInterval + context.lookAhead gives you the\n\t *  total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t *  What the source of the clock is, either \"worker\" (default),\n\t *  \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t *  The unwrapped AudioContext.\n\t */\n\tget rawContext(): BaseAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short {@link lookAhead}.\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t *  Starts the audio context from a suspended state. This is required\n\t *  to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && this._context instanceof AudioContext) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t *  Promise which is invoked when the context is running.\n\t *  Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<Context> {\n\t\tif (this._context instanceof AudioContext) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TIMEOUTS\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The private loop which keeps track of the context scheduled timeouts\n\t *  Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void  {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t *  A setTimeout which is guarented by the clock source.\n\t *  Also runs in the offline context.\n\t *  @param  fn       The callback to invoke\n\t *  @param  timeout  The timeout in seconds\n\t *  @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback : fn,\n\t\t\tid : this._timeoutIds,\n\t\t\ttime : now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t *  Clears a previously scheduled timeout with Tone.context.setTimeout\n\t *  @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): Context {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator, OscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from \"./Oscillator\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\nexport interface PWMOscillatorOptions extends ToneOscillatorOptions {\n\tmodulationFrequency: Frequency;\n}\n\ntype PWMOscillatorType = \"pwm\";\n\n/**\n *  @class PWMOscillator modulates the width of a Tone.PulseOscillator\n *         at the modulationFrequency. This has the effect of continuously\n *         changing the timbre of the oscillator by altering the harmonics\n *         generated.\n *\n *  @extends {Tone.Source}\n *  @constructor\n *  @param {Frequency} frequency The starting frequency of the oscillator.\n *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n *  @example\n *  var pwm = new PWMOscillator(\"Ab3\", 0.3).toMaster().start();\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t *  the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator = new PulseOscillator({ context: this.context });\n\t/**\n\t *  the modulator\n\t *  @type {Tone.Oscillator}\n\t *  @private\n\t */\n\tprivate _modulator: Oscillator = new Oscillator({ context: this.context });\n\n\t/**\n\t *  Scale the oscillator so it doesn't go silent\n\t *  at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency> = this._modulator.frequency;\n\n\t/**\n\t *  The detune of the oscillator.\n\t */\n\treadonly detune: Signal<Cents> = this._modulator.detune;\n\n\t/**\n\t *  The modulation rate of the oscillator.\n\t */\n\treadonly modulationFrequency: Signal<Frequency> = this._pulse.frequency;\n\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\t// change the pulse oscillator type\n\t\t// @ts-ignore\n\t\tthis._pulse._sawtooth.type = \"sine\";\n\n\t\tthis._pulse.frequency.setValueAtTime(options.modulationFrequency, 0);\n\t\tthis._modulator.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis._modulator.detune.setValueAtTime(options.detune, 0);\n\t\tthis._modulator.phase = options.phase;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tmodulationFrequency: 0.4,\n\t\t});\n\t}\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): PWMOscillatorType {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): PWMOscillatorType {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator, OscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from \"./Oscillator\";\n\nexport interface FatOscillatorOptions extends ToneOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n\ttype: ToneOscillatorType;\n}\n\n/**\n *  FatOscillator is an array of oscillators with detune spread between the oscillators\n *  @param frequency The oscillator's frequency.\n *  @param type The type of the oscillator.\n *  @param spread The detune spread between the oscillators.\n *  @example\n * var fatOsc = new FatOscillator(\"Ab3\", \"sine\", 40).toMaster().start();\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"FatOscillator\";\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"frequency\",\n\t});\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"cents\",\n\t});\n\n\t/**\n\t *  The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t *  The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t *  The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t *  The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t *  The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\tconstructor(options?: Partial<FatOscillatorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount : 3,\n\t\t\tspread : 20,\n\t\t\ttype : \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.restart(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Should be an integer greater than 1.\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\n\tset count(count: number) {\n\t\tcount = Math.max(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext : this.context,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t} else {\n\t\t\t\t\tosc.type = this._type;\n\t\t\t\t}\n\t\t\t\tosc.partialCount = this._partialCount;\n\t\t\t\tosc.phase = this._phase + (i / count) * 360;\n\t\t\t\tosc.volume.value = -6 - count * 1.1;\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @memberOf FatOscillator#\n\t * @type {Array}\n\t * @name partials\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @memberOf FatOscillator#\n\t * @type {Number}\n\t * @name partialCount\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator, OscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from \"./Oscillator\";\n\nexport interface FMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: ToneOscillatorType;\n}\n\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @param frequency The starting frequency of the oscillator.\n * @param type The type of the carrier oscillator.\n * @param modulationType The type of the modulator oscillator.\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new FMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"FMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator = new Oscillator({\n\t\tcontext : this.context,\n\t\tfrequency: 0,\n\t});\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"frequency\",\n\t});\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents> = this._carrier.detune;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator = new Oscillator({ context : this.context });\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t *  @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive> = new Multiply({\n\t\tcontext: this.context,\n\t\tunits: \"positive\",\n\t});\n\n\t/**\n\t *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t *  modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<Positive> = new Multiply({\n\t\tcontext: this.context,\n\t\tunits: \"positive\",\n\t});\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\tconstructor(options?: Partial<FMOscillatorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier.type = options.type;\n\t\tthis._modulator.type = options.modulationType;\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\t\tthis.harmonicity.setValueAtTime(options.harmonicity, 0);\n\t\tthis.modulationIndex.setValueAtTime(options.modulationIndex, 0);\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\tthis.phase = options.phase;\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  stop and restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction, isUndef } from \"../core/util/TypeCheck\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\ntype WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping =  WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n *  @param mapping The function used to define the values.\n *                 The mapping function should take two arguments:\n *                 the first is the value at the current position\n *                 and the second is the array position.\n *                 If the argument is an array, that array will be\n *                 set as the wave shaping function. The input\n *                 signal is an AudioRange [-1, 1] value and the output\n *                 signal can take on any numerical values.\n *\n *  @param bufferLen The length of the WaveShaperNode buffer.\n *  @example\n * var timesTwo = new WaveShaper(function(val){\n * \treturn val * 2;\n * }, 2048);\n *  @example\n * //a waveshaper can also be constructed with an array of values\n * var invert = new WaveShaper([1, -1]);\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\tname = \"WaveShaper\";\n\n\t/**\n\t *  the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\tprotected _internalChannels = [this._shaper];\n\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor(mapping?: WaveShaperMapping , length?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t *  Uses a mapping function to set the value of the curve.\n\t *  @param mapping The function used to define the values.\n\t *                 The mapping function take two arguments:\n\t *                 the first is the value at the current position\n\t *                 which goes from -1 to 1 over the number of elements\n\t *                 in the curve array. The second argument is the array position.\n\t * @example\n\t * //map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap(function(val, index){\n\t * \treturn (val + 1) * 5;\n\t * })\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length: number = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tthis.assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"..//core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator, OscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from \"./Oscillator\";\n\nexport interface AMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: ToneOscillatorType;\n}\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n *\n * @param frequency The starting frequency of the oscillator.\n * @param type The type of the carrier oscillator.\n * @param modulationType The type of the modulator oscillator.\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new AMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"AMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator = new Oscillator({context : this.context });\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency> = this._carrier.frequency;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents> = this._carrier.detune;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator = new Oscillator({ context : this.context });\n\n\t/**\n\t *  convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t *  @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive> = new Multiply({\n\t\tcontext: this.context,\n\t\tunits: \"positive\",\n\t});\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\tconstructor(options?: Partial<AMOscillatorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier.type = options.type;\n\t\tthis._modulator.type = options.modulationType;\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\t\tthis.harmonicity.setValueAtTime(options.harmonicity, 0);\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\tthis.phase = options.phase;\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[Tone.Oscillator](Oscillator) is better for most use-cases***\n *  @extends {Tone.AudioNode}\n *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n *  @param  {Function}  onload  The callback to invoke when the\n *                               buffer is done playing.\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\tname = \"ToneOscillatorNode\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._gainNode, this._oscillator];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t *  The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.frequency,\n\t\t\tunits : \"frequency\",\n\t\t\tvalue : this.toFrequency(options.frequency),\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.detune,\n\t\t\tunits : \"cents\",\n\t\t\tvalue : options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tthis.log(\"start\", time);\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t *  @return  {OscillatorNode}  this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\nimport { PlaybackState } from \"../core/util/StateTimeline\";\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: () => void;\n}\n\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The callback to invoke after the\n\t *  source is done playing.\n\t */\n\tonended: () => void = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t *  The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t *  The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain : 0,\n\t});\n\n\t/**\n\t *  The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time = 0;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time = 0;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: \"linear\" | \"exponential\" = \"linear\";\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tonended : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\tthis._stopSource(this.now());\n\t\t\tthis.onended();\n\t\t\t// disconnect when it's ended, to free up for garbage collection\n\t\t\tsetTimeout(() => this._gainNode.disconnect(), 100);\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t *  Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n *  @class Wrapper around the native BufferSourceNode.\n *  @extends {Tone.AudioNode}\n *  @param  buffer   The buffer to play\n *  @param  onended  The callback to invoke when the buffer is done playing.\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\tname = \"ToneBufferSource\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._gainNode, this._source];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<Positive>;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = this._stopSource.bind(this);\n\n\t\t/**\n\t\t *  The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._source.playbackRate,\n\t\t\tunits : \"positive\",\n\t\t\tvalue : options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tcurve: \"linear\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): \"linear\" | \"exponential\" {\n\t\treturn this._curve;\n\t}\n\tset curve(t: \"linear\" | \"exponential\") {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t *  Start the buffer\n\t *  @param  time When the player should start.\n\t *  @param  offset The offset from the beginning of the sample to start at.\n\t *  @param  duration How long the sample should play. If no duration\n\t *                   is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t *  @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\ttime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(time, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\toffset = this.toSeconds(offset);\n\t\t// make sure the offset is not less than 0\n\t\toffset = Math.max(offset, 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (offset >= loopEnd) {\n\t\t\t\toffset = ((offset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (offset < this.buffer.duration) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(time, offset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(time + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(): void {\n\t\tif (!this._sourceStopped) {\n\t\t\tthis._sourceStopped = true;\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? this.toSeconds(this._fadeOut) * 2 : 0;\n\t\t\tif (this._sourceStarted && this._stopTime !== -1) {\n\t\t\t\tthis._source.stop(this._stopTime + additionalTail);\n\t\t\t}\n\n\t\t\tthis.onended();\n\t\t\t// remove the onended callback\n\t\t\tthis.onended = noOp;\n\n\t\t\t// dispose the source after it's come to a stop\n\t\t\tsetTimeout(() => {\n\t\t\t\t// if it hasn't already been disposed\n\t\t\t\tif (this._source) {\n\t\t\t\t\tthis._source.disconnect();\n\t\t\t\t\tthis._gainNode.disconnect();\n\t\t\t\t}\n\t\t\t}, additionalTail * 1000 + 100);\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t * @memberOf ToneBufferSource#\n\t * @type {Tone.Buffer}\n\t * @name buffer\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by (Tone.Transport)[Transport]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n * @param Transport The transport object which the event belongs to\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class Volume is a simple volume node, useful for creating a volume fader.\n *\n *  @extends {Tone.AudioNode}\n *  @constructor\n *  @param {Decibels} [volume=0] the initial volume\n *  @example\n * var vol = new Volume(-12);\n * instrument.chain(vol, Tone.Master);\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\tname = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<Decibels> = new Gain({\n\t\tcontext: this.context,\n\t\tunits: \"decibels\",\n\t});\n\tprotected _internalChannels = [this.output];\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput = this.output;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t *  The volume control in decibels.\n\t */\n\tvolume: Param<Decibels> = this.output.gain;\n\n\tconstructor(options?: Decibels | Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.volume.value = options.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * volume.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\tname = \"IntervalTimeline\";\n\n\t/**\n\t *  The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t *  Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t *  The event to add to the timeline. All events must\n\t *  have a time and duration value\n\t *  @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t *  @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t *  Remove events whose time time is after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Replace the references to the node in the node's parent\n\t *  with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t *  Remove the node from the tree and replace it with\n\t *  a successor which follows the schema.\n\t */\n\tprivate _removeNode(node): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t *  Rotate the tree to the left\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateLeft(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tnode.right = pivotNode.left;\n\t\tpivotNode.left = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Rotate the tree to the right\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateRight(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tnode.left = pivotNode.right;\n\t\tpivotNode.right = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get an event whose time and duration span the give time. Will\n\t *  return the match whose \"time\" value is closest to the given time.\n\t *  @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *  Iterate over everything in the timeline.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the given time\n\t *  overlaps with the time and duration time of the event.\n\t *  @param  time The time to check if items are overlapping\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the time is greater\n\t *  than or equal to the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time, callback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINTERVAL NODE HELPER\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Represents a node in the binary search tree, with the addition\n *  of a \"high\" value which keeps track of the highest value of\n *  its children.\n *  References:\n *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n *  @param low\n *  @param high\n */\n// tslint:disable-next-line: max-classes-per-file\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low, high, event) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t *  Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which overlap\n\t *  with the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which are less\n\t *  than the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Invoke the callback on this element and both it's branches\n\t *  @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t *  The balance is how the leafs are distributed on the node\n\t *  @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t *  @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t *  get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter, EmitterEventObject } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n *\n * @param callback The callback to be invoked with the time of the audio event\n * @param frequency The rate of the callback\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n */\nexport class Clock<Type extends BPM | Hertz = Hertz>\nextends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\tname = \"Clock\";\n\n\t/**\n\t *  The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t *  The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t *  The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t *  Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t *  The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\tthis.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t *  @param time The time when the clock should stop.\n\t *  @returns {Clock} this\n\t *  @example\n\t * clock.stop();\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t *  The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\tname = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUGMENT BASE EXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote : {\n\t\t\t\tregexp : /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tEXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t *  @return  A new transposed frequency\n\t *  @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t *  Takes an array of semitone intervals and returns\n\t *  an array of frequencies transposed by those intervals.\n\t *  @return  Returns an array of Frequencies\n\t *  @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t *  @return  {MIDI}\n\t *  @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t *  Return the value of the frequency in Scientific Pitch Notation\n\t *  @return  {Note}\n\t *  @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS HELPERS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tFREQUENCY CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Note to scale index\n *  @type  {Object}\n *  @private\n */\nconst noteToScaleIndex = {\n\t// tslint:disable-next-line\n\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n};\n\n/**\n *  scale index to note (sharps)\n *  @type  {Array}\n *  @private\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","export const version = \"14.0.11\";\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator, AMOscillatorOptions } from \"./AMOscillator\";\nimport { FatOscillator, FatOscillatorOptions } from \"./FatOscillator\";\nimport { FMOscillator, FMOscillatorOptions } from \"./FMOscillator\";\nimport { Oscillator, OscillatorInterface,\n\tToneOscillatorBaseType, ToneOscillatorOptions,\n\tToneOscillatorType } from \"./Oscillator\";\nimport { PulseOscillator, PulseOscillatorOptions } from \"./PulseOscillator\";\nimport { PWMOscillator, PWMOscillatorOptions } from \"./PWMOscillator\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * The constructor of each of the OmniOscillator types\n */\ntype TypeofAnyOscillator = typeof Oscillator | typeof PWMOscillator |\n\ttypeof PulseOscillator | typeof FatOscillator |\n\ttypeof AMOscillator | typeof FMOscillator;\n\n/**\n * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n * when it's not.\n */\ntype OmniOscillatorType = string;\n\n/**\n * Select the Oscillator's Options depending on the generic type.\n */\ntype ConditionalOptions<Osc extends AnyOscillator> =\n\tOsc extends FMOscillator ? FMOscillatorOptions :\n\tOsc extends Oscillator ? ToneOscillatorOptions :\n\tOsc extends AMOscillator ? AMOscillatorOptions :\n\tOsc extends FatOscillator ? FatOscillatorOptions :\n\tOsc extends PulseOscillator ? PulseOscillatorOptions :\n\tOsc extends PWMOscillator ? PWMOscillatorOptions :\n\tToneOscillatorOptions;\n\n/**\n * The aggregate options of all of the oscillators\n */\nexport type OmniOscillatorOptions = ConditionalOptions<AnyOscillator>;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\n// tslint:disable-next-line: variable-name\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType] : TypeofAnyOscillator\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n * into one class. The oscillator class can be changed by setting the `type`.\n * `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n * any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n * will use the FMOscillator, AMOscillator or FatOscillator respectively.\n * For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n * to a FatOscillator of type \"sawtooth\".\n *\n * @param frequency The initial frequency of the oscillator.\n * @param type The type of the oscillator.\n * @example\n * var omniOsc = new OmniOscillator(\"C#4\", \"pwm\");\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\nextends Source<OmniOscillatorOptions> implements OscillatorInterface {\n\n\tname = \"OmniOscillator\";\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"frequency\",\n\t});\n\n\t/**\n\t *  The detune control.\n\t */\n\treadonly detune: Signal<Cents> = new Signal({\n\t\tcontext: this.context,\n\t\tunits: \"cents\",\n\t});\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t *  the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\tconstructor(options?: Partial<ConditionalOptions<OscType>>);\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency.setValueAtTime(options.frequency, 0);\n\t\tthis.detune.setValueAtTime(options.detune, 0);\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// // set the oscillator\n\t\t// this.type = options.type;\n\t\t// set the options\n\t\tthis.set<Oscillator>(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Oscillator.getDefaults();\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\trestart(time?: Time): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not.\n\t * @example\n\t * omniOsc.type = \"pwm\";\n\t * //modulationFrequency is parameter which is available\n\t * //only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t * @example\n\t * //an square wave frequency modulated by a sawtooth\n\t * omniOsc.type = \"fmsquare\";\n\t * omniOsc.modulationType = \"sawtooth\";\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2);\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2);\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3);\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = type;\n\t\t}\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\t/**\n\t * The partial count of the oscillator. This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * //set the maximum number of partials\n\t * osc.partialCount = 0;\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset<Osc extends AnyOscillator = OscType>(props: Partial<ConditionalOptions<Osc>>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t\t// delete props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the object's attributes. Given no arguments get\n\t *  will return all available object properties and their corresponding\n\t *  values. Pass in a single attribute to retrieve or an array\n\t *  of attributes. The attribute strings can also include a \".\"\n\t *  to access deeper properties.\n\t */\n\tget<Osc extends AnyOscillator = OscType>(): ConditionalOptions<Osc> {\n\t\tconst options = this._oscillator.get();\n\t\toptions.type = this.type;\n\t\treturn options as ConditionalOptions<Osc>;\n\t}\n\n\t/**\n\t *  connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst oscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new oscConstructor({\n\t\t\t\t// @ts-ignore\n\t\t\t\tcontext : this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare\");\n\t * omniOsc.sourceType // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare4\");\n\t * omniOsc.sourceType // 'fm'\n\t * omniOsc.baseType //'square'\n\t * omniOsc.partialCount //4\n\t */\n\tget baseType(): ToneOscillatorBaseType {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pulse\");\n\t * //can access the width attribute only if type === \"pulse\"\n\t * omniOsc.width.value = 0.2;\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<AudioRange>> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators, when sourceType === \"fat\".\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t * for more info.\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator\n\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t * for more info.\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t * See Tone.FMOscillator for more info.\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t *  for more info.\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator\n\t * (only if the oscillator type is set to pwm). See\n\t * Tone.PWMOscillator for more info.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pwm\");\n\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t * omniOsc.modulationFrequency.value = 0.2;\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<Frequency>> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n *         See Tone.GainToAudio.\n *\n *  @extends {Tone.SignalBase}\n *  @constructor\n *  @example\n *  var a2g = new AudioToGain();\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\tprotected _internalChannels = [this._norm];\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/BufferSource\";\n\ntype NoiseType = \"white\" | \"brown\" | \"pink\";\n\ninterface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @param type the noise type (white|pink|brown)\n * @example\n * //initialize the noise and start\n * var noise = new Noise(\"pink\").start();\n *\n * //make an autofilter to shape the noise\n * var autoFilter = new Tone.AutoFilter({\n * \t\"frequency\" : \"8m\",\n * \t\"min\" : 800,\n * \t\"max\" : 15000\n * }).connect(Tone.Master);\n *\n * //connect the noise\n * noise.connect(autoFilter);\n * //start the autofilter LFO\n * autoFilter.start()\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\tname = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\tconstructor(options?: NoiseType | Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * noise.type = \"white\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t *  internal start method\n\t */\n\tprotected _start(time: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource(buffer).connect(this.output);\n\t\tthis._source.loop = true;\n\t\tthis._source.playbackRate.value = this._playbackRate;\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t *  internal stop method\n\t *\n\t *  @param {Time} time\n\t *  @private\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// THE NOISE BUFFERS\n///////////////////////////////////////////////////////////////////////////\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\t// tslint:disable-next-line: one-variable-per-declaration\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","export { Noise } from \"./Noise\";\nexport { Oscillator } from \"./oscillator/Oscillator\";\nexport { AMOscillator } from \"./oscillator/AMOscillator\";\nexport { FMOscillator } from \"./oscillator/FMOscillator\";\nexport { PulseOscillator } from \"./oscillator/PulseOscillator\";\nexport { FatOscillator } from \"./oscillator/FatOscillator\";\nexport { PWMOscillator } from \"./oscillator/PWMOscillator\";\nexport { OmniOscillator } from \"./oscillator/OmniOscillator\";\nexport { ToneOscillatorNode } from \"./oscillator/OscillatorNode\";\nexport { ToneBufferSource } from \"./buffer/BufferSource\";\n","import { Context } from \"../context/Context\";\nimport { Ticks, TicksClass } from \"../type/Ticks\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: Context;\n\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = Ticks(options.duration).valueOf();\n\t\tthis._interval = Ticks(options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { Time, TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { Param } from \"../context/Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * //repeated event every 8th note\n * Transport.scheduleRepeat(function(time){\n * \t//do something with the time\n * }, \"8n\");\n * @example\n * //schedule an event on the 16th measure\n * Transport.schedule(function(time){\n * \t//do something with the time\n * }, \"16:0:0\");\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\tname = \"Transport\";\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tLOOPING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * \tIf the transport loops or not.\n\t */\n\tloop: boolean = false;\n\n\t/**\n\t * \tThe loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * \tThe loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tCLOCK/TEMPO\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t *  watches the main oscillator for timing ticks\n\t *  initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<BPM>;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * Transport.bpm.value = 80;\n\t * //ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: Param<BPM>;\n\n\t/**\n\t *  The time signature, or more accurately the numerator\n\t *  of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tTIMELINE EVENTS\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * \tThe scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t *  Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t *  All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tSWING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t *  The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback : this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency : 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tTICKS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  called on every tick\n\t *  @param  tickTime clock relative tick time\n\t *  @private\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this.loop) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSCHEDULABLE EVENTS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * //trigger the callback when the Transport reaches the desired time\n\t * Transport.schedule(function(time){\n\t * \tenvelope.triggerAttack(time);\n\t * }, \"128i\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * //a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration : new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime : new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t *  Schedule an event that will be removed after it is invoked.\n\t *  @param callback The callback to invoke once.\n\t *  @param time The time the callback should be invoked.\n\t *  @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce : true,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSTART/STOP/PAUSE\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * //start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSETTERS/GETTERS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * //common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * //this will be reduced to a single number\n\t * Transport.timeSignature; //returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn Time(this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn Time(this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * //loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's position in seconds\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's loop position as a normalized value. Always\n\t *  returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t *  Pulses Per Quarter note. This is the smallest resolution\n\t *  the Transport timing supports. This should be set once\n\t *  on initialization and not set again. Changing this value\n\t *  after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSYNCING\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * Transport.start(); //the transport must be started\n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t *  Attaches the signal to the tempo control signal so that\n\t *  any changes in the tempo will change the signal in the same\n\t *  ratio.\n\t *\n\t *  @param signal\n\t *  @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial : signal.value,\n\t\t\tratio : ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsyncs a previously synced signal from the transport's control.\n\t *  See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n///////////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  A single master output which is connected to the\n *  AudioDestinationNode (aka your speakers).\n *  It provides useful conveniences such as the ability\n *  to set the volume and mute the entire application.\n *  It also gives you the ability to apply master effects to your application.\n *\n *  @example\n * //the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * //a convenience for connecting to the master output is also provided:\n * oscillator.toMaster();\n * //the above two examples are equivalent.\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\tname = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<Decibels> = this.input.volume;\n\t_internalChannels = [this.input, this.output];\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.volume.value = options.volume;\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t *  chained in the master effects chain.\n\t *  @param nodes All arguments will be connected in a row and the Master will be routed through it.\n\t *  @return  {Destination}  this\n\t *  @example\n\t * //some overall compression to keep the levels in check\n\t * var masterCompressor = new Tone.Compressor({\n\t * \t\"threshold\" : -6,\n\t * \t\"ratio\" : 3,\n\t * \t\"attack\" : 0.5,\n\t * \t\"release\" : 0.1\n\t * });\n\t * //give a little boost to the lows\n\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t * //route everything through the filter\n\t * //and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\tname = \"Draw\";\n\n\t/**\n\t *  The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t *  The amount of time before the scheduled time\n\t *  that the callback can be invoked. Default is\n\t *  half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t *  All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t *  Schedule a function at the given time to be invoked\n\t *  on the nearest animation frame.\n\t *  @param  callback  Callback is invoked at the given time.\n\t *  @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime : this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events scheduled after the given time\n\t *  @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../Connect\";\nimport { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { getContext } from \"../Global\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ninterface TickAutomationEvent extends AutomationEvent {\n\tticks: number;\n}\n\ninterface TickSignalOptions extends ParamOptions {\n\tvalue: Hertz | BPM;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n *\n * @param value The initial value of the signal\n */\nexport class TickSignal<Type extends Hertz | BPM> extends Param<Type> {\n\n\tname = \"TickSignal\";\n\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\tprivate _sig: ConstantSourceNode = this.context.createConstantSource();\n\n\tprotected _param = this._sig.offset;\n\n\tprivate _multiplier: number = 1;\n\n\tconstructor(options: Partial<TickSignalOptions>);\n\tconstructor(value?: number);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._sig = this.context.createConstantSource();\n\t\tthis._sig.start(0);\n\t\tthis._param = this._sig.offset;\n\n\t\t// set the multiplier\n\t\tthis.multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis.cancelScheduledValues(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime : 0,\n\t\t\ttype : \"setValue\",\n\t\t\tvalue: this._fromType(options.value as Type),\n\t\t});\n\t\tthis.setValueAtTime(options.value as Type, 0);\n\t}\n\n\tstatic getDefaults(): TickSignalOptions {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tparam: getContext().createConstantSource().offset,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: Type, time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks : 0,\n\t\t\t\ttime : 0,\n\t\t\t\ttype: \"setValue\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValue\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linear\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as Type;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multipler\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n\n\t/**\n\t * Connect the output signal\n\t */\n\tconnect(dstNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnect(this._sig, dstNode, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n *  Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n *\n *  @param frequency The initial frequency that the signal ticks at\n */\nexport class TickSource<Type extends BPM | Hertz> extends ToneWithContext<TickSourceOptions> {\n\n\tname = \"TickSource\";\n\n\t/**\n\t *  The frequency the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t *  The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\tconstructor(frequency?: Frequency);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: this.toFrequency(options.frequency),\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}, ToneWithContext.getDefaults()) as TickSourceOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t *  @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the TickSource has been running. Accounts\n\t *  for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state : \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds : this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Returns the scheduled state at the given time.\n\t *  @param  time  The time to query.\n\t *  @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t *  Invoke the callback event at all scheduled ticks between the\n\t *  start time and the end time\n\t *  @param  startTime  The beginning of the search range\n\t *  @param  endTime    The end of the search range\n\t *  @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: number;\n\tmaxDelay: number;\n}\n\n/**\n *  Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n *  @param delayTime The delay applied to the incoming signal.\n *  @param maxDelay The maximum delay time.\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\tname = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t *  The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * The internal channels for channel routing changes\n\t */\n\tprotected _internalChannels: AudioNode[];\n\n\tconstructor(options?: Partial<DelayOptions>)\n\tconstructor(delayTime?: Time, maxDelay?: Time)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tthis.maxDelay = Math.max(this.toSeconds(options.maxDelay), this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(options.maxDelay);\n\t\tthis._internalChannels = [this._delayNode];\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._delayNode.delayTime,\n\t\t\tunits : \"time\",\n\t\t\tvalue : options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime : 0,\n\t\t\tmaxDelay: 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\n\n/**\n *  Wrapper around the OfflineAudioContext\n *  @param  channels  The number of channels to render\n *  @param  duration  The duration to render in samples\n *  @param sampleRate the sample rate to render at\n */\nexport class OfflineContext extends Context {\n\n\tname = \"OfflineContext\";\n\n\t/**\n\t *  A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t *  An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\tconstructor(channels: number | OfflineAudioContext, duration: Seconds, sampleRate: number) {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: channels instanceof OfflineAudioContext ?\n\t\t\t\tchannels : new OfflineAudioContext(channels, duration * sampleRate, sampleRate),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: channels instanceof OfflineAudioContext ?\n\t\t\t\t\t128 / channels.sampleRate : 128 / sampleRate,\n\t\t});\n\n\t\tthis._duration = channels instanceof OfflineAudioContext ?\n\t\t\tchannels.length / channels.sampleRate : duration;\n\t}\n\n\t/**\n\t *  Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t *  Render the output of the OfflineContext\n\t */\n\trender(): Promise<AudioBuffer> {\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t// increment the clock in 5ms chunks\n\t\t\tthis._currentTime += 0.005;\n\t\t}\n\n\t\treturn this._context.startRendering();\n\t}\n\n\t/**\n\t *  Close the context\n\t */\n\tclose(): Promise<OfflineContext> {\n\t\treturn Promise.resolve(this);\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject , isString, isUndef } from \"../util/TypeCheck\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @param  val    The time value as a number, string or object\n * @param  units  Unit values\n * @example\n * new TimeBase(4, \"n\")\n * new TimeBase(2, \"t\")\n * new TimeBase(\"2t\")\n * new TimeBase({\"2t\" : 2})\n * new TimeBase(\"2t\") + new TimeBase(\"4n\");\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\tconstructor(context: Context, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tVALUE OF\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t *  @private\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t *  With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tTEMPO CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tCONVERSION INTERFACE\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t *  Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t *  Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t *  Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t *  Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\treturn this;\n\t}\n}\n","export { Gain } from \"./context/Gain\";\nexport { Context } from \"./context/Context\";\nexport { OfflineContext } from \"./context/OfflineContext\";\nexport { ToneAudioBuffer } from \"./context/ToneAudioBuffer\";\nexport { Delay } from \"./context/Delay\";\nexport { Clock } from \"./clock/Clock\";\nexport { Frequency } from \"./type/Frequency\";\nexport { Time } from \"./type/Time\";\nexport { Ticks } from \"./type/Ticks\";\nexport { TransportTime } from \"./type/TransportTime\";\nexport { Draw } from \"./util/Draw\";\nexport { StateTimeline } from \"./util/StateTimeline\";\nexport { IntervalTimeline } from \"./util/IntervalTimeline\";\nexport { Timeline } from \"./util/Timeline\";\nexport { Emitter } from \"./util/Emitter\";\nexport { Tone } from \"./Tone\";\nexport { Destination } from \"./context/Destination\";\nexport { Transport } from \"./clock/Transport\";\n","/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseAudioContext;\n\n// @ts-ignore\nglobalContext = window.TONE_AUDIO_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): BaseAudioContext {\n\tif (!globalContext) {\n\t\tsetAudioContext(new AudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: BaseAudioContext): void {\n\tglobalContext = context;\n\t// @ts-ignore\n\twindow.TONE_AUDIO_CONTEXT = globalContext;\n}\n","\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t *  Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t// the initial timeout time\n\t\t\t`var timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();`,\n\t\t]);\n\t\tconst blobUrl = window.URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = window.setTimeout(()  => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./core/index\";\nexport * from \"./source/index\";\n\nimport { getContext } from \"./core/Global\";\n/**\n *  The current audio context time\n */\nexport function now(): Seconds {\n\treturn getContext().now();\n}\n"],"sourceRoot":""}