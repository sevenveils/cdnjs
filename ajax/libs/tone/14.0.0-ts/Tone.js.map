{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./Tone/core/util/TypeCheck.ts","webpack:///./Tone/core/util/Defaults.ts","webpack:///./Tone/core/Global.ts","webpack:///./Tone/core/util/Timeline.ts","webpack:///./Tone/core/context/ToneWithContext.ts","webpack:///./Tone/core/Tone.ts","webpack:///./Tone/core/util/Interface.ts","webpack:///./Tone/core/type/Time.ts","webpack:///./Tone/core/context/Param.ts","webpack:///./Tone/core/util/StateTimeline.ts","webpack:///./Tone/core/context/ToneAudioNode.ts","webpack:///./Tone/core/type/TransportTime.ts","webpack:///./Tone/core/type/Frequency.ts","webpack:///./Tone/core/util/Emitter.ts","webpack:///./Tone/core/context/Context.ts","webpack:///./Tone/core/Connect.ts","webpack:///./Tone/version.ts","webpack:///./Tone/core/type/Conversions.ts","webpack:///./Tone/core/util/IntervalTimeline.ts","webpack:///./Tone/core/util/Draw.ts","webpack:///./Tone/core/type/Ticks.ts","webpack:///./Tone/core/clock/TickSignal.ts","webpack:///./Tone/core/clock/TickSource.ts","webpack:///./Tone/core/clock/Clock.ts","webpack:///./Tone/core/context/Delay.ts","webpack:///./Tone/core/context/ToneAudioBuffer.ts","webpack:///./Tone/core/context/OfflineContext.ts","webpack:///./Tone/core/type/TypeBase.ts","webpack:///./Tone/core/context/AudioContext.ts","webpack:///./Tone/core/clock/Ticker.ts","webpack:///./Tone/core/context/Gain.ts","webpack:///./Tone/core/index.ts","webpack:///./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isUndef","arg","isString","isDefined","isFunction","isNumber","isObject","toString","constructor","isBoolean","isArray","Array","isNote","test","TypeCheck_1","deepMerge","target","sources","_i","arguments","length","source","shift","key","assign","_a","_b","apply","concat","optionsFromArguments","defaults","argsArray","keys","opts","args","from","getDefaultsFromInstance","instance","getDefaults","defaultArg","given","fallback","globalContext","version_1","Context_1","setContext","context","initialize","window","TONE_CONTEXT","getContext","Context","start","resume","TONE_SILENCE_LOGGING","prefix","version","printString","console","log","Tone_1","Defaults_1","Timeline","_super","_this","_timeline","options","memory","__extends","Infinity","add","event","assert","Reflect","has","time","valueOf","index","_search","splice","diff","remove","indexOf","param","peek","getAfter","getBefore","len","cancel","after","slice","cancelBefore","previousEvent","beginning","end","midPoint","Math","floor","event_1","nextEvent","_iterate","callback","lowerBound","upperBound","forEach","forEachBefore","forEachAfter","forEachBetween","startTime","endTime","forEachFrom","forEachAtTime","dispose","Tone","Global_1","Frequency_1","Time_1","TransportTime_1","ToneWithContext","defaultContext","now","currentTime","lookAhead","immediate","sampleRate","toSeconds","TimeClass","toFrequency","freq","FrequencyClass","toTicks","TransportTimeClass","attribute","member","set","props","debug","statement","error","Error","readOnly","str","writable","noOp","_getExpressions","defaultUnit","method","capture","_now","regexp","quantize","quantTo","_secondsToUnits","transport","nextSubdivision","subdiv","percent","subdivision","round","toNotation","testNotations","power","pow","push","closest","closestSeconds","notation","notationSeconds","abs","toBarsBeatsSixteenths","quarterTime","_beatsToUnits","quarters","parseFloat","toFixed","measures","_getTimeSignature","sixteenths","sixteenthString","join","_getPPQ","toMidi","ftom","TypeBaseClass","Time","units","Conversions_1","Timeline_1","ToneWithContext_1","Param","overridden","_minOutput","AudioParam","_param","input","_events","_initialValue","convert","setValueAtTime","getValueAtTime","_fromType","cancelScheduledValues","minValue","maxValue","_is","type","val","dbToGain","min","max","_toType","gainToDb","numericValue","computedTime","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","constant","_exponentialApproach","setRampPoint","currentVal","cancelAndHoldAtTime","linearRampToValueAtTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","startingValue","segTime","valueAtTime","sampleTime","rampTo","t0","v0","v1","t","exp","t1","StateTimeline","initial","_initial","state","setStateAtTime","getLastState","getNextState","event_2","Connect_1","ToneAudioNode","numberOfInputs","numberOfOutputs","channelCount","channelCountMode","channelInterpretation","createInsOuts","createGain","output","_setChannelProperties","_internalChannels","node","_getChannelProperties","connect","destination","outputNum","inputNum","toDestination","toMaster","disconnect","chain","nodes","connectSeries","fan","AudioNode","seconds","TransportTime","defaultUnits","midi","_defaultUnits","mtof","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","parseInt","tr","q","total","transpose","interval","intervalToFrequencyRatio","harmonize","intervals","map","toNote","log2","A4","scaleIndexToNote","_noArg","_frequencyToUnits","_ticksToUnits","ticks","_getBpm","beats","frequency","cbb","cb","c#","cx","dbb","db","d#","dx","ebb","eb","e","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a#","ax","bbb","bb","b","b#","bx","Frequency","Emitter","on","split","eventName","once","boundCallback","off","eventList","emit","mixin","constr","getOwnPropertyDescriptor","undefined","Ticker_1","Emitter_1","AudioContext_1","_constants","Map","_timeouts","_timeoutIds","_initialized","_context","_latencyHint","latencyHint","_ticker","Ticker","bind","clockSource","updateInterval","_timeoutLoop","addEventListener","getAudioContext","_notifyNewContext","createAnalyser","createOscillator","createBufferSource","createBiquadFilter","createBuffer","numberOfChannels","createChannelMerger","createChannelSplitter","createConstantSource","createConvolver","createDelay","maxDelayTime","createDynamicsCompressor","createIIRFilter","feedforward","feedback","createPanner","createPeriodicWave","real","imag","constraints","createStereoPanner","createWaveShaper","decodeAudioData","audioData","listener","_transport","_destination","hint","lookAheadValue","AudioContext","Promise","resolve","close","sent","getConstant","buffer","arr","getChannelData","loop","firstEvent","setTimeout","fn","timeout","id","clearTimeout","onInit","ToneAudioNode_1","srcNode","dstNode","outputNumber","inputNumber","first","reduce","prev","current","dst","equalPowerScale","piFactor","PI","sin","gain","LN10","IntervalTimeline","_root","_length","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","results","search","results_1","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes_1","traverse","searchAfter","high","_left","_right","height","point","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","schedule","requestAnimationFrame","cancelAnimationFrame","TicksClass","Ticks","Param_1","TickSignal","_sig","offset","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","delta","k","sqrt","sol1","ticksToTime","when","timeToTicks","computedDuration","startTicks","Interface_1","StateTimeline_1","TickSignal_1","TickSource","_state","_tickOffset","setTicksAtTime","stop","pause","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","getStateAtTime","absoluteTicks","forEachTickBetween","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","nextTickTime","TickSource_1","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","ceil","Delay","maxDelay","delayTime","_delayNode","ToneAudioBuffer","onload","reverse","url","AudioBuffer","load","catch","onerror","_buffer","loaded","_reversed","_reverse","promise","downloads","audioBuffer","e_1","fromArray","array","isMultidimensional","channels","multiChannelArray","copyToChannel","toMono","chanNum","toArray","outputArray","Float32Array","numChannels_1","channel","channelArray","sample","ret","startSamples","endSamples","replacementArray","rev","fromUrl","matches","match","extensions","extension","extensions_1","ext","supportsType","replace","fetch","baseUrl","response","ok","arrayBuffer","document","createElement","canPlayType","OfflineContext","OfflineAudioContext","_currentTime","_duration","render","startRendering","_val","_units","_expressions","fromType","hz","dot","scalar","number","samples","trim","typeName","quantity","expr","matching","bpm","timeSignature","PPQ","toSamples","toMilliseconds","setAudioContext","TONE_AUDIO_CONTEXT","_callback","_type","_updateInterval","_createClock","_createWorker","blob","Blob","blobUrl","URL","createObjectURL","worker","Worker","onmessage","_worker","_createTimeout","_timeout","_disposeClock","terminate","postMessage","Gain","_gainNode","Gain_1","OfflineContext_1","ToneAudioBuffer_1","Delay_1","Clock_1","Ticks_1","Draw_1","IntervalTimeline_1","__export"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 33);\n","/**\n *  Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n *  Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n *  Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n *  Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n *  Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n *  Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n *  Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { BaseToneOptions } from \"../Tone\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T, ...sources: T[]): T {\n\tif (!sources.length) { return target; }\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (isObject(source[key])) {\n\t\t\t\tif (!target[key]) { Object.assign(target, { [key]: {} }); }\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T>(defaults: T, argsArray: IArguments, keys: string[] = []): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n","import { version } from \"../version\";\nimport { Context } from \"./context/Context\";\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context;\n\n// @ts-ignore\nglobalContext = window.TONE_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getContext(): Context {\n\tif (!globalContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setContext(context: Context): void {\n\tglobalContext = context;\n\tcontext.initialize();\n\t// @ts-ignore\n\twindow.TONE_CONTEXT = context;\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (!this.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\t// @ts-ignore\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// tslint:disable-next-line: no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n *  @class A Timeline class for scheduling and maintaining state\n *         along a timeline. All events must have a \"time\" property.\n *         Internally, events are stored in time order for fast\n *         retrieval.\n *  @param memory The number of previous events that are retained.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\tname = \"Timeline\";\n\n\t/**\n\t *  The memory of the timeline, i.e.\n\t *  how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\tconstructor(options?: Partial<TimelineOptions>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(memory?: number);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t};\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t *  @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): Timeline<GenericEvent> {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tconst index = this._search(event.time);\n\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  {Object}  event  The event object to remove from the list.\n\t *  @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): Timeline<GenericEvent> {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the nearest event whose time is less than or equal to the given time.\n\t *  @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the first event in the timeline without removing it\n\t *  @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t *  Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t *  Get the event which is scheduled after the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Get the event before the event at the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Cancel events at and after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): Timeline<GenericEvent> {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events before or equal to the given time.\n\t *  @param  {Number}  time  The time to cancel before.\n\t *  @returns {Timeline} this\n\t */\n\tcancelBefore(time): Timeline<GenericEvent> {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  {Object} event The event to find the previous one of\n\t * @return {Object}       The event right before the given event\n\t */\n\tpreviousEvent(event): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Does a binary search on the timeline array and returns the\n\t *  nearest event index whose time is after or equal to the given time.\n\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t *  If the time is after the end, the index of the last item is returned.\n\t *  @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (event[param] === time) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (testEvent[param] === time) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] < time && nextEvent[param] > time) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] > time) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t *  Internal iterator. Applies extra safety checks for\n\t *  removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t *  Iterate over everything in the array\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or before the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array after the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array between the startTime and endTime.\n\t *  The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t *  range = [startTime, endTime).\n\t *  @param  startTime The time to check if items are before\n\t *  @param  endTime The end of the test interval.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or after the given time. Similar to\n\t *  forEachAfter, but includes the item(s) at the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at the given time\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport \"../type/Units\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor\n\t */\n\treadonly defaultContext?: Context;\n\n\tconstructor(context?: Context | Partial<ToneWithContextOptions>) {\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tsuper();\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time: Time): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tGET/SET\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Get the object's attributes. Given no arguments get\n\t * will return all available object properties and their corresponding\n\t * values. Pass in a single attribute to retrieve or an array\n\t * of attributes. The attribute strings can also include a \".\"\n\t * to access deeper properties.\n\t * @param params the parameters to get, otherwise will return all available.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t * @example\n\t * osc.get(\"type\");\n\t * //returns { \"type\" : \"sine\"}\n\t * @example\n\t * //use dot notation to access deep properties\n\t * synth.get([\"envelope.attack\", \"envelope.release\"]);\n\t * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member.get();\n\t\t\t\t} else {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: Partial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tif (isDefined(this[attribute]) && isDefined(this[attribute].value)) {\n\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { Context } from \"./context/Context\";\nimport { getContext } from \"./Global\";\nimport \"./type/Units\";\n\n///////////////////////////////////////////////////////////////////////////\n// \tTONE\n///////////////////////////////////////////////////////////////////////////\n\n// tslint:disable-next-line: no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n *  @class  Tone is the base class of all other classes.\n *  @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t *  disconnect and dispose.\n\t */\n\tabstract dispose(): this;\n\n\t/**\n\t * Takes a partial options an returns the completed options by filling in the defaults\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEBUGGING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tprotected debug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @param args\n\t *  @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\t// if (this.debug || this.toString() === global.TONE_DEBUG_CLASS) {\n\t\t// \targs.unshift(this.toString() + \":\");\n\t\t// \t// eslint-disable-next-line no-console\n\t\t// \tconsole.log(...args);\n\t\t// }\n\t}\n\n\t/**\n\t *  Assert that the statement is true, otherwise invoke the error.\n\t *  @param {Boolean} statement\n\t *  @param {String} error The message which is passed into an Error\n\t *  @private\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tif (!statement) {\n\t\t\tthrow new Error(error);\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEFAULTS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  If the `given` parameter is undefined, use the `fallback`.\n\t *  If both `given` and `fallback` are object literals, it will\n\t *  return a deep copy which includes all of the parameters from both\n\t *  objects. If a parameter is undefined in given, it will return\n\t *  the fallback property.\n\t *  <br><br>\n\t *  WARNING: if object is self referential, it will go into an an\n\t *  infinite recursive loop.\n\t *  @memberOf Tone\n\t *  @param  {*} given\n\t *  @param  {*} fallback\n\t *  @return {*}\n\t */\n\t// static defaultArg(given, fallback) {\n\t\t// if (isObject(given) && isObject(fallback)) {\n\t\t// \tconst ret = {};\n\t\t// \t// make a deep copy of the given object\n\t\t// \tfor (const givenProp in given) {\n\t\t// \t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t// \t}\n\t\t// \tfor (const fallbackProp in fallback) {\n\t\t// \t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t// \t}\n\t\t// \treturn ret;\n\t\t// } else {\n\t\t// \treturn isUndef(given) ? fallback : given;\n\t\t// }\n\t// }\n\n\t// protected options(argsArray: IArguments, keys: string[]): object {\n\t// \tlet options: any = {};\n\t// \tconst args = Array.from(argsArray);\n\t// \tif (args[0] instanceof BaseAudioContext) {\n\t// \t\toptions.context = args.shift();\n\t// \t}\n\t// \tif (args.length === 1 && isObject(args[0])) {\n\t// \t\toptions = Object.assign(options, args[0]);\n\t// \t} else {\n\t// \t\tfor (let i = 0; i < keys.length; i++) {\n\t// \t\t\tif (isDefined(args[i])) {\n\t// \t\t\t\toptions[keys[i]] = args[i];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn deepMerge(this.getDefaults(), options);\n\t// }\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tSTATIC\n\t///////////////////////////////////////////////////////////////////////////\n\n\tstatic get context(): Context {\n\t\treturn getContext();\n\t}\n\n\tstatic now(): Seconds {\n\t\treturn Tone.context.now();\n\t}\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n *  Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n *  Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n","import { getContext } from \"../Global\";\nimport { FrequencyClass } from \"./Frequency\";\nimport { TypeBaseClass, TypeBaseExpression, TypeBaseUnits } from \"./TypeBase\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds> extends TypeBaseClass<Type> {\n\n\tname = \"Time\";\n\n\tprotected _getExpressions(defaultUnit): TypeBaseExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(defaultUnit), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new TimeClass(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: number | string | TimeObject, percent = 1): Type {\n\t\tconst subdivision = new TimeClass(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\t/**\n\t *  Convert a Time to Notation. The notation values are will be the\n\t *  closest representation between 1m to 128th note.\n\t *  @return {Notation}\n\t *  @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t *  Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t *  Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn FrequencyClass.ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\nexport function Time(value?: Time, units?: TypeBaseUnits): TimeClass {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions extends ToneWithContextOptions {\n\tunits: Unit;\n\tvalue?: number;\n\tparam: AudioParam;\n\tconvert: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linear\" | \"exponential\" | \"setValue\" | \"setTarget\" | \"cancel\";\n\n/**\n * The events on the automation\n */\nexport interface AutomationEvent {\n\ttype: AutomationType;\n\ttime: number;\n\tvalue: number;\n\tconstant?: number;\n}\n\n/**\n *  Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<Type extends Unit = \"number\">\nextends ToneWithContext<ParamOptions>\nimplements AbstractParam<Type> {\n\n\tname = \"Param\";\n\n\tstatic getDefaults(): ParamOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as Unit,\n\t\t} as ParamOptions);\n\t}\n\n\t/**\n\t * The input connection\n\t */\n\treadonly input: AudioParam;\n\treadonly units: Unit;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t *  The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t *  The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t *  The minimum output value\n\t */\n\tprivate _minOutput = 1e-5;\n\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) && options.param instanceof AudioParam, \"param must be an AudioParam\");\n\n\t\t// initialize\n\t\tthis._param = this.input = options.param;\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.value;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tget value(): UnitMap[Type] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: UnitMap[Type]) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\tif (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg, type: Unit): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t *  Convert the given value from the type specified by Param.units\n\t *  into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[Type]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[Type] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[Type];\n\t\t} else {\n\t\t\treturn val as UnitMap[Type];\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis._events.add({\n\t\t\ttime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setValue\", value, time);\n\t\tthis._param.setValueAtTime(numericValue, time);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[Type] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTarget\" && (after === null || after.type === \"setValue\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (isDefined(before.constant)) {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linear\" || after.type === \"exponential\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTarget\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[Type], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tendTime = this.toSeconds(endTime);\n\t\tthis._events.add({\n\t\t\ttime: endTime,\n\t\t\ttype: \"linear\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"linear\", value, endTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, endTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[Type], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tendTime = this.toSeconds(endTime);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: endTime,\n\t\t\ttype: \"exponential\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"exponential\", value, endTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, endTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[Type], time: Time, rampTime: Time): this {\n\t\tconst timeConstant = Math.log(this.toSeconds(rampTime) + 1) / Math.log(200);\n\t\ttime = this.toSeconds(time);\n\t\treturn this.setTargetAtTime(value, time, timeConstant);\n\t}\n\n\tsetTargetAtTime(value: UnitMap[Type], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(timeConstant > 0, \"timeConstant must be greater than 0\");\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: startTime,\n\t\t\ttype: \"setTarget\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setTarget\", value, startTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, startTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Array<UnitMap[Type]>, startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._events.cancel(time);\n\t\tthis._param.cancelScheduledValues(time);\n\t\tthis.log(\"cancel\", time);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(time));\n\t\tthis.log(\"cancelAndHoldAtTime\", time, \"value=\" + valueAtTime);\n\n\t\t// remove the schedule events\n\t\tthis._param.cancelScheduledValues(time);\n\n\t\t// if there is an event at the given time\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(time);\n\t\tconst after = this._events.getAfter(time);\n\t\tif (before && before.time === time) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(time + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), time);\n\t\t\t} else if (after.type === \"exponential\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), time);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, time);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[Type], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","// import \"../type/Type\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type PlaybackState = \"started\" | \"stopped\" | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\tduration?: Seconds;\n\toffset?: Seconds;\n}\n\n/**\n *  A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n *  @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline extends Timeline<StateTimelineEvent> {\n\n\t/**\n\t *  The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t *  Returns the scheduled state scheduled before or at\n\t *  the given time.\n\t *  @param  time  The time to query.\n\t *  @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a state to the timeline.\n\t *  @param  state The name of the state to set.\n\t *  @param  time  The time to query.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds): this {\n\t\t// all state changes need to be >= the previous state time\n\t\t// TODO throw error if time < the previous event time\n\t\tthis.add({\n\t\t\tstate,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the event before the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check before\n\t *  @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Return the event after the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check from\n\t *  @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { connect, connectSeries, disconnect } from \"../Connect\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport type InputNode = ToneAudioNode | AudioNode | AudioParam | Param<Unit>;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\nexport interface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport interface ToneAudioNodeOptions extends ToneWithContextOptions {\n\tnumberOfInputs: number;\n\tnumberOfOutputs: number;\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n *  ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\nextends ToneWithContext<Options> {\n\n\tabstract name = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | InputNode[] | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | OutputNode[] | undefined;\n\n\t/**\n\t *  The number of inputs feeding into the AudioNode.\n\t *  For source nodes, this will be 0.\n\t */\n\treadonly numberOfInputs: number;\n\n\t/**\n\t *  The number of outputs of the AudioNode.\n\t */\n\treadonly numberOfOutputs: number;\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected abstract _internalChannels: OutputNode[];\n\n\tstatic getDefaults(): ToneAudioNodeOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tchannelCount: 2,\n\t\t\tchannelCountMode: \"max\" as ChannelCountMode,\n\t\t\tchannelInterpretation: \"speakers\" as ChannelInterpretation,\n\t\t\tnumberOfInputs: 0,\n\t\t\tnumberOfOutputs: 0,\n\t\t});\n\t}\n\n\tconstructor(options: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(ToneAudioNode.getDefaults(), arguments, [\"context\"]));\n\n\t\tconst options = optionsFromArguments(ToneAudioNode.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis.numberOfInputs = options.numberOfInputs;\n\t\tthis.numberOfOutputs = options.numberOfInputs;\n\t}\n\n\tprotected createInsOuts(numberOfInputs: number = 0, numberOfOutputs: number = 0): void {\n\t\tif (numberOfInputs === 1) {\n\t\t\tthis.input = this.context.createGain();\n\t\t} else if (numberOfInputs > 1) {\n\t\t\tthis.input = [];\n\t\t\tfor (let i = 0; i < numberOfInputs; i++) {\n\t\t\t\tthis.input[i] = this.context.createGain();\n\t\t\t}\n\t\t}\n\n\t\tif (numberOfOutputs === 1) {\n\t\t\tthis.output = this.context.createGain();\n\t\t} else if (numberOfOutputs > 1) {\n\t\t\tthis.output = [];\n\t\t\tfor (let o = 0; o < numberOfOutputs; o++) {\n\t\t\t\tthis.output[o] = this.context.createGain();\n\t\t\t}\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// AUDIO PROPERTIES\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tif (this._internalChannels.length) {\n\t\t\tthis._internalChannels.forEach(node => {\n\t\t\t\tnode.channelCount = options.channelCount;\n\t\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tif (this._internalChannels.length) {\n\t\t\tconst node = this._internalChannels[0];\n\t\t\treturn {\n\t\t\t\tchannelCount: node.channelCount,\n\t\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t\t};\n\t\t} else {\n\t\t\t// return the defaults\n\t\t\treturn {\n\t\t\t\tchannelCount: 2,\n\t\t\t\tchannelCountMode: \"max\",\n\t\t\t\tchannelInterpretation: \"speakers\",\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t *  channelCount is the number of channels used when up-mixing and down-mixing\n\t *  connections to any inputs to the node. The default value is 2 except for\n\t *  specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount: number) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t *  channelCountMode determines how channels will be counted when up-mixing and\n\t *  down-mixing connections to any inputs to the node.\n\t *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode: ChannelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t *  channelInterpretation determines how individual channels will be treated\n\t *  when up-mixing and down-mixing connections to any inputs to the node.\n\t *  The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation: ChannelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONNECTIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t */\n\ttoMaster(): this {\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t *  disconnect the output\n\t *  @param output Either the output index to disconnect if the output is an array, or the node to disconnect from.\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Connect the output of this node to the rest of the nodes in series.\n\t *  @param nodes\n\t *  @example\n\t *  //connect a node to an effect, panVol and then to the master output\n\t *  node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  connect the output of this node to the rest of the nodes in parallel.\n\t *  @param nodes\n\t *  @returns this\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isArray(this.input)) {\n\t\t\t\tthis.input.forEach(input => {\n\t\t\t\t\tif (input instanceof ToneAudioNode) {\n\t\t\t\t\t\tinput.dispose();\n\t\t\t\t\t} else if (input instanceof AudioNode) {\n\t\t\t\t\t\tinput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this.input instanceof AudioNode) {\n\t\t\t\t\tthis.input.disconnect();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (isArray(this.output)) {\n\t\t\t\tthis.output.forEach(output => {\n\t\t\t\t\tif (output instanceof ToneAudioNode) {\n\t\t\t\t\t\toutput.dispose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\nimport { TypeBaseUnits } from \"./TypeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\tname = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\nexport function TransportTime(value: Time, units?: TypeBaseUnits): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TypeBaseExpression } from \"./TypeBase\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n */\nexport class FrequencyClass extends TimeClass<Hertz> {\n\n\tname = \"Frequency\";\n\n\treadonly defaultUnits = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic A4: Hertz = 440;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUGMENT BASE EXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tprotected _getExpressions(defaultUnit): TypeBaseExpression<Hertz> {\n\t\treturn Object.assign({}, super._getExpressions(defaultUnit), {\n\t\t\tmidi : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this._defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote : {\n\t\t\t\tregexp : /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this._defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tEXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t *  @return  A new transposed frequency\n\t *  @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t *  Takes an array of semitone intervals and returns\n\t *  an array of frequencies transposed by those intervals.\n\t *  @return  Returns an array of Frequencies\n\t *  @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t *  @return  {MIDI}\n\t *  @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn FrequencyClass.ftom(this.valueOf());\n\t}\n\n\t/**\n\t *  Return the value of the frequency in Scientific Pitch Notation\n\t *  @return  {Note}\n\t *  @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS HELPERS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  With no arguments, return 0\n\t */\n\tprotected _noArg(): Hertz {\n\t\treturn 0;\n\t}\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Hertz {\n\t\treturn freq;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Hertz {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ()));\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Hertz {\n\t\treturn 1 / super._beatsToUnits(beats);\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Hertz {\n\t\treturn 1 / seconds;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn FrequencyClass.A4 * Math.pow(2, (midi - 69) / 12);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn 69 + Math.round(12 * Math.log2(frequency / FrequencyClass.A4));\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tFREQUENCY CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Note to scale index\n *  @type  {Object}\n *  @private\n */\nconst noteToScaleIndex = {\n\t// tslint:disable-next-line\n\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n};\n\n/**\n *  scale index to note (sharps)\n *  @type  {Array}\n *  @private\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nexport function Frequency(value, units?): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\tname = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t *  Bind a callback to a specific event.\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Bind a callback which is only invoked once\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[])  => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove the event listener.\n\t *  @param  event     The event to stop listening to.\n\t *  @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                    If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Invoke all of the callbacks bound to the event\n\t *  with any arguments passed in.\n\t *  @param  event  The name of the event.\n\t *  @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Transport } from \"../clock/Transport\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isString } from \"../util/TypeCheck\";\nimport { getAudioContext } from \"./AudioContext\";\nimport { Destination } from \"./Destination\";\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"createScriptProcessor\" | \"onstatechange\" | \"addEventListener\"\n\t| \"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\";\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: BaseAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\tname = \"Context\";\n\n\t/**\n\t *  The amount of time into the future events are scheduled\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: BaseAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t *  The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t *  An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t *  All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t *  The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\tconstructor(context?: BaseAudioContext);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.addEventListener(\"statechange\", () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tinitialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tContext._notifyNewContext.forEach(cb => cb(this));\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// BASE AUDIO CONTEXT METHODS\n\t///////////////////////////////////////////////////////////////////////\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode {\n\t\treturn this._context.createIIRFilter(feedforward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t *  The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t *  There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t *  A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TICKER\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  How often the interval callback is invoked.\n\t *  This number corresponds to how responsive the scheduling\n\t *  can be. context.updateInterval + context.lookAhead gives you the\n\t *  total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t *  What the source of the clock is, either \"worker\" (default),\n\t *  \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t *  The unwrapped AudioContext.\n\t */\n\tget rawContext(): BaseAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t *  The current audio context time\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t *  Starts the audio context from a suspended state. This is required\n\t *  to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && this._context instanceof AudioContext) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t *  Promise which is invoked when the context is running.\n\t *  Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<Context> {\n\t\tif (this._context instanceof AudioContext) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TIMEOUTS\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The private loop which keeps track of the context scheduled timeouts\n\t *  Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void  {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t *  A setTimeout which is guarented by the clock source.\n\t *  Also runs in the offline context.\n\t *  @param  fn       The callback to invoke\n\t *  @param  timeout  The timeout in seconds\n\t *  @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback : fn,\n\t\t\tid : this._timeoutIds,\n\t\t\ttime : now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t *  Clears a previously scheduled timeout with Tone.context.setTimeout\n\t *  @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): Context {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// INITIALIZING NEW CONTEXT\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Array of callbacks to invoke when a new context is created\n\t */\n\tprivate static _notifyNewContext: Array<(ctx: Context) => void> = [];\n\n\t/**\n\t * Used internally to setup a new Context\n\t */\n\tstatic onInit(cb: (ctx: Context) => void): void {\n\t\tContext._notifyNewContext.push(cb);\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNode } from \"./context/ToneAudioNode\";\nimport { isArray, isDefined, isNumber } from \"./util/TypeCheck\";\n\n/**\n *  connect together all of the arguments in series\n *  @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode || prev instanceof AudioNode) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\t// resolve the input of the dstNode\n\twhile (!(dstNode instanceof AudioNode || dstNode instanceof AudioParam)) {\n\t\tif (isArray(dstNode.input)) {\n\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t} else if (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t\tinputNumber = 0;\n\t}\n\n\tif (srcNode instanceof ToneAudioNode) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\t// make the connection\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.connect(dstNode, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (isArray(dstNode.input)) {\n\t\t\t\tif (isNumber(inputNumber)) {\n\t\t\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the input number is greater than the number of inputs\");\n\t\t\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t\t\t} else {\n\t\t\t\t\t// disconnect from all of the nodes\n\t\t\t\t\t// since we don't know which one was connected\n\t\t\t\t\tdstNode.input.forEach(dst => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// catch errors from disconnecting from nodes that are not connected\n\t\t\t\t\t\t\tdisconnect(srcNode, dst, outputNumber);\n\t\t\t\t\t\t\t// tslint:disable-next-line: no-empty\n\t\t\t\t\t\t} catch (e) { }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tinputNumber = 0;\n\t\t\t} else if (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(srcNode instanceof AudioNode)) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (dstNode instanceof AudioNode) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","export const version = \"14.0.0-ts\";\n","import \"./Units\";\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n *  @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n *  Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n *  Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\tname = \"IntervalTimeline\";\n\n\t/**\n\t *  The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t *  Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t *  The event to add to the timeline. All events must\n\t *  have a time and duration value\n\t *  @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t *  @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t *  Remove events whose time time is after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Replace the references to the node in the node's parent\n\t *  with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t *  Remove the node from the tree and replace it with\n\t *  a successor which follows the schema.\n\t */\n\tprivate _removeNode(node): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t *  Rotate the tree to the left\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateLeft(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tnode.right = pivotNode.left;\n\t\tpivotNode.left = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Rotate the tree to the right\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateRight(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tnode.left = pivotNode.right;\n\t\tpivotNode.right = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get an event whose time and duration span the give time. Will\n\t *  return the match whose \"time\" value is closest to the given time.\n\t *  @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *  Iterate over everything in the timeline.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the given time\n\t *  overlaps with the time and duration time of the event.\n\t *  @param  time The time to check if items are overlapping\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the time is greater\n\t *  than or equal to the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time, callback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINTERVAL NODE HELPER\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Represents a node in the binary search tree, with the addition\n *  of a \"high\" value which keeps track of the highest value of\n *  its children.\n *  References:\n *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n *  @param low\n *  @param high\n */\n// tslint:disable-next-line: max-classes-per-file\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low, high, event) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t *  Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which overlap\n\t *  with the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which are less\n\t *  than the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Invoke the callback on this element and both it's branches\n\t *  @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t *  The balance is how the leafs are distributed on the node\n\t *  @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t *  @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t *  get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\tname = \"Draw\";\n\n\t/**\n\t *  The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t *  The amount of time before the scheduled time\n\t *  that the callback can be invoked. Default is\n\t *  half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t *  All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t *  Schedule a function at the given time to be invoked\n\t *  on the nearest animation frame.\n\t *  @param  callback  Callback is invoked at the given time.\n\t *  @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime : this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events scheduled after the given time\n\t *  @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { getContext } from \"../Global\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { TypeBaseUnits } from \"./TypeBase\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\tname = \"Ticks\";\n\n\treadonly defaultUnits: TypeBaseUnits = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t *  Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t *  Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\nexport function Ticks(value: Time, units?: TypeBaseUnits): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { connect } from \"../Connect\";\nimport { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { getContext } from \"../Global\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ninterface TickAutomationEvent extends AutomationEvent {\n\tticks: number;\n}\n\ninterface TickSignalOptions extends ParamOptions {\n\tvalue: Hertz | BPM;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n *\n * @param value The initial value of the signal\n */\nexport class TickSignal<Type extends \"hertz\" | \"bpm\"> extends Param<Type> {\n\n\tname = \"TickSignal\";\n\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\tprivate _sig: ConstantSourceNode = this.context.createConstantSource();\n\n\tprotected _param = this._sig.offset;\n\n\tprivate _multiplier: number = 1;\n\n\tconstructor(options: Partial<TickSignalOptions>);\n\tconstructor(value?: number);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._sig = this.context.createConstantSource();\n\t\tthis._sig.start(0);\n\t\tthis._param = this._sig.offset;\n\n\t\t// set the multiplier\n\t\tthis.multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis.cancelScheduledValues(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime : 0,\n\t\t\ttype : \"setValue\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickSignalOptions {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tparam: getContext().createConstantSource().offset,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[Type], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks : 0,\n\t\t\t\ttime : 0,\n\t\t\t\ttype: \"setValue\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValue\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linear\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[Type]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\tprotected _toType(val: number): UnitMap[Type] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multipler\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n\n\t/**\n\t * Connect the output signal\n\t */\n\tconnect(dstNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnect(this._sig, dstNode, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n *  Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n *\n *  @param frequency The initial frequency that the signal ticks at\n */\nexport class TickSource<Type extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\tname = \"TickSource\";\n\n\t/**\n\t *  The frequency the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t *  The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\tconstructor(frequency?: Frequency);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: this.toFrequency(options.frequency),\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}, ToneWithContext.getDefaults()) as TickSourceOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t *  @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the TickSource has been running. Accounts\n\t *  for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state : \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds : this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Returns the scheduled state at the given time.\n\t *  @param  time  The time to query.\n\t *  @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t *  Invoke the callback event at all scheduled ticks between the\n\t *  start time and the end time\n\t *  @param  startTime  The beginning of the search range\n\t *  @param  endTime    The end of the search range\n\t *  @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter, EmitterEventObject } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n *\n * @param callback The callback to be invoked with the time of the audio event\n * @param frequency The rate of the callback\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n */\nexport class Clock<Type extends \"bpm\" | \"hertz\" = \"hertz\">\nextends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\tname = \"Clock\";\n\n\t/**\n\t *  The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t *  The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t *  The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t *  Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t *  The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\tthis.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t *  @param time The time when the clock should stop.\n\t *  @returns {Clock} this\n\t *  @example\n\t * clock.stop();\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t *  The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: number;\n\tmaxDelay: number;\n}\n\n/**\n *  Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n *  @param delayTime The delay applied to the incoming signal.\n *  @param maxDelay The maximum delay time.\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t *  The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * The internal channels for channel routing changes\n\t */\n\tprotected _internalChannels: AudioNode[];\n\n\tconstructor(options?: Partial<DelayOptions>)\n\tconstructor(delayTime?: Time, maxDelay?: Time)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tthis.maxDelay = Math.max(this.toSeconds(options.maxDelay), this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(options.maxDelay);\n\t\tthis._internalChannels = [this._delayNode];\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._delayNode.delayTime,\n\t\t\tunits : \"time\",\n\t\t\tvalue : options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime : 0,\n\t\t\tmaxDelay: 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n *\n * @param url The url to load, or the audio buffer to set.\n * @param onload A callback which is invoked after the buffer is loaded.\n *                            It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n *                            since it will give you a callback when _all_ buffers are loaded.\n * @param onerror The callback to invoke if there is an error\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n */\nexport class ToneAudioBuffer extends Tone {\n\n\tname = \"ToneAudioBuffer\";\n\n\t/**\n\t *  stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t *  indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && options.url instanceof AudioBuffer || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t *  Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * \tInvokes the callback once the audio buffer loads.\n\t *  @param url The url of the buffer to load. filetype support depends on the browser.\n\t *  @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tSums multiple channels into 1 channel\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t *  @param  channel  The channel number to return\n\t *  @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t *  Cut a subsection of the array and return a buffer of the\n\t *  subsection. Does not modify the original buffer\n\t *  @param start The time to start the slice\n\t *  @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.length): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tconst replacementArray: Float32Array[] = [];\n\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\treplacementArray[i] = this.toArray(i).slice(startSamples, endSamples) as Float32Array;\n\t\t}\n\t\tconst retBuffer = new ToneAudioBuffer().fromArray(replacementArray);\n\t\treturn retBuffer;\n\t}\n\n\t/**\n\t *  Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tArray.prototype.reverse.call(this.getChannelData(i));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// STATIC METHODS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t *  Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t *  pass in a multidimensional array.\n\t *  @param array The array to fill the audio buffer\n\t *  @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t *  Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t *  Checks a url's extension to see if the current browser can play that file type.\n\t *  @param url The url/extension to test\n\t *  @return If the file extension can be played\n\t *  @static\n\t *  @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","import { Context } from \"../context/Context\";\n\n/**\n *  Wrapper around the OfflineAudioContext\n *  @param  channels  The number of channels to render\n *  @param  duration  The duration to render in samples\n *  @param sampleRate the sample rate to render at\n */\nexport class OfflineContext extends Context {\n\n\tname = \"OfflineContext\";\n\n\t/**\n\t *  A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t *  An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\tconstructor(channels: number | OfflineAudioContext, duration: Seconds, sampleRate: number) {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: channels instanceof OfflineAudioContext ?\n\t\t\t\tchannels : new OfflineAudioContext(channels, duration * sampleRate, sampleRate),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: channels instanceof OfflineAudioContext ?\n\t\t\t\t\t128 / channels.sampleRate : 128 / sampleRate,\n\t\t});\n\n\t\tthis._duration = channels instanceof OfflineAudioContext ?\n\t\t\tchannels.length / channels.sampleRate : duration;\n\t}\n\n\t/**\n\t *  Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t *  Render the output of the OfflineContext\n\t */\n\trender(): Promise<AudioBuffer> {\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t// increment the clock in 5ms chunks\n\t\t\tthis._currentTime += 0.005;\n\t\t}\n\n\t\treturn this._context.startRendering();\n\t}\n\n\t/**\n\t *  Close the context\n\t */\n\tclose(): Promise<OfflineContext> {\n\t\treturn Promise.resolve(this);\n\t}\n}\n","import { Tone } from \"../../core/Tone\";\nimport { Context } from \"../context/Context\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { isDefined, isObject , isString, isUndef } from \"../util/TypeCheck\";\n\ninterface TypeBaseClassOptions extends ToneWithContextOptions {\n\tvalue?: TypeBaseClassValue;\n\tunits?: TypeBaseUnits;\n}\n\ntype TypeBaseClassValue = string | number | TimeObject | TypeBaseClass<any>;\n\n/**\n * TypeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @param  val    The time value as a number, string or object\n * @param  units  Unit values\n * @example\n * new TypeBase(4, \"n\")\n * new TypeBase(2, \"t\")\n * new TypeBase(\"2t\")\n * new TypeBase({\"2t\" : 2})\n * new TypeBase(\"2t\") + new TypeBase(\"4n\");\n */\nexport abstract class TypeBaseClass<Type extends Seconds | Hertz | Ticks> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TypeBaseClassValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: TypeBaseUnits;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TypeBaseExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: TypeBaseUnits = \"s\";\n\n\tconstructor(context: Context, value?: TypeBaseClassValue, units?: TypeBaseUnits) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\n\t\tthis._expressions = this._getExpressions(this.defaultUnits);\n\n\t\tif (value instanceof TypeBaseClass) {\n\t\t\tthis.fromType(value);\n\t\t}\n\t}\n\n\tstatic getDefaults(): TypeBaseClassOptions {\n\t\treturn ToneWithContext.getDefaults();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(defaultUnit: TypeBaseUnits): TypeBaseExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[defaultUnit].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tVALUE OF\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as TypeBaseUnits;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t *  @private\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t *  With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tTEMPO CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tCONVERSION INTERFACE\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TypeBaseClass<any>): void {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t *  Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t *  Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t *  Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t *  Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\treturn this;\n\t}\n}\n/**\n * The units that the TypeBase can accept. extended by other classes\n */\nexport type TypeBaseUnits = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\n/**\n * The format of the type conversion expressions\n */\nexport type TypeBaseExpression<T> = {\n\t[key in TypeBaseUnits]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => T;\n\t};\n};\n","/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseAudioContext;\n\n// @ts-ignore\nglobalContext = window.TONE_AUDIO_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): BaseAudioContext {\n\tif (!globalContext) {\n\t\tsetAudioContext(new AudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: BaseAudioContext): void {\n\tglobalContext = context;\n\t// @ts-ignore\n\twindow.TONE_AUDIO_CONTEXT = globalContext;\n}\n","\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t *  Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t// the initial timeout time\n\t\t\t`var timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();`,\n\t\t]);\n\t\tconst blobUrl = window.URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = window.setTimeout(()  => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: Unit;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @param  gain The initial gain of the GainNode\n * @param units The units of the gain parameter.\n */\nexport class Gain<Type extends Unit = \"gain\"> extends ToneAudioNode<GainOptions> {\n\n\treadonly name = \"Gain\";\n\n\t/**\n\t *  The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * Add all of the gain nodes\n\t */\n\tprotected _internalChannels: AudioNode[] = [this._gainNode];\n\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext : this.context,\n\t\t\tconvert : options.convert,\n\t\t\tparam : this._gainNode.gain,\n\t\t\tunits : options.units,\n\t\t\tvalue : options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert : true,\n\t\t\tgain : 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits : \"gain\" as Unit,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","export { Gain } from \"./context/Gain\";\nexport { Context } from \"./context/Context\";\nexport { OfflineContext } from \"./context/OfflineContext\";\nexport { Param } from \"./context/Param\";\nexport { ToneAudioBuffer } from \"./context/ToneAudioBuffer\";\nexport { Delay } from \"./context/Delay\";\nexport { Clock } from \"./clock/Clock\";\nexport { Frequency, FrequencyClass } from \"./type/Frequency\";\nexport { Time, TimeClass } from \"./type/Time\";\nexport { Ticks, TicksClass } from \"./type/Ticks\";\nexport { TransportTime, TransportTimeClass } from \"./type/TransportTime\";\nexport { Draw } from \"./util/Draw\";\nexport { StateTimeline } from \"./util/StateTimeline\";\nexport { IntervalTimeline } from \"./util/IntervalTimeline\";\nexport { Timeline } from \"./util/Timeline\";\nexport { Emitter } from \"./util/Emitter\";\n","export * from \"./core/index\";\n"],"sourceRoot":""}