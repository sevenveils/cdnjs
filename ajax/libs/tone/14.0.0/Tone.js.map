{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./Tone/core/util/Defaults.ts","webpack:///./Tone/core/util/TypeCheck.ts","webpack:///./Tone/core/util/Interface.ts","webpack:///./Tone/core/context/ToneAudioNode.ts","webpack:///./Tone/core/Global.ts","webpack:///./Tone/core/util/Timeline.ts","webpack:///./Tone/core/Tone.ts","webpack:///./Tone/core/context/Param.ts","webpack:///./Tone/core/context/ToneWithContext.ts","webpack:///./Tone/core/type/Time.ts","webpack:///./Tone/core/context/Gain.ts","webpack:///./Tone/core/Connect.ts","webpack:///./Tone/core/util/StateTimeline.ts","webpack:///./Tone/core/type/TransportTime.ts","webpack:///./Tone/core/util/Emitter.ts","webpack:///./Tone/core/type/Conversions.ts","webpack:///./Tone/core/type/Ticks.ts","webpack:///./Tone/core/context/ToneAudioBuffer.ts","webpack:///./Tone/core/context/ContextInitialization.ts","webpack:///./Tone/core/context/Context.ts","webpack:///./Tone/source/oscillator/OscillatorNode.ts","webpack:///./Tone/source/OneShotSource.ts","webpack:///./Tone/source/buffer/BufferSource.ts","webpack:///./Tone/source/Source.ts","webpack:///./Tone/core/clock/TransportEvent.ts","webpack:///./Tone/component/channel/Volume.ts","webpack:///./Tone/core/util/IntervalTimeline.ts","webpack:///./Tone/core/clock/Clock.ts","webpack:///./Tone/core/type/Frequency.ts","webpack:///./Tone/version.ts","webpack:///./Tone/signal/Signal.ts","webpack:///./Tone/source/oscillator/Oscillator.ts","webpack:///./Tone/source/Noise.ts","webpack:///./Tone/source/index.ts","webpack:///./Tone/core/clock/TransportRepeatEvent.ts","webpack:///./Tone/core/clock/Transport.ts","webpack:///./Tone/core/context/Destination.ts","webpack:///./Tone/core/util/Draw.ts","webpack:///./Tone/core/clock/TickSignal.ts","webpack:///./Tone/core/clock/TickSource.ts","webpack:///./Tone/core/context/Delay.ts","webpack:///./Tone/core/context/OfflineContext.ts","webpack:///./Tone/core/type/TypeBase.ts","webpack:///./Tone/core/context/AudioContext.ts","webpack:///./Tone/core/clock/Ticker.ts","webpack:///./Tone/core/index.ts","webpack:///./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","a","i","self","this","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","TypeCheck_1","deepMerge","target","sources","_i","arguments","length","source","shift","isObject","key","assign","_a","_b","apply","concat","optionsFromArguments","defaults","argsArray","keys","opts","args","Array","from","isDefined","getDefaultsFromInstance","instance","constructor","getDefaults","defaultArg","given","fallback","isUndef","arg","isString","isFunction","isNumber","toString","isBoolean","isArray","isNote","test","readOnly","forEach","str","writable","noOp","Defaults_1","ToneWithContext_1","ToneAudioNode","_super","_this","options","numberOfInputs","numberOfOutputs","__extends","ToneWithContext","channelCount","channelCountMode","channelInterpretation","createInsOuts","input","context","createGain","output","_setChannelProperties","_internalChannels","node","_getChannelProperties","props","connect","destination","outputNum","inputNum","toDestination","toMaster","disconnect","chain","nodes","connectSeries","fan","dispose","AudioNode","first","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber","AudioParam","assert","dst","e","globalContext","version_1","Context_1","setContext","initialize","window","TONE_CONTEXT","getContext","Context","start","resume","TONE_SILENCE_LOGGING","prefix","version","printString","console","log","Tone_1","Timeline","_timeline","memory","Infinity","add","event","Reflect","has","time","valueOf","index","_search","splice","diff","remove","indexOf","param","peek","getAfter","getBefore","len","cancel","after","slice","cancelBefore","previousEvent","beginning","end","midPoint","Math","floor","event_1","nextEvent","_iterate","callback","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","startTime","endTime","forEachFrom","forEachAtTime","Tone","debug","statement","error","Error","Conversions_1","Timeline_1","Param","overridden","_minOutput","_param","_events","_initialValue","units","convert","setValueAtTime","now","getValueAtTime","_fromType","cancelScheduledValues","minValue","maxValue","_is","type","val","toSeconds","dbToGain","toFrequency","min","max","_toType","gainToDb","numericValue","computedTime","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","constant","_exponentialApproach","setRampPoint","currentVal","cancelAndHoldAtTime","linearRampToValueAtTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","startingValue","segTime","valueAtTime","sampleTime","rampTo","t0","v0","v1","t","exp","t1","pow","Global_1","Frequency_1","Time_1","TransportTime_1","defaultContext","currentTime","lookAhead","immediate","sampleRate","TimeClass","freq","FrequencyClass","toTicks","TransportTimeClass","attribute","member","set","_getExpressions","defaultUnit","method","capture","_now","regexp","quantize","quantTo","_secondsToUnits","transport","nextSubdivision","subdiv","percent","subdivision","round","toNotation","testNotations","power","push","closest","closestSeconds","notation","notationSeconds","abs","toBarsBeatsSixteenths","quarterTime","_beatsToUnits","quarters","parseFloat","toFixed","measures","_getTimeSignature","sixteenths","sixteenthString","join","_getPPQ","toMidi","ftom","TypeBaseClass","Time","Param_1","Interface_1","ToneAudioNode_1","Gain","_gainNode","gain","StateTimeline","initial","_initial","state","setStateAtTime","getLastState","getNextState","event_2","seconds","TransportTime","Emitter","on","split","eventName","once","boundCallback","off","eventList","emit","mixin","constr","getOwnPropertyDescriptor","undefined","equalPowerScale","piFactor","PI","sin","db","LN10","intervalToFrequencyRatio","interval","A4","getA4","setA4","frequency","log2","TicksClass","defaultUnits","ticks","beats","_getBpm","_ticksToUnits","Ticks","ToneAudioBuffer","onload","reverse","url","AudioBuffer","load","catch","onerror","_buffer","buffer","loaded","_reversed","_reverse","promise","downloads","audioBuffer","sent","e_1","fromArray","array","isMultidimensional","channels","createBuffer","multiChannelArray","copyToChannel","toMono","chanNum","toArray","outputArray","Float32Array","numChannels_1","numberOfChannels","channel","channelArray","map","sample","getChannelData","ret","startSamples","endSamples","replacementArray","rev","fromUrl","matches","match","extensions","extension","extensions_1","ext","supportsType","replace","fetch","baseUrl","response","ok","arrayBuffer","decodeAudioData","document","createElement","canPlayType","notifyNewContext","onContextInit","cb","initializeContext","ctx","Ticker_1","Emitter_1","AudioContext_1","ContextInitialization_1","_constants","Map","_timeouts","_timeoutIds","_initialized","_context","_latencyHint","latencyHint","_ticker","Ticker","bind","clockSource","updateInterval","_timeoutLoop","addEventListener","getAudioContext","createAnalyser","createOscillator","createBufferSource","createBiquadFilter","createChannelMerger","createChannelSplitter","createConstantSource","createConvolver","createDelay","maxDelayTime","createDynamicsCompressor","createIIRFilter","feedforward","feedback","createPanner","createPeriodicWave","real","imag","constraints","createStereoPanner","createWaveShaper","audioData","listener","_transport","_destination","hint","lookAheadValue","AudioContext","Promise","resolve","close","getConstant","arr","loop","firstEvent","setTimeout","fn","timeout","id","clearTimeout","Connect_1","OneShotSource_1","ToneOscillatorNode","_oscillator","detune","OneShotSource","_startGain","_stopSource","stop","setPeriodicWave","periodicWave","Gain_1","onended","_startTime","_stopTime","_timeout","_fadeIn","_fadeOut","_curve","getStateAtTime","fadeInTime","_stopGain","cancelStop","fadeOutTime","ToneAudioBuffer_1","ToneBufferSource","_source","_sourceStarted","_sourceStopped","playbackRate","loopStart","loopEnd","curve","fadeIn","fadeOut","offset","computedDur","additionalTail","Volume_1","StateTimeline_1","Source","Volume","_volume","volume","_state","_synced","_scheduled","_syncedStart","_syncedStop","mute","restart","sched","schedule","_start","_stop","sync","stateEvent","startOffset","getSecondsAtTime","unsync","clear","TransportEvent","_eventId","_once","invoke","_unmutedVolume","IntervalTimeline","_root","_length","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","results","search","results_1","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes_1","traverse","searchAfter","high","_left","_right","height","point","TickSource_1","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","TickSource","pause","ceil","getTicksAtTime","setTicksAtTime","nextTickTime","when","currentTick","getTimeOfTick","forEachTickBetween","Conversions_2","midi","_defaultUnits","mtof","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","parseInt","tr","q","total","transpose","harmonize","intervals","toNote","scaleIndexToNote","_noArg","_frequencyToUnits","cbb","c#","cx","dbb","d#","dx","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a#","ax","bbb","bb","b","b#","bx","Frequency","Signal","_constantSource","Signal_1","Source_1","OscillatorNode_1","Oscillator","_partials","partials","_partialCount","partialCount","_phase","phase","_type","baseType","oscillator","_wave","syncFrequency","syncSignal","unsyncFrequency","unsyncSignal","isBasicType","_getRealImaginary","partial","exec","periodicWaveSize","fftSize","TypeError","cos","_inverseFFT","sum","_getInitialValue","twoPi","BufferSource_1","Noise","_playbackRate","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","Noise_1","Oscillator_1","Ticks_1","TransportEvent_1","TransportRepeatEvent","_currentId","_nextId","_nextTick","_boundRestart","_restart","_interval","_createEvents","scheduleOnce","IntervalTimeline_1","Clock_1","TransportRepeatEvent_1","Transport","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","bpm","multiplier","_timeSignature","timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","timeToTicks","remainingTicks","signal","ratio","computedFreq","PPQ","ratioSignal","syncedSignal","Destination","rawContext","unshift","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","TickSignal","_sig","_multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getDurationOfTicks","tick","delta","k","sqrt","sol1","ticksToTime","computedDuration","startTicks","TickSignal_1","_tickOffset","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","elapsedSeconds","absoluteTicks","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","Delay","maxDelay","delayTime","_delayNode","OfflineContext","OfflineAudioContext","_currentTime","_duration","render","startRendering","_val","_units","_expressions","fromType","hz","dot","scalar","number","samples","trim","typeName","quantity","expr","matching","toSamples","toMilliseconds","setAudioContext","TONE_AUDIO_CONTEXT","_callback","_updateInterval","_createClock","_createWorker","blob","Blob","blobUrl","URL","createObjectURL","worker","Worker","onmessage","_worker","_createTimeout","_disposeClock","terminate","postMessage","OfflineContext_1","Delay_1","Draw_1","Destination_1","Transport_1","__export"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 47);\n","// import { BaseToneOptions } from \"../Tone\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T, ...sources: T[]): T {\n\tif (!sources.length) { return target; }\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (isObject(source[key])) {\n\t\t\t\tif (!target[key]) { Object.assign(target, { [key]: {} }); }\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T>(defaults: T, argsArray: IArguments, keys: string[] = []): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n","/**\n *  Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n *  Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n *  Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n *  Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n *  Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n *  Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n *  Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n *  Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n *  Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n","import { optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isDefined, isNumber } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport type InputNode = ToneAudioNode | AudioNode | AudioParam | Param<Unit>;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\nexport interface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport interface ToneAudioNodeOptions extends ToneWithContextOptions {\n\tnumberOfInputs: number;\n\tnumberOfOutputs: number;\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n *  ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\nextends ToneWithContext<Options> {\n\n\tabstract name = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | InputNode[] | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | OutputNode[] | undefined;\n\n\t/**\n\t *  The number of inputs feeding into the AudioNode.\n\t *  For source nodes, this will be 0.\n\t */\n\treadonly numberOfInputs: number;\n\n\t/**\n\t *  The number of outputs of the AudioNode.\n\t */\n\treadonly numberOfOutputs: number;\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected abstract _internalChannels: OutputNode[];\n\n\tstatic getDefaults(): ToneAudioNodeOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tchannelCount: 2,\n\t\t\tchannelCountMode: \"max\" as ChannelCountMode,\n\t\t\tchannelInterpretation: \"speakers\" as ChannelInterpretation,\n\t\t\tnumberOfInputs: 0,\n\t\t\tnumberOfOutputs: 0,\n\t\t});\n\t}\n\n\tconstructor(options: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(ToneAudioNode.getDefaults(), arguments, [\"context\"]));\n\n\t\tconst options = optionsFromArguments(ToneAudioNode.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis.numberOfInputs = options.numberOfInputs;\n\t\tthis.numberOfOutputs = options.numberOfInputs;\n\t}\n\n\tprotected createInsOuts(numberOfInputs: number = 0, numberOfOutputs: number = 0): void {\n\t\tif (numberOfInputs === 1) {\n\t\t\tthis.input = this.context.createGain();\n\t\t} else if (numberOfInputs > 1) {\n\t\t\tthis.input = [];\n\t\t\tfor (let i = 0; i < numberOfInputs; i++) {\n\t\t\t\tthis.input[i] = this.context.createGain();\n\t\t\t}\n\t\t}\n\n\t\tif (numberOfOutputs === 1) {\n\t\t\tthis.output = this.context.createGain();\n\t\t} else if (numberOfOutputs > 1) {\n\t\t\tthis.output = [];\n\t\t\tfor (let o = 0; o < numberOfOutputs; o++) {\n\t\t\t\tthis.output[o] = this.context.createGain();\n\t\t\t}\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// AUDIO PROPERTIES\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tif (this._internalChannels.length) {\n\t\t\tthis._internalChannels.forEach(node => {\n\t\t\t\tnode.channelCount = options.channelCount;\n\t\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tif (this._internalChannels.length) {\n\t\t\tconst node = this._internalChannels[0];\n\t\t\treturn {\n\t\t\t\tchannelCount: node.channelCount,\n\t\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t\t};\n\t\t} else {\n\t\t\t// return the defaults\n\t\t\treturn {\n\t\t\t\tchannelCount: 2,\n\t\t\t\tchannelCountMode: \"max\",\n\t\t\t\tchannelInterpretation: \"speakers\",\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t *  channelCount is the number of channels used when up-mixing and down-mixing\n\t *  connections to any inputs to the node. The default value is 2 except for\n\t *  specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount: number) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t *  channelCountMode determines how channels will be counted when up-mixing and\n\t *  down-mixing connections to any inputs to the node.\n\t *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode: ChannelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t *  channelInterpretation determines how individual channels will be treated\n\t *  when up-mixing and down-mixing connections to any inputs to the node.\n\t *  The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation: ChannelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONNECTIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t */\n\ttoMaster(): this {\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t *  disconnect the output\n\t *  @param output Either the output index to disconnect if the output is an array, or the node to disconnect from.\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Connect the output of this node to the rest of the nodes in series.\n\t *  @param nodes\n\t *  @example\n\t *  //connect a node to an effect, panVol and then to the master output\n\t *  node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  connect the output of this node to the rest of the nodes in parallel.\n\t *  @param nodes\n\t *  @returns this\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isArray(this.input)) {\n\t\t\t\tthis.input.forEach(input => {\n\t\t\t\t\tif (input instanceof ToneAudioNode) {\n\t\t\t\t\t\tinput.dispose();\n\t\t\t\t\t} else if (input instanceof AudioNode) {\n\t\t\t\t\t\tinput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this.input instanceof AudioNode) {\n\t\t\t\t\tthis.input.disconnect();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (isArray(this.output)) {\n\t\t\t\tthis.output.forEach(output => {\n\t\t\t\t\tif (output instanceof ToneAudioNode) {\n\t\t\t\t\t\toutput.dispose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.disconnect();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONNECTIONS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n *  connect together all of the arguments in series\n *  @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode || prev instanceof AudioNode) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\t// resolve the input of the dstNode\n\twhile (!(dstNode instanceof AudioNode || dstNode instanceof AudioParam)) {\n\t\tif (isArray(dstNode.input)) {\n\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t} else if (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t\tinputNumber = 0;\n\t}\n\n\tif (srcNode instanceof ToneAudioNode) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\t// make the connection\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.connect(dstNode, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (isArray(dstNode.input)) {\n\t\t\t\tif (isNumber(inputNumber)) {\n\t\t\t\t\tthis.assert(dstNode.input.length < inputNumber, \"the input number is greater than the number of inputs\");\n\t\t\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t\t\t} else {\n\t\t\t\t\t// disconnect from all of the nodes\n\t\t\t\t\t// since we don't know which one was connected\n\t\t\t\t\tdstNode.input.forEach(dst => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// catch errors from disconnecting from nodes that are not connected\n\t\t\t\t\t\t\tdisconnect(srcNode, dst, outputNumber);\n\t\t\t\t\t\t\t// tslint:disable-next-line: no-empty\n\t\t\t\t\t\t} catch (e) { }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tinputNumber = 0;\n\t\t\t} else if (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(srcNode instanceof AudioNode)) {\n\t\tif (isArray(srcNode.output)) {\n\t\t\tthis.assert(srcNode.output.length < outputNumber, \"the output number is greater than the number of outputs\");\n\t\t\tsrcNode = srcNode.output[outputNumber];\n\t\t} else if (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t\toutputNumber = 0;\n\t}\n\n\tif (dstNode instanceof AudioParam) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (dstNode instanceof AudioNode) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { version } from \"../version\";\nimport { Context } from \"./context/Context\";\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context;\n\n// @ts-ignore\nglobalContext = window.TONE_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getContext(): Context {\n\tif (!globalContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setContext(context: Context): void {\n\tglobalContext = context;\n\tcontext.initialize();\n\t// @ts-ignore\n\twindow.TONE_CONTEXT = context;\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (!this.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\t// @ts-ignore\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// tslint:disable-next-line: no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n *  @class A Timeline class for scheduling and maintaining state\n *         along a timeline. All events must have a \"time\" property.\n *         Internally, events are stored in time order for fast\n *         retrieval.\n *  @param memory The number of previous events that are retained.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\tname = \"Timeline\";\n\n\t/**\n\t *  The memory of the timeline, i.e.\n\t *  how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\tconstructor(options?: Partial<TimelineOptions>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(memory?: number);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t};\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t *  @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): Timeline<GenericEvent> {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tconst index = this._search(event.time);\n\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  {Object}  event  The event object to remove from the list.\n\t *  @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): Timeline<GenericEvent> {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the nearest event whose time is less than or equal to the given time.\n\t *  @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the first event in the timeline without removing it\n\t *  @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t *  Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t *  Get the event which is scheduled after the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Get the event before the event at the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Cancel events at and after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): Timeline<GenericEvent> {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events before or equal to the given time.\n\t *  @param  {Number}  time  The time to cancel before.\n\t *  @returns {Timeline} this\n\t */\n\tcancelBefore(time): Timeline<GenericEvent> {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  {Object} event The event to find the previous one of\n\t * @return {Object}       The event right before the given event\n\t */\n\tpreviousEvent(event): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Does a binary search on the timeline array and returns the\n\t *  nearest event index whose time is after or equal to the given time.\n\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t *  If the time is after the end, the index of the last item is returned.\n\t *  @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (event[param] === time) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (testEvent[param] === time) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] < time && nextEvent[param] > time) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] > time) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t *  Internal iterator. Applies extra safety checks for\n\t *  removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t *  Iterate over everything in the array\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or before the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array after the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array between the startTime and endTime.\n\t *  The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t *  range = [startTime, endTime).\n\t *  @param  startTime The time to check if items are before\n\t *  @param  endTime The end of the test interval.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or after the given time. Similar to\n\t *  forEachAfter, but includes the item(s) at the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at the given time\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\n// import { getContext } from \"./Global\";\nimport \"./type/Units\";\n\n///////////////////////////////////////////////////////////////////////////\n// \tTONE\n///////////////////////////////////////////////////////////////////////////\n\n// tslint:disable-next-line: no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n *  @class  Tone is the base class of all other classes.\n *  @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t *  disconnect and dispose.\n\t */\n\tabstract dispose(): this;\n\n\t/**\n\t * Takes a partial options an returns the completed options by filling in the defaults\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEBUGGING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tprotected debug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @param args\n\t *  @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\t// if (this.debug || this.toString() === global.TONE_DEBUG_CLASS) {\n\t\t// \targs.unshift(this.toString() + \":\");\n\t\t// \t// eslint-disable-next-line no-console\n\t\t// \tconsole.log(...args);\n\t\t// }\n\t}\n\n\t/**\n\t *  Assert that the statement is true, otherwise invoke the error.\n\t *  @param {Boolean} statement\n\t *  @param {String} error The message which is passed into an Error\n\t *  @private\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tif (!statement) {\n\t\t\tthrow new Error(error);\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEFAULTS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  If the `given` parameter is undefined, use the `fallback`.\n\t *  If both `given` and `fallback` are object literals, it will\n\t *  return a deep copy which includes all of the parameters from both\n\t *  objects. If a parameter is undefined in given, it will return\n\t *  the fallback property.\n\t *  <br><br>\n\t *  WARNING: if object is self referential, it will go into an an\n\t *  infinite recursive loop.\n\t *  @memberOf Tone\n\t *  @param  {*} given\n\t *  @param  {*} fallback\n\t *  @return {*}\n\t */\n\t// static defaultArg(given, fallback) {\n\t\t// if (isObject(given) && isObject(fallback)) {\n\t\t// \tconst ret = {};\n\t\t// \t// make a deep copy of the given object\n\t\t// \tfor (const givenProp in given) {\n\t\t// \t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t// \t}\n\t\t// \tfor (const fallbackProp in fallback) {\n\t\t// \t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t// \t}\n\t\t// \treturn ret;\n\t\t// } else {\n\t\t// \treturn isUndef(given) ? fallback : given;\n\t\t// }\n\t// }\n\n\t// protected options(argsArray: IArguments, keys: string[]): object {\n\t// \tlet options: any = {};\n\t// \tconst args = Array.from(argsArray);\n\t// \tif (args[0] instanceof BaseAudioContext) {\n\t// \t\toptions.context = args.shift();\n\t// \t}\n\t// \tif (args.length === 1 && isObject(args[0])) {\n\t// \t\toptions = Object.assign(options, args[0]);\n\t// \t} else {\n\t// \t\tfor (let i = 0; i < keys.length; i++) {\n\t// \t\t\tif (isDefined(args[i])) {\n\t// \t\t\t\toptions[keys[i]] = args[i];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn deepMerge(this.getDefaults(), options);\n\t// }\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tSTATIC\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// static get context(): import(\"./context/Context\").Context {\n\t// \treturn getContext();\n\t// }\n\n\t// static now(): Seconds {\n\t// \treturn Tone.context.now();\n\t// }\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions extends ToneWithContextOptions {\n\tunits: Unit;\n\tvalue?: number;\n\tparam: AudioParam;\n\tconvert: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linear\" | \"exponential\" | \"setValue\" | \"setTarget\" | \"cancel\";\n\n/**\n * The events on the automation\n */\nexport interface AutomationEvent {\n\ttype: AutomationType;\n\ttime: number;\n\tvalue: number;\n\tconstant?: number;\n}\n\n/**\n *  Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<Type extends Unit = \"number\">\nextends ToneWithContext<ParamOptions>\nimplements AbstractParam<Type> {\n\n\tname = \"Param\";\n\n\tstatic getDefaults(): ParamOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as Unit,\n\t\t} as ParamOptions);\n\t}\n\n\t/**\n\t * The input connection\n\t */\n\treadonly input: AudioParam;\n\treadonly units: Unit;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t *  The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t *  The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t *  The minimum output value\n\t */\n\tprivate _minOutput = 1e-5;\n\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) && options.param instanceof AudioParam, \"param must be an AudioParam\");\n\n\t\t// initialize\n\t\tthis._param = this.input = options.param;\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.value;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tget value(): UnitMap[Type] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: UnitMap[Type]) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\tif (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg, type: Unit): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t *  Convert the given value from the type specified by Param.units\n\t *  into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[Type]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[Type] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[Type];\n\t\t} else {\n\t\t\treturn val as UnitMap[Type];\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis._events.add({\n\t\t\ttime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setValue\", value, time);\n\t\tthis._param.setValueAtTime(numericValue, time);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[Type] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTarget\" && (after === null || after.type === \"setValue\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (isDefined(before.constant)) {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linear\" || after.type === \"exponential\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTarget\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[Type], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tendTime = this.toSeconds(endTime);\n\t\tthis._events.add({\n\t\t\ttime: endTime,\n\t\t\ttype: \"linear\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"linear\", value, endTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, endTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[Type], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tendTime = this.toSeconds(endTime);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: endTime,\n\t\t\ttype: \"exponential\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(\"exponential\", value, endTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, endTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[Type], time: Time, rampTime: Time): this {\n\t\tconst timeConstant = Math.log(this.toSeconds(rampTime) + 1) / Math.log(200);\n\t\ttime = this.toSeconds(time);\n\t\treturn this.setTargetAtTime(value, time, timeConstant);\n\t}\n\n\tsetTargetAtTime(value: UnitMap[Type], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(timeConstant > 0, \"timeConstant must be greater than 0\");\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: startTime,\n\t\t\ttype: \"setTarget\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\"setTarget\", value, startTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, startTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Array<UnitMap[Type]>, startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._events.cancel(time);\n\t\tthis._param.cancelScheduledValues(time);\n\t\tthis.log(\"cancel\", time);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(time));\n\t\tthis.log(\"cancelAndHoldAtTime\", time, \"value=\" + valueAtTime);\n\n\t\t// remove the schedule events\n\t\tthis._param.cancelScheduledValues(time);\n\n\t\t// if there is an event at the given time\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(time);\n\t\tconst after = this._events.getAfter(time);\n\t\tif (before && before.time === time) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(time + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), time);\n\t\t\t} else if (after.type === \"exponential\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), time);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, time);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[Type], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport \"../type/Units\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor\n\t */\n\treadonly defaultContext?: Context;\n\n\tconstructor(context?: Context | Partial<ToneWithContextOptions>) {\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tsuper();\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time: Time): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tGET/SET\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Get the object's attributes. Given no arguments get\n\t * will return all available object properties and their corresponding\n\t * values. Pass in a single attribute to retrieve or an array\n\t * of attributes. The attribute strings can also include a \".\"\n\t * to access deeper properties.\n\t * @param params the parameters to get, otherwise will return all available.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t * @example\n\t * osc.get(\"type\");\n\t * //returns { \"type\" : \"sine\"}\n\t * @example\n\t * //use dot notation to access deep properties\n\t * synth.get([\"envelope.attack\", \"envelope.release\"]);\n\t * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member.get();\n\t\t\t\t} else {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: Partial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tif (isDefined(this[attribute]) && isDefined(this[attribute].value)) {\n\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TypeBaseClass, TypeBaseExpression, TypeBaseUnits } from \"./TypeBase\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds> extends TypeBaseClass<Type> {\n\n\tname = \"Time\";\n\n\tprotected _getExpressions(defaultUnit): TypeBaseExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(defaultUnit), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new TimeClass(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: number | string | TimeObject, percent = 1): Type {\n\t\tconst subdivision = new TimeClass(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\t/**\n\t *  Convert a Time to Notation. The notation values are will be the\n\t *  closest representation between 1m to 128th note.\n\t *  @return {Notation}\n\t *  @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t *  Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t *  Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\nexport function Time(value?: Time, units?: TypeBaseUnits): TimeClass {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { Param } from \"../context/Param\";\nimport \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: Unit;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @param  gain The initial gain of the GainNode\n * @param units The units of the gain parameter.\n */\nexport class Gain<Type extends Unit = \"gain\"> extends ToneAudioNode<GainOptions> {\n\n\treadonly name = \"Gain\";\n\n\t/**\n\t *  The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * Add all of the gain nodes\n\t */\n\tprotected _internalChannels: AudioNode[] = [this._gainNode];\n\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext : this.context,\n\t\t\tconvert : options.convert,\n\t\t\tparam : this._gainNode.gain,\n\t\t\tunits : options.units,\n\t\t\tvalue : options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert : true,\n\t\t\tgain : 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits : \"gain\" as Unit,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","export { connect, disconnect, connectSeries } from \"./context/ToneAudioNode\";\n","// import \"../type/Type\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type PlaybackState = \"started\" | \"stopped\" | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\tduration?: Seconds;\n\toffset?: Seconds;\n}\n\n/**\n *  A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n *  @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline extends Timeline<StateTimelineEvent> {\n\n\t/**\n\t *  The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t *  Returns the scheduled state scheduled before or at\n\t *  the given time.\n\t *  @param  time  The time to query.\n\t *  @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a state to the timeline.\n\t *  @param  state The name of the state to set.\n\t *  @param  time  The time to query.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds): this {\n\t\t// all state changes need to be >= the previous state time\n\t\t// TODO throw error if time < the previous event time\n\t\tthis.add({\n\t\t\tstate,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the event before the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check before\n\t *  @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Return the event after the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check from\n\t *  @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\nimport { TypeBaseUnits } from \"./TypeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\tname = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\nexport function TransportTime(value: Time, units?: TypeBaseUnits): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\tname = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t *  Bind a callback to a specific event.\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Bind a callback which is only invoked once\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[])  => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove the event listener.\n\t *  @param  event     The event to stop listening to.\n\t *  @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                    If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Invoke all of the callbacks bound to the event\n\t *  with any arguments passed in.\n\t *  @param  event  The name of the event.\n\t *  @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import \"./Units\";\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n *  @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n *  Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n *  Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Frequency.ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn 69 + Math.round(12 * Math.log2(frequency / A4));\n}\n","import { Context } from \"../context/Context\";\nimport { getContext } from \"../Global\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { TypeBaseUnits } from \"./TypeBase\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\tname = \"Ticks\";\n\n\treadonly defaultUnits: TypeBaseUnits = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t *  Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t *  Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\nexport function Ticks(value: Time, units?: TypeBaseUnits): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n *\n * @param url The url to load, or the audio buffer to set.\n * @param onload A callback which is invoked after the buffer is loaded.\n *                            It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n *                            since it will give you a callback when _all_ buffers are loaded.\n * @param onerror The callback to invoke if there is an error\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n */\nexport class ToneAudioBuffer extends Tone {\n\n\tname = \"ToneAudioBuffer\";\n\n\t/**\n\t *  stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t *  indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && options.url instanceof AudioBuffer || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t *  Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * \tInvokes the callback once the audio buffer loads.\n\t *  @param url The url of the buffer to load. filetype support depends on the browser.\n\t *  @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tSums multiple channels into 1 channel\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t *  @param  channel  The channel number to return\n\t *  @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t *  Cut a subsection of the array and return a buffer of the\n\t *  subsection. Does not modify the original buffer\n\t *  @param start The time to start the slice\n\t *  @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.length): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tconst replacementArray: Float32Array[] = [];\n\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\treplacementArray[i] = this.toArray(i).slice(startSamples, endSamples) as Float32Array;\n\t\t}\n\t\tconst retBuffer = new ToneAudioBuffer().fromArray(replacementArray);\n\t\treturn retBuffer;\n\t}\n\n\t/**\n\t *  Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tArray.prototype.reverse.call(this.getChannelData(i));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// STATIC METHODS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t *  Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t *  pass in a multidimensional array.\n\t *  @param array The array to fill the audio buffer\n\t *  @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t *  Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t *  Checks a url's extension to see if the current browser can play that file type.\n\t *  @param url The url/extension to test\n\t *  @return If the file extension can be played\n\t *  @static\n\t *  @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","///////////////////////////////////////////////////////////////////////////\n// INITIALIZING NEW CONTEXT\n///////////////////////////////////////////////////////////////////////////\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isString } from \"../util/TypeCheck\";\nimport { getAudioContext } from \"./AudioContext\";\nimport { initializeContext } from \"./ContextInitialization\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"createScriptProcessor\" | \"onstatechange\" | \"addEventListener\"\n\t| \"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\";\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: BaseAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\tname = \"Context\";\n\n\t/**\n\t *  The amount of time into the future events are scheduled\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: BaseAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t *  The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t *  An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t *  All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t *  The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\tconstructor(context?: BaseAudioContext);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.addEventListener(\"statechange\", () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tinitialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// BASE AUDIO CONTEXT METHODS\n\t///////////////////////////////////////////////////////////////////////\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode {\n\t\treturn this._context.createIIRFilter(feedforward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t *  The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t *  There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t *  A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TICKER\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  How often the interval callback is invoked.\n\t *  This number corresponds to how responsive the scheduling\n\t *  can be. context.updateInterval + context.lookAhead gives you the\n\t *  total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t *  What the source of the clock is, either \"worker\" (default),\n\t *  \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t *  The unwrapped AudioContext.\n\t */\n\tget rawContext(): BaseAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t *  The current audio context time\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t *  Starts the audio context from a suspended state. This is required\n\t *  to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && this._context instanceof AudioContext) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t *  Promise which is invoked when the context is running.\n\t *  Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<Context> {\n\t\tif (this._context instanceof AudioContext) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TIMEOUTS\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The private loop which keeps track of the context scheduled timeouts\n\t *  Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void  {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t *  A setTimeout which is guarented by the clock source.\n\t *  Also runs in the offline context.\n\t *  @param  fn       The callback to invoke\n\t *  @param  timeout  The timeout in seconds\n\t *  @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback : fn,\n\t\t\tid : this._timeoutIds,\n\t\t\ttime : now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t *  Clears a previously scheduled timeout with Tone.context.setTimeout\n\t *  @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): Context {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[Tone.Oscillator](Oscillator) is better for most use-cases***\n *  @extends {Tone.AudioNode}\n *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n *  @param  {Function}  onload  The callback to invoke when the\n *                               buffer is done playing.\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\tname = \"ToneOscillatorNode\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._gainNode, this._oscillator];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t *  The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.frequency,\n\t\t\tunits : \"frequency\",\n\t\t\tvalue : this.toFrequency(options.frequency),\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.detune,\n\t\t\tunits : \"cents\",\n\t\t\tvalue : options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tthis.log(\"start\", time);\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t *  @return  {OscillatorNode}  this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"Tone/core/Tone\";\nimport { PlaybackState } from \"Tone/core/util/StateTimeline\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: () => void;\n}\n\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The callback to invoke after the\n\t *  source is done playing.\n\t */\n\tonended: () => void = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t *  The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t *  The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain : 0,\n\t});\n\n\t/**\n\t *  The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time = 0;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time = 0;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: \"linear\" | \"exponential\" = \"linear\";\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tonended : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\tthis._stopSource(this.now());\n\t\t\tthis.onended();\n\t\t\t// disconnect when it's ended, to free up for garbage collection\n\t\t\tsetTimeout(() => this._gainNode.disconnect(), 100);\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t *  Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n *  @class Wrapper around the native BufferSourceNode.\n *  @extends {Tone.AudioNode}\n *  @param  buffer   The buffer to play\n *  @param  onended  The callback to invoke when the buffer is done playing.\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\tname = \"ToneBufferSource\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._gainNode, this._source];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = this._stopSource.bind(this);\n\n\t\t/**\n\t\t *  The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._source.playbackRate,\n\t\t\tunits : \"positive\",\n\t\t\tvalue : options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tcurve: \"linear\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): \"linear\" | \"exponential\" {\n\t\treturn this._curve;\n\t}\n\tset curve(t: \"linear\" | \"exponential\") {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t *  Start the buffer\n\t *  @param  time When the player should start.\n\t *  @param  offset The offset from the beginning of the sample to start at.\n\t *  @param  duration How long the sample should play. If no duration\n\t *                   is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t *  @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\ttime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(time, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\toffset = this.toSeconds(offset);\n\t\t// make sure the offset is not less than 0\n\t\toffset = Math.max(offset, 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (offset >= loopEnd) {\n\t\t\t\toffset = ((offset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (offset < this.buffer.duration) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(time, offset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(time + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(): void {\n\t\tif (!this._sourceStopped) {\n\t\t\tthis._sourceStopped = true;\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? this.toSeconds(this._fadeOut) * 2 : 0;\n\t\t\tif (this._sourceStarted && this._stopTime !== -1) {\n\t\t\t\tthis._source.stop(this._stopTime + additionalTail);\n\t\t\t}\n\n\t\t\tthis.onended();\n\t\t\t// remove the onended callback\n\t\t\tthis.onended = noOp;\n\n\t\t\t// dispose the source after it's come to a stop\n\t\t\tsetTimeout(() => {\n\t\t\t\t// if it hasn't already been disposed\n\t\t\t\tif (this._source) {\n\t\t\t\t\tthis._source.disconnect();\n\t\t\t\t\tthis._gainNode.disconnect();\n\t\t\t\t}\n\t\t\t}, additionalTail * 1000 + 100);\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t * @memberOf ToneBufferSource#\n\t * @type {Tone.Buffer}\n\t * @name buffer\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class  Base class for sources. Sources have start/stop methods\n *          and the ability to be synced to the\n *          start/stop of this.context.transport.\n *\n *  @constructor\n *  @extends {Tone.AudioNode}\n *  @example\n * //Multiple state change events can be chained together,\n * //but must be set in the correct order and with ascending times\n *\n * // OK\n * state.start().stop(\"+0.2\");\n * // AND\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n *\n * // BAD\n * state.stop(\"+0.2\").start();\n * // OR\n * state.start(\"+0.3\").stop(\"+0.2\");\n *\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output volume node\n\t *  @type  {Tone.Volume}\n\t *  @private\n\t */\n\tprivate _volume: Volume = new Volume({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * The output note\n\t */\n\toutput = this._volume;\n\tprotected _internalChannels = [this.output];\n\n\t/**\n\t * There is no input\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @type {Decibels}\n\t * @signal\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume = this._volume.volume;\n\n\t/**\n\t * \tKeep track of the scheduled state.\n\t *  @type {Tone.StateTimeline}\n\t *  @private\n\t */\n\tprotected _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The synced `start` callback function from the transport\n\t *  @type {Function}\n\t *  @private\n\t */\n\tprivate _synced = false;\n\n\t/**\n\t *  Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: Partial<SourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\treadOnly(this, \"volume\");\n\t\tthis._state.memory = 100;\n\t\tthis.volume.value = options.volume;\n\t\t// set mute initially\n\t\tthis.mute = options.mute;\n\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds);\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t *  Start the source at the specified time. If no time is given,\n\t *  start the source now.\n\t *  @param  {Time} [time=now] When the source should be started.\n\t *  @returns {Source} this\n\t *  @example\n\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tif (isUndef(time) && this._synced) {\n\t\t\ttime = this.context.transport.seconds;\n\t\t} else {\n\t\t\ttime = this.toSeconds(time);\n\t\t\ttime = Math.max(time, this.context.currentTime);\n\t\t}\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._state.setStateAtTime(\"started\", time);\n\t\t\tthis.restart(time, offset, duration);\n\t\t} else {\n\t\t\tthis._state.setStateAtTime(\"started\", time);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(time);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = this.toSeconds(duration);\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, time);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the source at the specified time. If no time is given,\n\t *  stop the source now.\n\t *  @param  {Time} [time=now] When the source should be stopped.\n\t *  @returns {Source} this\n\t *  @example\n\t * source.stop(); // stops the source immediately\n\t */\n\tstop(time?: Time): this {\n\t\tif (isUndef(time) && this._synced) {\n\t\t\ttime = this.context.transport.seconds;\n\t\t} else {\n\t\t\ttime = this.toSeconds(time);\n\t\t\ttime = Math.max(time, this.context.currentTime);\n\t\t}\n\t\tif (!this._synced) {\n\t\t\tthis._stop.apply(this, arguments);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), time);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(time);\n\t\tthis._state.setStateAtTime(\"stopped\", time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the source to the Transport so that all subsequent\n\t *  calls to `start` and `stop` are synced to the TransportTime\n\t *  instead of the AudioContext time.\n\t *\n\t * @example\n\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * source.sync().start(0).stop(0.3);\n\t * //start the transport.\n\t * this.context.transport.start();\n\t *\n\t * @example\n\t * //start the transport with an offset and the sync'ed sources\n\t * //will start in the correct position\n\t * source.sync().start(0.1);\n\t * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)\n\t * this.context.transport.start(\"+0.5\", 0.5);\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by (Tone.Transport)[Transport]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n * @param Transport The transport object which the event belongs to\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class Volume is a simple volume node, useful for creating a volume fader.\n *\n *  @extends {Tone.AudioNode}\n *  @constructor\n *  @param {Decibels} [volume=0] the initial volume\n *  @example\n * var vol = new Volume(-12);\n * instrument.chain(vol, Tone.Master);\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\tname = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<\"decibels\"> = new Gain({\n\t\tcontext: this.context,\n\t\tunits: \"decibels\",\n\t});\n\tprotected _internalChannels = [this.output];\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput = this.output;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t *  The volume control in decibels.\n\t */\n\tvolume: Param<\"decibels\"> = this.output.gain;\n\n\tconstructor(options?: Decibels | Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.volume.value = options.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * volume.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\tname = \"IntervalTimeline\";\n\n\t/**\n\t *  The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t *  Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t *  The event to add to the timeline. All events must\n\t *  have a time and duration value\n\t *  @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t *  @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t *  Remove events whose time time is after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Replace the references to the node in the node's parent\n\t *  with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t *  Remove the node from the tree and replace it with\n\t *  a successor which follows the schema.\n\t */\n\tprivate _removeNode(node): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t *  Rotate the tree to the left\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateLeft(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tnode.right = pivotNode.left;\n\t\tpivotNode.left = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Rotate the tree to the right\n\t *  @param  {IntervalNode}  node\n\t *  @private\n\t */\n\t_rotateRight(node): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tnode.left = pivotNode.right;\n\t\tpivotNode.right = node;\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get an event whose time and duration span the give time. Will\n\t *  return the match whose \"time\" value is closest to the given time.\n\t *  @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *  Iterate over everything in the timeline.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the given time\n\t *  overlaps with the time and duration time of the event.\n\t *  @param  time The time to check if items are overlapping\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: IntervalTimelineEvent) => void): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the time is greater\n\t *  than or equal to the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time, callback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINTERVAL NODE HELPER\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Represents a node in the binary search tree, with the addition\n *  of a \"high\" value which keeps track of the highest value of\n *  its children.\n *  References:\n *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n *  @param low\n *  @param high\n */\n// tslint:disable-next-line: max-classes-per-file\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low, high, event) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t *  Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which overlap\n\t *  with the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which are less\n\t *  than the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Invoke the callback on this element and both it's branches\n\t *  @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t *  The balance is how the leafs are distributed on the node\n\t *  @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t *  @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t *  get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter, EmitterEventObject } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n *\n * @param callback The callback to be invoked with the time of the audio event\n * @param frequency The rate of the callback\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n */\nexport class Clock<Type extends \"bpm\" | \"hertz\" = \"hertz\">\nextends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\tname = \"Clock\";\n\n\t/**\n\t *  The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t *  The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t *  The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t *  Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t *  The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\tthis.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t *  @param time The time when the clock should stop.\n\t *  @returns {Clock} this\n\t *  @example\n\t * clock.stop();\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t *  The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TypeBaseExpression } from \"./TypeBase\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n */\nexport class FrequencyClass extends TimeClass<Hertz> {\n\n\tname = \"Frequency\";\n\n\treadonly defaultUnits = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUGMENT BASE EXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tprotected _getExpressions(defaultUnit): TypeBaseExpression<Hertz> {\n\t\treturn Object.assign({}, super._getExpressions(defaultUnit), {\n\t\t\tmidi : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this._defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote : {\n\t\t\t\tregexp : /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this._defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tEXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t *  @return  A new transposed frequency\n\t *  @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t *  Takes an array of semitone intervals and returns\n\t *  an array of frequencies transposed by those intervals.\n\t *  @return  Returns an array of Frequencies\n\t *  @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t *  @return  {MIDI}\n\t *  @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn FrequencyClass.ftom(this.valueOf());\n\t}\n\n\t/**\n\t *  Return the value of the frequency in Scientific Pitch Notation\n\t *  @return  {Note}\n\t *  @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS HELPERS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  With no arguments, return 0\n\t */\n\tprotected _noArg(): Hertz {\n\t\treturn 0;\n\t}\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Hertz {\n\t\treturn freq;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Hertz {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ()));\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Hertz {\n\t\treturn 1 / super._beatsToUnits(beats);\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Hertz {\n\t\treturn 1 / seconds;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn FrequencyClass.A4 * Math.pow(2, (midi - 69) / 12);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tFREQUENCY CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Note to scale index\n *  @type  {Object}\n *  @private\n */\nconst noteToScaleIndex = {\n\t// tslint:disable-next-line\n\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n};\n\n/**\n *  scale index to note (sharps)\n *  @type  {Array}\n *  @private\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\nexport function Frequency(value, units?): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","export const version = \"14.0.0\";\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\ninterface SignalOptions extends ToneAudioNodeOptions {\n\tvalue: any;\n\tunits: Unit;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *  @param value Initial value of the signal\n *  @param units unit The units the signal is in.\n * @example\n * const signal = new Tone.Signal(10);\n */\nexport class Signal<Type extends Unit = \"number\"> extends ToneAudioNode<SignalOptions>\nimplements AbstractParam<Type> {\n\n\tname = \"Signal\";\n\n\tstatic getDefaults(): SignalOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannelCount: 1,\n\t\t\tchannelCountMode: \"explicit\",\n\t\t\tchannelInterpretation: \"discrete\",\n\t\t\tconvert: true,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t\tunits: \"number\" as Unit,\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprivate _constantSource: ConstantSourceNode = this.context.createConstantSource();\n\treadonly output: AudioNode = this._constantSource;\n\tprivate _param: Param<Type>;\n\treadonly input: Param<Type>;\n\tprotected _internalChannels = [this._constantSource];\n\n\tconstructor(value?: UnitMap[Type], units?: Unit);\n\tconstructor(options?: Partial<SignalOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tif (destination instanceof Param || destination instanceof AudioParam || destination instanceof Signal) {\n\t\t\t// cancel changes\n\t\t\tdestination.cancelScheduledValues(0);\n\t\t\t// reset the value\n\t\t\tdestination.setValueAtTime(0, 0);\n\t\t\t// mark the value as overridden\n\t\t\tif (destination instanceof Signal) {\n\t\t\t\tdestination.overridden = true;\n\t\t\t}\n\t\t}\n\t\tsuper.connect(destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): UnitMap[Type] {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: UnitMap[Type], time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: UnitMap[Type], startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: Array<UnitMap[Type]>, startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: UnitMap[Type], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): UnitMap[Type] {\n\t\treturn this._param.value;\n\t}\n\tset value(value: UnitMap[Type]) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): Unit {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): UnitMap[Type] {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): UnitMap[Type] {\n\t\treturn this._param.minValue;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneOscillatorNode } from \"./OscillatorNode\";\n\ntype ToneOscillatorType = OscillatorType | string;\n\ninterface OscillatorOptions extends SourceOptions {\n\ttype: ToneOscillatorType;\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tphase: Degrees;\n\tpartials: number[];\n\tpartialCount: number;\n}\n\n/**\n *  Oscillator supports a number of features including\n *  phase rotation, multiple oscillator types (see Oscillator.type),\n *  and Transport syncing (see Oscillator.syncFrequency).\n *\n *  @param frequency Starting frequency\n *  @param type The oscillator type. Read more about type below.\n *  @example\n * //make and start a 440hz sine tone\n * var osc = new Oscillator(440, \"sine\").toMaster().start();\n */\nexport class Oscillator extends Source<OscillatorOptions> {\n\n\tname = \"Oscillator\";\n\n\t/**\n\t *  the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t *  the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t *  The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t *  the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase: Radians;\n\n\t/**\n\t *  the type of the oscillator\n\t *  @type {string}\n\t *  @private\n\t */\n\tprivate _type;\n\n\tconstructor(options?: Partial<OscillatorOptions>)\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._phase = options.phase;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString();\n\t\t}\n\t\tthis.phase = this._phase;\n\t}\n\n\tstatic getDefaults(): OscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tthis.log(\"start\", time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// disconnect onended\n\t\toscillator.onended = () => {\n\t\t\t// defer the callback for the offline context rendering\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.frequency.disconnect(oscillator.frequency);\n\t\t\t\tthis.detune.disconnect(oscillator.detune);\n\t\t\t}, 100);\n\t\t};\n\n\t\t// start the oscillator\n\t\ttime = this.toSeconds(time);\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tif (this._oscillator) {\n\t\t\ttime = this.toSeconds(time);\n\t\t\tthis._oscillator.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t *  will also affect the oscillators frequency.\n\t *  @example\n\t * Tone.Transport.bpm.value = 120;\n\t * osc.frequency.value = 440;\n\t * //the ration between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * Tone.Transport.bpm.value = 240;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the oscillator's frequency from the Transport.\n\t *  See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/* tslint:disable */\n\t/**\n\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t * 8 partials of the triangle wave.\n\t * <br><br>\n\t * Uses PeriodicWave internally even for native types so that it can set the phase.\n\t * PeriodicWave equations are from the\n\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t *\n\t * @memberOf Oscillator#\n\t * @type {string}\n\t * @name type\n\t * @example\n\t * //set it to a square wave\n\t * osc.type = \"square\";\n\t * @example\n\t * //set the first 6 partials of a sawtooth wave\n\t * osc.type = \"sawtooth6\";\n\t */\n\t/* tslint:enable */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\n\tset type(type: ToneOscillatorType) {\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\tthis._wave = periodicWave;\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t}\n\t\t}\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._type.replace(this.partialCount, \"\");\n\t}\n\n\tset baseType(baseType: OscillatorType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @example\n\t * osc.type = 'sine'\n\t * osc.partialCount = 3\n\t * //is equivalent to\n\t * osc.type = 'sine3'\n\t */\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p: number) {\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1];\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get the object's attributes. Given no arguments get\n\t *  will return all available object properties and their corresponding\n\t *  values.\n\t */\n\tget(): OscillatorOptions {\n\t\tconst values = super.get();\n\t\tif (values.type !== \"custom\") {\n\t\t\tdelete values.partials;\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t *  Returns the real and imaginary components based\n\t *  on the oscillator type.\n\t *  @returns [real: Float32Array, imaginary: Float32Array]\n\t *  @private\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1];\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\t// tslint:disable: no-bitwise\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t *  Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t *  Returns the initial value of the oscillator.\n\t */\n\tprotected _getInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\t// check for peaks in 8 places\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / 8) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis.type = \"custom\";\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t * @example\n\t * osc.phase = 180; //flips the phase of the oscillator\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\t/**\n\t *  Dispose and disconnect.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/BufferSource\";\n\ntype NoiseType = \"white\" | \"brown\" | \"pink\";\n\ninterface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @param type the noise type (white|pink|brown)\n * @example\n * //initialize the noise and start\n * var noise = new Noise(\"pink\").start();\n *\n * //make an autofilter to shape the noise\n * var autoFilter = new Tone.AutoFilter({\n * \t\"frequency\" : \"8m\",\n * \t\"min\" : 800,\n * \t\"max\" : 15000\n * }).connect(Tone.Master);\n *\n * //connect the noise\n * noise.connect(autoFilter);\n * //start the autofilter LFO\n * autoFilter.start()\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\tname = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\tconstructor(options?: NoiseType | Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * noise.type = \"white\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t *  internal start method\n\t */\n\tprotected _start(time: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource(buffer).connect(this.output);\n\t\tthis._source.loop = true;\n\t\tthis._source.playbackRate.value = this._playbackRate;\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t *  internal stop method\n\t *\n\t *  @param {Time} time\n\t *  @private\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// THE NOISE BUFFERS\n///////////////////////////////////////////////////////////////////////////\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\t// tslint:disable-next-line: one-variable-per-declaration\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","export { Noise } from \"./Noise\";\nexport { Oscillator } from \"./oscillator/Oscillator\";\nexport { ToneOscillatorNode } from \"./oscillator/OscillatorNode\";\nexport { ToneBufferSource } from \"./buffer/BufferSource\";\n","import { Context } from \"../context/Context\";\nimport { Ticks, TicksClass } from \"../type/Ticks\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: Context;\n\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = Ticks(options.duration).valueOf();\n\t\tthis._interval = Ticks(options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { Time, TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { Param } from \"../context/Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * //repeated event every 8th note\n * Transport.scheduleRepeat(function(time){\n * \t//do something with the time\n * }, \"8n\");\n * @example\n * //schedule an event on the 16th measure\n * Transport.schedule(function(time){\n * \t//do something with the time\n * }, \"16:0:0\");\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\tname = \"Transport\";\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tLOOPING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * \tIf the transport loops or not.\n\t */\n\tloop: boolean = false;\n\n\t/**\n\t * \tThe loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * \tThe loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tCLOCK/TEMPO\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t *  watches the main oscillator for timing ticks\n\t *  initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * Transport.bpm.value = 80;\n\t * //ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: Param<\"bpm\">;\n\n\t/**\n\t *  The time signature, or more accurately the numerator\n\t *  of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tTIMELINE EVENTS\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * \tThe scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t *  Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t *  All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tSWING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t *  The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback : this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency : 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tTICKS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  called on every tick\n\t *  @param  tickTime clock relative tick time\n\t *  @private\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this.loop) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSCHEDULABLE EVENTS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * //trigger the callback when the Transport reaches the desired time\n\t * Transport.schedule(function(time){\n\t * \tenvelope.triggerAttack(time);\n\t * }, \"128i\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * //a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration : new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime : new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t *  Schedule an event that will be removed after it is invoked.\n\t *  @param callback The callback to invoke once.\n\t *  @param time The time the callback should be invoked.\n\t *  @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce : true,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSTART/STOP/PAUSE\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * //start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSETTERS/GETTERS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * //common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * //this will be reduced to a single number\n\t * Transport.timeSignature; //returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn Time(this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn Time(this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * //loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's position in seconds\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's loop position as a normalized value. Always\n\t *  returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t *  Pulses Per Quarter note. This is the smallest resolution\n\t *  the Transport timing supports. This should be set once\n\t *  on initialization and not set again. Changing this value\n\t *  after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSYNCING\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * Transport.start(); //the transport must be started\n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t *  Attaches the signal to the tempo control signal so that\n\t *  any changes in the tempo will change the signal in the same\n\t *  ratio.\n\t *\n\t *  @param signal\n\t *  @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial : signal.value,\n\t\t\tratio : ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsyncs a previously synced signal from the transport's control.\n\t *  See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n///////////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  A single master output which is connected to the\n *  AudioDestinationNode (aka your speakers).\n *  It provides useful conveniences such as the ability\n *  to set the volume and mute the entire application.\n *  It also gives you the ability to apply master effects to your application.\n *\n *  @example\n * //the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * //a convenience for connecting to the master output is also provided:\n * oscillator.toMaster();\n * //the above two examples are equivalent.\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\tname = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<\"decibels\"> = this.input.volume;\n\t_internalChannels = [this.input, this.output];\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.volume.value = options.volume;\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t *  chained in the master effects chain.\n\t *  @param nodes All arguments will be connected in a row and the Master will be routed through it.\n\t *  @return  {Destination}  this\n\t *  @example\n\t * //some overall compression to keep the levels in check\n\t * var masterCompressor = new Tone.Compressor({\n\t * \t\"threshold\" : -6,\n\t * \t\"ratio\" : 3,\n\t * \t\"attack\" : 0.5,\n\t * \t\"release\" : 0.1\n\t * });\n\t * //give a little boost to the lows\n\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t * //route everything through the filter\n\t * //and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\tname = \"Draw\";\n\n\t/**\n\t *  The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t *  The amount of time before the scheduled time\n\t *  that the callback can be invoked. Default is\n\t *  half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t *  All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t *  Schedule a function at the given time to be invoked\n\t *  on the nearest animation frame.\n\t *  @param  callback  Callback is invoked at the given time.\n\t *  @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime : this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events scheduled after the given time\n\t *  @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../Connect\";\nimport { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { getContext } from \"../Global\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ninterface TickAutomationEvent extends AutomationEvent {\n\tticks: number;\n}\n\ninterface TickSignalOptions extends ParamOptions {\n\tvalue: Hertz | BPM;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n *\n * @param value The initial value of the signal\n */\nexport class TickSignal<Type extends \"hertz\" | \"bpm\"> extends Param<Type> {\n\n\tname = \"TickSignal\";\n\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\tprivate _sig: ConstantSourceNode = this.context.createConstantSource();\n\n\tprotected _param = this._sig.offset;\n\n\tprivate _multiplier: number = 1;\n\n\tconstructor(options: Partial<TickSignalOptions>);\n\tconstructor(value?: number);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._sig = this.context.createConstantSource();\n\t\tthis._sig.start(0);\n\t\tthis._param = this._sig.offset;\n\n\t\t// set the multiplier\n\t\tthis.multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis.cancelScheduledValues(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime : 0,\n\t\t\ttype : \"setValue\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickSignalOptions {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tparam: getContext().createConstantSource().offset,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[Type], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[Type], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks : 0,\n\t\t\t\ttime : 0,\n\t\t\t\ttype: \"setValue\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValue\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linear\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[Type]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\tprotected _toType(val: number): UnitMap[Type] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multipler\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n\n\t/**\n\t * Connect the output signal\n\t */\n\tconnect(dstNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnect(this._sig, dstNode, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n *  Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n *\n *  @param frequency The initial frequency that the signal ticks at\n */\nexport class TickSource<Type extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\tname = \"TickSource\";\n\n\t/**\n\t *  The frequency the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t *  The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\tconstructor(frequency?: Frequency);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: this.toFrequency(options.frequency),\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}, ToneWithContext.getDefaults()) as TickSourceOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t *  @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the TickSource has been running. Accounts\n\t *  for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state : \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds : this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Returns the scheduled state at the given time.\n\t *  @param  time  The time to query.\n\t *  @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t *  Invoke the callback event at all scheduled ticks between the\n\t *  start time and the end time\n\t *  @param  startTime  The beginning of the search range\n\t *  @param  endTime    The end of the search range\n\t *  @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: number;\n\tmaxDelay: number;\n}\n\n/**\n *  Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n *  @param delayTime The delay applied to the incoming signal.\n *  @param maxDelay The maximum delay time.\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t *  The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * The internal channels for channel routing changes\n\t */\n\tprotected _internalChannels: AudioNode[];\n\n\tconstructor(options?: Partial<DelayOptions>)\n\tconstructor(delayTime?: Time, maxDelay?: Time)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tthis.maxDelay = Math.max(this.toSeconds(options.maxDelay), this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(options.maxDelay);\n\t\tthis._internalChannels = [this._delayNode];\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._delayNode.delayTime,\n\t\t\tunits : \"time\",\n\t\t\tvalue : options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime : 0,\n\t\t\tmaxDelay: 1,\n\t\t\tnumberOfInputs: 1,\n\t\t\tnumberOfOutputs: 1,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\n\n/**\n *  Wrapper around the OfflineAudioContext\n *  @param  channels  The number of channels to render\n *  @param  duration  The duration to render in samples\n *  @param sampleRate the sample rate to render at\n */\nexport class OfflineContext extends Context {\n\n\tname = \"OfflineContext\";\n\n\t/**\n\t *  A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t *  An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\tconstructor(channels: number | OfflineAudioContext, duration: Seconds, sampleRate: number) {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: channels instanceof OfflineAudioContext ?\n\t\t\t\tchannels : new OfflineAudioContext(channels, duration * sampleRate, sampleRate),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: channels instanceof OfflineAudioContext ?\n\t\t\t\t\t128 / channels.sampleRate : 128 / sampleRate,\n\t\t});\n\n\t\tthis._duration = channels instanceof OfflineAudioContext ?\n\t\t\tchannels.length / channels.sampleRate : duration;\n\t}\n\n\t/**\n\t *  Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t *  Render the output of the OfflineContext\n\t */\n\trender(): Promise<AudioBuffer> {\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t// increment the clock in 5ms chunks\n\t\t\tthis._currentTime += 0.005;\n\t\t}\n\n\t\treturn this._context.startRendering();\n\t}\n\n\t/**\n\t *  Close the context\n\t */\n\tclose(): Promise<OfflineContext> {\n\t\treturn Promise.resolve(this);\n\t}\n}\n","import { Tone } from \"../../core/Tone\";\nimport { Context } from \"../context/Context\";\nimport { getContext } from \"../Global\";\nimport { isDefined, isObject , isString, isUndef } from \"../util/TypeCheck\";\n\ninterface TypeBaseClassOptions {\n\tvalue?: TypeBaseClassValue;\n\tunits?: TypeBaseUnits;\n\tcontext: Context;\n}\n\ntype TypeBaseClassValue = string | number | TimeObject | TypeBaseClass<any>;\n\n/**\n * TypeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @param  val    The time value as a number, string or object\n * @param  units  Unit values\n * @example\n * new TypeBase(4, \"n\")\n * new TypeBase(2, \"t\")\n * new TypeBase(\"2t\")\n * new TypeBase({\"2t\" : 2})\n * new TypeBase(\"2t\") + new TypeBase(\"4n\");\n */\nexport abstract class TypeBaseClass<Type extends Seconds | Hertz | Ticks> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TypeBaseClassValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: TypeBaseUnits;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TypeBaseExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: TypeBaseUnits = \"s\";\n\n\tconstructor(context: Context, value?: TypeBaseClassValue, units?: TypeBaseUnits) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\n\t\tthis._expressions = this._getExpressions(this.defaultUnits);\n\n\t\tif (value instanceof TypeBaseClass) {\n\t\t\tthis.fromType(value);\n\t\t}\n\t}\n\n\tstatic getDefaults(): TypeBaseClassOptions {\n\t\treturn {\n\t\t\tcontext : getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(defaultUnit: TypeBaseUnits): TypeBaseExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[defaultUnit].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tVALUE OF\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as TypeBaseUnits;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t *  @private\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t *  With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tTEMPO CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tCONVERSION INTERFACE\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TypeBaseClass<any>): void {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t *  Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t *  Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t *  Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t *  Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\treturn this;\n\t}\n}\n/**\n * The units that the TypeBase can accept. extended by other classes\n */\nexport type TypeBaseUnits = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\n/**\n * The format of the type conversion expressions\n */\nexport type TypeBaseExpression<T> = {\n\t[key in TypeBaseUnits]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => T;\n\t};\n};\n","/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseAudioContext;\n\n// @ts-ignore\nglobalContext = window.TONE_AUDIO_CONTEXT;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): BaseAudioContext {\n\tif (!globalContext) {\n\t\tsetAudioContext(new AudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: BaseAudioContext): void {\n\tglobalContext = context;\n\t// @ts-ignore\n\twindow.TONE_AUDIO_CONTEXT = globalContext;\n}\n","\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t *  Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t// the initial timeout time\n\t\t\t`var timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();`,\n\t\t]);\n\t\tconst blobUrl = window.URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = window.setTimeout(()  => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","export { Gain } from \"./context/Gain\";\nexport { Context } from \"./context/Context\";\nexport { OfflineContext } from \"./context/OfflineContext\";\nexport { Param } from \"./context/Param\";\nexport { ToneAudioBuffer } from \"./context/ToneAudioBuffer\";\nexport { Delay } from \"./context/Delay\";\nexport { Clock } from \"./clock/Clock\";\nexport { Frequency, FrequencyClass } from \"./type/Frequency\";\nexport { Time, TimeClass } from \"./type/Time\";\nexport { Ticks, TicksClass } from \"./type/Ticks\";\nexport { TransportTime, TransportTimeClass } from \"./type/TransportTime\";\nexport { Draw } from \"./util/Draw\";\nexport { StateTimeline } from \"./util/StateTimeline\";\nexport { IntervalTimeline } from \"./util/IntervalTimeline\";\nexport { Timeline } from \"./util/Timeline\";\nexport { Emitter } from \"./util/Emitter\";\nexport { Tone } from \"./Tone\";\nexport { Destination } from \"./context/Destination\";\nexport { Transport } from \"./clock/Transport\";\n","export * from \"./core/index\";\nexport * from \"./source/index\";\n"],"sourceRoot":""}